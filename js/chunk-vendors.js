(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["chunk-vendors"], {
    "00ee": function(t, e, n) {
        var i = n("b622")
            , r = i("toStringTag")
            , o = {};
        o[r] = "z",
            t.exports = "[object z]" === String(o)
    },
    "0366": function(t, e, n) {
        var i = n("1c0b");
        t.exports = function(t, e, n) {
            if (i(t),
            void 0 === e)
                return t;
            switch (n) {
                case 0:
                    return function() {
                        return t.call(e)
                    }
                        ;
                case 1:
                    return function(n) {
                        return t.call(e, n)
                    }
                        ;
                case 2:
                    return function(n, i) {
                        return t.call(e, n, i)
                    }
                        ;
                case 3:
                    return function(n, i, r) {
                        return t.call(e, n, i, r)
                    }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }
    },
    "06cf": function(t, e, n) {
        var i = n("83ab")
            , r = n("d1e7")
            , o = n("5c6c")
            , s = n("fc6a")
            , a = n("c04e")
            , c = n("5135")
            , l = n("0cfb")
            , u = Object.getOwnPropertyDescriptor;
        e.f = i ? u : function(t, e) {
            if (t = s(t),
                e = a(e, !0),
                l)
                try {
                    return u(t, e)
                } catch (n) {}
            if (c(t, e))
                return o(!r.f.call(t, e), t[e])
        }
    },
    "0b25": function(t, e, n) {
        var i = n("a691")
            , r = n("50c4");
        t.exports = function(t) {
            if (void 0 === t)
                return 0;
            var e = i(t)
                , n = r(e);
            if (e !== n)
                throw RangeError("Wrong length or index");
            return n
        }
    },
    "0cfb": function(t, e, n) {
        var i = n("83ab")
            , r = n("d039")
            , o = n("cc12");
        t.exports = !i && !r((function() {
                return 7 != Object.defineProperty(o("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
        ))
    },
    1448: function(t, e, n) {
        var i = n("ebb5").aTypedArrayConstructor
            , r = n("4840");
        t.exports = function(t, e) {
            var n = r(t, t.constructor)
                , o = 0
                , s = e.length
                , a = new (i(n))(s);
            while (s > o)
                a[o] = e[o++];
            return a
        }
    },
    "145e": function(t, e, n) {
        "use strict";
        var i = n("7b0b")
            , r = n("23cb")
            , o = n("50c4")
            , s = Math.min;
        t.exports = [].copyWithin || function(t, e) {
            var n = i(this)
                , a = o(n.length)
                , c = r(t, a)
                , l = r(e, a)
                , u = arguments.length > 2 ? arguments[2] : void 0
                , h = s((void 0 === u ? a : r(u, a)) - l, a - c)
                , d = 1;
            l < c && c < l + h && (d = -1,
                l += h - 1,
                c += h - 1);
            while (h-- > 0)
                l in n ? n[c] = n[l] : delete n[c],
                    c += d,
                    l += d;
            return n
        }
    },
    "159b": function(t, e, n) {
        var i = n("da84")
            , r = n("fdbc")
            , o = n("17c2")
            , s = n("9112");
        for (var a in r) {
            var c = i[a]
                , l = c && c.prototype;
            if (l && l.forEach !== o)
                try {
                    s(l, "forEach", o)
                } catch (u) {
                    l.forEach = o
                }
        }
    },
    "170b": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("50c4")
            , o = n("23cb")
            , s = n("4840")
            , a = i.aTypedArray
            , c = i.exportTypedArrayMethod;
        c("subarray", (function(t, e) {
                var n = a(this)
                    , i = n.length
                    , c = o(t, i);
                return new (s(n, n.constructor))(n.buffer,n.byteOffset + c * n.BYTES_PER_ELEMENT,r((void 0 === e ? i : o(e, i)) - c))
            }
        ))
    },
    "17c2": function(t, e, n) {
        "use strict";
        var i = n("b727").forEach
            , r = n("a640")
            , o = r("forEach");
        t.exports = o ? [].forEach : function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    },
    "182d": function(t, e, n) {
        var i = n("f8cd");
        t.exports = function(t, e) {
            var n = i(t);
            if (n % e)
                throw RangeError("Wrong offset");
            return n
        }
    },
    "19aa": function(t, e) {
        t.exports = function(t, e, n) {
            if (!(t instanceof e))
                throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
            return t
        }
    },
    "1be4": function(t, e, n) {
        var i = n("d066");
        t.exports = i("document", "documentElement")
    },
    "1c0b": function(t, e) {
        t.exports = function(t) {
            if ("function" != typeof t)
                throw TypeError(String(t) + " is not a function");
            return t
        }
    },
    "1c7e": function(t, e, n) {
        var i = n("b622")
            , r = i("iterator")
            , o = !1;
        try {
            var s = 0
                , a = {
                next: function() {
                    return {
                        done: !!s++
                    }
                },
                return: function() {
                    o = !0
                }
            };
            a[r] = function() {
                return this
            }
                ,
                Array.from(a, (function() {
                        throw 2
                    }
                ))
        } catch (c) {}
        t.exports = function(t, e) {
            if (!e && !o)
                return !1;
            var n = !1;
            try {
                var i = {};
                i[r] = function() {
                    return {
                        next: function() {
                            return {
                                done: n = !0
                            }
                        }
                    }
                }
                    ,
                    t(i)
            } catch (c) {}
            return n
        }
    },
    "1cdc": function(t, e, n) {
        var i = n("342f");
        t.exports = /(iphone|ipod|ipad).*applewebkit/i.test(i)
    },
    "1d80": function(t, e) {
        t.exports = function(t) {
            if (void 0 == t)
                throw TypeError("Can't call method on " + t);
            return t
        }
    },
    "1dde": function(t, e, n) {
        var i = n("d039")
            , r = n("b622")
            , o = n("2d00")
            , s = r("species");
        t.exports = function(t) {
            return o >= 51 || !i((function() {
                    var e = []
                        , n = e.constructor = {};
                    return n[s] = function() {
                        return {
                            foo: 1
                        }
                    }
                        ,
                    1 !== e[t](Boolean).foo
                }
            ))
        }
    },
    "219c": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = i.aTypedArray
            , o = i.exportTypedArrayMethod
            , s = [].sort;
        o("sort", (function(t) {
                return s.call(r(this), t)
            }
        ))
    },
    2266: function(t, e, n) {
        var i = n("825a")
            , r = n("e95a")
            , o = n("50c4")
            , s = n("0366")
            , a = n("35a1")
            , c = n("2a62")
            , l = function(t, e) {
            this.stopped = t,
                this.result = e
        };
        t.exports = function(t, e, n) {
            var u, h, d, p, f, m, g, v = n && n.that, y = !(!n || !n.AS_ENTRIES), _ = !(!n || !n.IS_ITERATOR), x = !(!n || !n.INTERRUPTED), b = s(e, v, 1 + y + x), w = function(t) {
                return u && c(u),
                    new l(!0,t)
            }, M = function(t) {
                return y ? (i(t),
                    x ? b(t[0], t[1], w) : b(t[0], t[1])) : x ? b(t, w) : b(t)
            };
            if (_)
                u = t;
            else {
                if (h = a(t),
                "function" != typeof h)
                    throw TypeError("Target is not iterable");
                if (r(h)) {
                    for (d = 0,
                             p = o(t.length); p > d; d++)
                        if (f = M(t[d]),
                        f && f instanceof l)
                            return f;
                    return new l(!1)
                }
                u = h.call(t)
            }
            m = u.next;
            while (!(g = m.call(u)).done) {
                try {
                    f = M(g.value)
                } catch (S) {
                    throw c(u),
                        S
                }
                if ("object" == typeof f && f && f instanceof l)
                    return f
            }
            return new l(!1)
        }
    },
    "23cb": function(t, e, n) {
        var i = n("a691")
            , r = Math.max
            , o = Math.min;
        t.exports = function(t, e) {
            var n = i(t);
            return n < 0 ? r(n + e, 0) : o(n, e)
        }
    },
    "23e7": function(t, e, n) {
        var i = n("da84")
            , r = n("06cf").f
            , o = n("9112")
            , s = n("6eeb")
            , a = n("ce4e")
            , c = n("e893")
            , l = n("94ca");
        t.exports = function(t, e) {
            var n, u, h, d, p, f, m = t.target, g = t.global, v = t.stat;
            if (u = g ? i : v ? i[m] || a(m, {}) : (i[m] || {}).prototype,
                u)
                for (h in e) {
                    if (p = e[h],
                        t.noTargetGet ? (f = r(u, h),
                            d = f && f.value) : d = u[h],
                        n = l(g ? h : m + (v ? "." : "#") + h, t.forced),
                    !n && void 0 !== d) {
                        if (typeof p === typeof d)
                            continue;
                        c(p, d)
                    }
                    (t.sham || d && d.sham) && o(p, "sham", !0),
                        s(u, h, p, t)
                }
        }
    },
    "241c": function(t, e, n) {
        var i = n("ca84")
            , r = n("7839")
            , o = r.concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return i(t, o)
        }
    },
    "25a1": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("d58f").right
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("reduceRight", (function(t) {
                return r(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    2626: function(t, e, n) {
        "use strict";
        var i = n("d066")
            , r = n("9bf2")
            , o = n("b622")
            , s = n("83ab")
            , a = o("species");
        t.exports = function(t) {
            var e = i(t)
                , n = r.f;
            s && e && !e[a] && n(e, a, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    },
    2954: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("4840")
            , o = n("d039")
            , s = i.aTypedArray
            , a = i.aTypedArrayConstructor
            , c = i.exportTypedArrayMethod
            , l = [].slice
            , u = o((function() {
                new Int8Array(1).slice()
            }
        ));
        c("slice", (function(t, e) {
                var n = l.call(s(this), t, e)
                    , i = r(this, this.constructor)
                    , o = 0
                    , c = n.length
                    , u = new (a(i))(c);
                while (c > o)
                    u[o] = n[o++];
                return u
            }
        ), u)
    },
    "2a62": function(t, e, n) {
        var i = n("825a");
        t.exports = function(t) {
            var e = t["return"];
            if (void 0 !== e)
                return i(e.call(t)).value
        }
    },
    "2cf4": function(t, e, n) {
        var i, r, o, s = n("da84"), a = n("d039"), c = n("0366"), l = n("1be4"), u = n("cc12"), h = n("1cdc"), d = n("605d"), p = s.location, f = s.setImmediate, m = s.clearImmediate, g = s.process, v = s.MessageChannel, y = s.Dispatch, _ = 0, x = {}, b = "onreadystatechange", w = function(t) {
            if (x.hasOwnProperty(t)) {
                var e = x[t];
                delete x[t],
                    e()
            }
        }, M = function(t) {
            return function() {
                w(t)
            }
        }, S = function(t) {
            w(t.data)
        }, E = function(t) {
            s.postMessage(t + "", p.protocol + "//" + p.host)
        };
        f && m || (f = function(t) {
                var e = []
                    , n = 1;
                while (arguments.length > n)
                    e.push(arguments[n++]);
                return x[++_] = function() {
                    ("function" == typeof t ? t : Function(t)).apply(void 0, e)
                }
                    ,
                    i(_),
                    _
            }
                ,
                m = function(t) {
                    delete x[t]
                }
                ,
                d ? i = function(t) {
                        g.nextTick(M(t))
                    }
                    : y && y.now ? i = function(t) {
                            y.now(M(t))
                        }
                        : v && !h ? (r = new v,
                            o = r.port2,
                            r.port1.onmessage = S,
                            i = c(o.postMessage, o, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts && p && "file:" !== p.protocol && !a(E) ? (i = E,
                            s.addEventListener("message", S, !1)) : i = b in u("script") ? function(t) {
                                l.appendChild(u("script"))[b] = function() {
                                    l.removeChild(this),
                                        w(t)
                                }
                            }
                            : function(t) {
                                setTimeout(M(t), 0)
                            }
        ),
            t.exports = {
                set: f,
                clear: m
            }
    },
    "2d00": function(t, e, n) {
        var i, r, o = n("da84"), s = n("342f"), a = o.process, c = a && a.versions, l = c && c.v8;
        l ? (i = l.split("."),
            r = i[0] + i[1]) : s && (i = s.match(/Edge\/(\d+)/),
        (!i || i[1] >= 74) && (i = s.match(/Chrome\/(\d+)/),
        i && (r = i[1]))),
            t.exports = r && +r
    },
    3280: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("e58c")
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("lastIndexOf", (function(t) {
                return r.apply(o(this), arguments)
            }
        ))
    },
    "342f": function(t, e, n) {
        var i = n("d066");
        t.exports = i("navigator", "userAgent") || ""
    },
    "34ad": function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
                return r
            }
        ));
        var i = n("5a89")
            , r = function() {
            function t(t) {
                i["E"].call(this, t),
                    this.dracoLoader = null,
                    this.ktx2Loader = null,
                    this.meshoptDecoder = null,
                    this.pluginCallbacks = [],
                    this.register((function(t) {
                            return new s(t)
                        }
                    )),
                    this.register((function(t) {
                            return new c(t)
                        }
                    )),
                    this.register((function(t) {
                            return new l(t)
                        }
                    )),
                    this.register((function(t) {
                            return new a(t)
                        }
                    )),
                    this.register((function(t) {
                            return new r(t)
                        }
                    )),
                    this.register((function(t) {
                            return new u(t)
                        }
                    ))
            }
            function e() {
                var t = {};
                return {
                    get: function(e) {
                        return t[e]
                    },
                    add: function(e, n) {
                        t[e] = n
                    },
                    remove: function(e) {
                        delete t[e]
                    },
                    removeAll: function() {
                        t = {}
                    }
                }
            }
            t.prototype = Object.assign(Object.create(i["E"].prototype), {
                constructor: t,
                load: function(t, e, n, r) {
                    var o, s = this;
                    o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i["F"].extractUrlBase(t),
                        this.manager.itemStart(t);
                    var a = function(e) {
                        r ? r(e) : console.error(e),
                            s.manager.itemError(t),
                            s.manager.itemEnd(t)
                    }
                        , c = new i["l"](this.manager);
                    c.setPath(this.path),
                        c.setResponseType("arraybuffer"),
                        c.setRequestHeader(this.requestHeader),
                        c.setWithCredentials(this.withCredentials),
                        c.load(t, (function(n) {
                                try {
                                    s.parse(n, o, (function(n) {
                                            e(n),
                                                s.manager.itemEnd(t)
                                        }
                                    ), a)
                                } catch (i) {
                                    a(i)
                                }
                            }
                        ), n, a)
                },
                setDRACOLoader: function(t) {
                    return this.dracoLoader = t,
                        this
                },
                setDDSLoader: function() {
                    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                },
                setKTX2Loader: function(t) {
                    return this.ktx2Loader = t,
                        this
                },
                setMeshoptDecoder: function(t) {
                    return this.meshoptDecoder = t,
                        this
                },
                register: function(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
                        this
                },
                unregister: function(t) {
                    return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                        this
                },
                parse: function(t, e, r, s) {
                    var a, c = {}, l = {};
                    if ("string" === typeof t)
                        a = t;
                    else {
                        var u = i["F"].decodeText(new Uint8Array(t,0,4));
                        if (u === h) {
                            try {
                                c[n.KHR_BINARY_GLTF] = new f(t)
                            } catch (M) {
                                return void (s && s(M))
                            }
                            a = c[n.KHR_BINARY_GLTF].content
                        } else
                            a = i["F"].decodeText(new Uint8Array(t))
                    }
                    var d = JSON.parse(a);
                    if (void 0 === d.asset || d.asset.version[0] < 2)
                        s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    else {
                        var p = new H(d,{
                            path: e || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        p.fileLoader.setRequestHeader(this.requestHeader);
                        for (var v = 0; v < this.pluginCallbacks.length; v++) {
                            var x = this.pluginCallbacks[v](p);
                            l[x.name] = x,
                                c[x.name] = !0
                        }
                        if (d.extensionsUsed)
                            for (v = 0; v < d.extensionsUsed.length; ++v) {
                                var b = d.extensionsUsed[v]
                                    , w = d.extensionsRequired || [];
                                switch (b) {
                                    case n.KHR_MATERIALS_UNLIT:
                                        c[b] = new o;
                                        break;
                                    case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        c[b] = new y;
                                        break;
                                    case n.KHR_DRACO_MESH_COMPRESSION:
                                        c[b] = new m(d,this.dracoLoader);
                                        break;
                                    case n.KHR_TEXTURE_TRANSFORM:
                                        c[b] = new g;
                                        break;
                                    case n.KHR_MESH_QUANTIZATION:
                                        c[b] = new _;
                                        break;
                                    default:
                                        w.indexOf(b) >= 0 && void 0 === l[b] && console.warn('THREE.GLTFLoader: Unknown extension "' + b + '".')
                                }
                            }
                        p.setExtensions(c),
                            p.setPlugins(l),
                            p.parse(r, s)
                    }
                }
            });
            var n = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
            };
            function r(t) {
                this.parser = t,
                    this.name = n.KHR_LIGHTS_PUNCTUAL,
                    this.cache = {
                        refs: {},
                        uses: {}
                    }
            }
            function o() {
                this.name = n.KHR_MATERIALS_UNLIT
            }
            function s(t) {
                this.parser = t,
                    this.name = n.KHR_MATERIALS_CLEARCOAT
            }
            function a(t) {
                this.parser = t,
                    this.name = n.KHR_MATERIALS_TRANSMISSION
            }
            function c(t) {
                this.parser = t,
                    this.name = n.KHR_TEXTURE_BASISU
            }
            function l(t) {
                this.parser = t,
                    this.name = n.EXT_TEXTURE_WEBP,
                    this.isSupported = null
            }
            function u(t) {
                this.name = n.EXT_MESHOPT_COMPRESSION,
                    this.parser = t
            }
            r.prototype._markDefs = function() {
                for (var t = this.parser, e = this.parser.json.nodes || [], n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
                ,
                r.prototype._loadLight = function(t) {
                    var e = this.parser
                        , n = "light:" + t
                        , r = e.cache.get(n);
                    if (r)
                        return r;
                    var o, s = e.json, a = s.extensions && s.extensions[this.name] || {}, c = a.lights || [], l = c[t], u = new i["h"](16777215);
                    void 0 !== l.color && u.fromArray(l.color);
                    var h = void 0 !== l.range ? l.range : 0;
                    switch (l.type) {
                        case "directional":
                            o = new i["i"](u),
                                o.target.position.set(0, 0, -1),
                                o.add(o.target);
                            break;
                        case "point":
                            o = new i["Y"](u),
                                o.distance = h;
                            break;
                        case "spot":
                            o = new i["mb"](u),
                                o.distance = h,
                                l.spot = l.spot || {},
                                l.spot.innerConeAngle = void 0 !== l.spot.innerConeAngle ? l.spot.innerConeAngle : 0,
                                l.spot.outerConeAngle = void 0 !== l.spot.outerConeAngle ? l.spot.outerConeAngle : Math.PI / 4,
                                o.angle = l.spot.outerConeAngle,
                                o.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
                                o.target.position.set(0, 0, -1),
                                o.add(o.target);
                            break;
                        default:
                            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
                    }
                    return o.position.set(0, 0, 0),
                        o.decay = 2,
                    void 0 !== l.intensity && (o.intensity = l.intensity),
                        o.name = e.createUniqueName(l.name || "light_" + t),
                        r = Promise.resolve(o),
                        e.cache.add(n, r),
                        r
                }
                ,
                r.prototype.createNodeAttachment = function(t) {
                    var e = this
                        , n = this.parser
                        , i = n.json
                        , r = i.nodes[t]
                        , o = r.extensions && r.extensions[this.name] || {}
                        , s = o.light;
                    return void 0 === s ? null : this._loadLight(s).then((function(t) {
                            return n._getNodeRef(e.cache, s, t)
                        }
                    ))
                }
                ,
                o.prototype.getMaterialType = function() {
                    return i["M"]
                }
                ,
                o.prototype.extendParams = function(t, e, n) {
                    var r = [];
                    t.color = new i["h"](1,1,1),
                        t.opacity = 1;
                    var o = e.pbrMetallicRoughness;
                    if (o) {
                        if (Array.isArray(o.baseColorFactor)) {
                            var s = o.baseColorFactor;
                            t.color.fromArray(s),
                                t.opacity = s[3]
                        }
                        void 0 !== o.baseColorTexture && r.push(n.assignTexture(t, "map", o.baseColorTexture))
                    }
                    return Promise.all(r)
                }
                ,
                s.prototype.getMaterialType = function(t) {
                    var e = this.parser
                        , n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? i["O"] : null
                }
                ,
                s.prototype.extendMaterialParams = function(t, e) {
                    var n = this.parser
                        , r = n.json.materials[t];
                    if (!r.extensions || !r.extensions[this.name])
                        return Promise.resolve();
                    var o = []
                        , s = r.extensions[this.name];
                    if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                    void 0 !== s.clearcoatTexture && o.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
                    void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                    void 0 !== s.clearcoatRoughnessTexture && o.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
                    void 0 !== s.clearcoatNormalTexture && (o.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)),
                    void 0 !== s.clearcoatNormalTexture.scale)) {
                        var a = s.clearcoatNormalTexture.scale;
                        e.clearcoatNormalScale = new i["sb"](a,-a)
                    }
                    return Promise.all(o)
                }
                ,
                a.prototype.getMaterialType = function(t) {
                    var e = this.parser
                        , n = e.json.materials[t];
                    return n.extensions && n.extensions[this.name] ? i["O"] : null
                }
                ,
                a.prototype.extendMaterialParams = function(t, e) {
                    var n = this.parser
                        , i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name])
                        return Promise.resolve();
                    var r = []
                        , o = i.extensions[this.name];
                    return void 0 !== o.transmissionFactor && (e.transmission = o.transmissionFactor),
                    void 0 !== o.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", o.transmissionTexture)),
                        Promise.all(r)
                }
                ,
                c.prototype.loadTexture = function(t) {
                    var e = this.parser
                        , n = e.json
                        , i = n.textures[t];
                    if (!i.extensions || !i.extensions[this.name])
                        return null;
                    var r = i.extensions[this.name]
                        , o = n.images[r.source]
                        , s = e.options.ktx2Loader;
                    if (!s) {
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null
                    }
                    return e.loadTextureImage(t, o, s)
                }
                ,
                l.prototype.loadTexture = function(t) {
                    var e = this.name
                        , n = this.parser
                        , i = n.json
                        , r = i.textures[t];
                    if (!r.extensions || !r.extensions[e])
                        return null;
                    var o = r.extensions[e]
                        , s = i.images[o.source]
                        , a = n.textureLoader;
                    if (s.uri) {
                        var c = n.options.manager.getHandler(s.uri);
                        null !== c && (a = c)
                    }
                    return this.detectSupport().then((function(r) {
                            if (r)
                                return n.loadTextureImage(t, s, a);
                            if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                            return n.loadTexture(t)
                        }
                    ))
                }
                ,
                l.prototype.detectSupport = function() {
                    return this.isSupported || (this.isSupported = new Promise((function(t) {
                            var e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                                e.onload = e.onerror = function() {
                                    t(1 === e.height)
                                }
                        }
                    ))),
                        this.isSupported
                }
                ,
                u.prototype.loadBufferView = function(t) {
                    var e = this.parser.json
                        , n = e.bufferViews[t];
                    if (n.extensions && n.extensions[this.name]) {
                        var i = n.extensions[this.name]
                            , r = this.parser.getDependency("buffer", i.buffer)
                            , o = this.parser.options.meshoptDecoder;
                        if (!o || !o.supported) {
                            if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null
                        }
                        return Promise.all([r, o.ready]).then((function(t) {
                                var e = i.byteOffset || 0
                                    , n = i.byteLength || 0
                                    , r = i.count
                                    , s = i.byteStride
                                    , a = new ArrayBuffer(r * s)
                                    , c = new Uint8Array(t[0],e,n);
                                return o.decodeGltfBuffer(new Uint8Array(a), r, s, c, i.mode, i.filter),
                                    a
                            }
                        ))
                    }
                    return null
                }
            ;
            var h = "glTF"
                , d = 12
                , p = {
                JSON: 1313821514,
                BIN: 5130562
            };
            function f(t) {
                this.name = n.KHR_BINARY_GLTF,
                    this.content = null,
                    this.body = null;
                var e = new DataView(t,0,d);
                if (this.header = {
                    magic: i["F"].decodeText(new Uint8Array(t.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                },
                this.header.magic !== h)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                var r = this.header.length - d
                    , o = new DataView(t,d)
                    , s = 0;
                while (s < r) {
                    var a = o.getUint32(s, !0);
                    s += 4;
                    var c = o.getUint32(s, !0);
                    if (s += 4,
                    c === p.JSON) {
                        var l = new Uint8Array(t,d + s,a);
                        this.content = i["F"].decodeText(l)
                    } else if (c === p.BIN) {
                        var u = d + s;
                        this.body = t.slice(u, u + a)
                    }
                    s += a
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
            function m(t, e) {
                if (!e)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = n.KHR_DRACO_MESH_COMPRESSION,
                    this.json = t,
                    this.dracoLoader = e,
                    this.dracoLoader.preload()
            }
            function g() {
                this.name = n.KHR_TEXTURE_TRANSFORM
            }
            function v(t) {
                i["P"].call(this),
                    this.isGLTFSpecularGlossinessMaterial = !0;
                var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
                    , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
                    , r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
                    , o = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
                    , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
                    , a = {
                    specular: {
                        value: (new i["h"]).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
                this._extraUniforms = a,
                    this.onBeforeCompile = function(t) {
                        for (var i in a)
                            t.uniforms[i] = a[i];
                        t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", o).replace("#include <lights_physical_fragment>", s)
                    }
                    ,
                    Object.defineProperties(this, {
                        specular: {
                            get: function() {
                                return a.specular.value
                            },
                            set: function(t) {
                                a.specular.value = t
                            }
                        },
                        specularMap: {
                            get: function() {
                                return a.specularMap.value
                            },
                            set: function(t) {
                                a.specularMap.value = t,
                                    t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                            }
                        },
                        glossiness: {
                            get: function() {
                                return a.glossiness.value
                            },
                            set: function(t) {
                                a.glossiness.value = t
                            }
                        },
                        glossinessMap: {
                            get: function() {
                                return a.glossinessMap.value
                            },
                            set: function(t) {
                                a.glossinessMap.value = t,
                                    t ? (this.defines.USE_GLOSSINESSMAP = "",
                                        this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                                        delete this.defines.USE_UV)
                            }
                        }
                    }),
                    delete this.metalness,
                    delete this.roughness,
                    delete this.metalnessMap,
                    delete this.roughnessMap,
                    this.setValues(t)
            }
            function y() {
                return {
                    name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                    specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                    getMaterialType: function() {
                        return v
                    },
                    extendParams: function(t, e, n) {
                        var r = e.extensions[this.name];
                        t.color = new i["h"](1,1,1),
                            t.opacity = 1;
                        var o = [];
                        if (Array.isArray(r.diffuseFactor)) {
                            var s = r.diffuseFactor;
                            t.color.fromArray(s),
                                t.opacity = s[3]
                        }
                        if (void 0 !== r.diffuseTexture && o.push(n.assignTexture(t, "map", r.diffuseTexture)),
                            t.emissive = new i["h"](0,0,0),
                            t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1,
                            t.specular = new i["h"](1,1,1),
                        Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor),
                        void 0 !== r.specularGlossinessTexture) {
                            var a = r.specularGlossinessTexture;
                            o.push(n.assignTexture(t, "glossinessMap", a)),
                                o.push(n.assignTexture(t, "specularMap", a))
                        }
                        return Promise.all(o)
                    },
                    createMaterial: function(t) {
                        var e = new v(t);
                        return e.fog = !0,
                            e.color = t.color,
                            e.map = void 0 === t.map ? null : t.map,
                            e.lightMap = null,
                            e.lightMapIntensity = 1,
                            e.aoMap = void 0 === t.aoMap ? null : t.aoMap,
                            e.aoMapIntensity = 1,
                            e.emissive = t.emissive,
                            e.emissiveIntensity = 1,
                            e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap,
                            e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap,
                            e.bumpScale = 1,
                            e.normalMap = void 0 === t.normalMap ? null : t.normalMap,
                            e.normalMapType = i["ob"],
                        t.normalScale && (e.normalScale = t.normalScale),
                            e.displacementMap = null,
                            e.displacementScale = 1,
                            e.displacementBias = 0,
                            e.specularMap = void 0 === t.specularMap ? null : t.specularMap,
                            e.specular = t.specular,
                            e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap,
                            e.glossiness = t.glossiness,
                            e.alphaMap = null,
                            e.envMap = void 0 === t.envMap ? null : t.envMap,
                            e.envMapIntensity = 1,
                            e.refractionRatio = .98,
                            e
                    }
                }
            }
            function _() {
                this.name = n.KHR_MESH_QUANTIZATION
            }
            function x(t, e, n, r) {
                i["u"].call(this, t, e, n, r)
            }
            m.prototype.decodePrimitive = function(t, e) {
                var n = this.json
                    , i = this.dracoLoader
                    , r = t.extensions[this.name].bufferView
                    , o = t.extensions[this.name].attributes
                    , s = {}
                    , a = {}
                    , c = {};
                for (var l in o) {
                    var u = T[l] || l.toLowerCase();
                    s[u] = o[l]
                }
                for (l in t.attributes) {
                    u = T[l] || l.toLowerCase();
                    if (void 0 !== o[l]) {
                        var h = n.accessors[t.attributes[l]]
                            , d = w[h.componentType];
                        c[u] = d,
                            a[u] = !0 === h.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function(t) {
                        return new Promise((function(e) {
                                i.decodeDracoFile(t, (function(t) {
                                        for (var n in t.attributes) {
                                            var i = t.attributes[n]
                                                , r = a[n];
                                            void 0 !== r && (i.normalized = r)
                                        }
                                        e(t)
                                    }
                                ), s, c)
                            }
                        ))
                    }
                ))
            }
                ,
                g.prototype.extendTexture = function(t, e) {
                    return t = t.clone(),
                    void 0 !== e.offset && t.offset.fromArray(e.offset),
                    void 0 !== e.rotation && (t.rotation = e.rotation),
                    void 0 !== e.scale && t.repeat.fromArray(e.scale),
                    void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                        t.needsUpdate = !0,
                        t
                }
                ,
                v.prototype = Object.create(i["P"].prototype),
                v.prototype.constructor = v,
                v.prototype.copy = function(t) {
                    return i["P"].prototype.copy.call(this, t),
                        this.specularMap = t.specularMap,
                        this.specular.copy(t.specular),
                        this.glossinessMap = t.glossinessMap,
                        this.glossiness = t.glossiness,
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this
                }
                ,
                x.prototype = Object.create(i["u"].prototype),
                x.prototype.constructor = x,
                x.prototype.copySampleValue_ = function(t) {
                    for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i * 3 + i, o = 0; o !== i; o++)
                        e[o] = n[r + o];
                    return e
                }
                ,
                x.prototype.beforeStart_ = x.prototype.copySampleValue_,
                x.prototype.afterEnd_ = x.prototype.copySampleValue_,
                x.prototype.interpolate_ = function(t, e, n, i) {
                    for (var r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = 2 * s, c = 3 * s, l = i - e, u = (n - e) / l, h = u * u, d = h * u, p = t * c, f = p - c, m = -2 * d + 3 * h, g = d - h, v = 1 - m, y = g - h + u, _ = 0; _ !== s; _++) {
                        var x = o[f + _ + s]
                            , b = o[f + _ + a] * l
                            , w = o[p + _ + s]
                            , M = o[p + _] * l;
                        r[_] = v * x + y * b + m * w + g * M
                    }
                    return r
                }
            ;
            var b = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            }
                , w = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            }
                , M = {
                9728: i["R"],
                9729: i["B"],
                9984: i["T"],
                9985: i["D"],
                9986: i["S"],
                9987: i["C"]
            }
                , S = {
                33071: i["g"],
                33648: i["Q"],
                10497: i["fb"]
            }
                , E = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            }
                , T = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            }
                , A = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            }
                , L = {
                CUBICSPLINE: void 0,
                LINEAR: i["w"],
                STEP: i["v"]
            }
                , R = {
                OPAQUE: "OPAQUE",
                MASK: "MASK",
                BLEND: "BLEND"
            };
            function C(t, e) {
                return "string" !== typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                    /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
            function P(t) {
                return void 0 === t["DefaultMaterial"] && (t["DefaultMaterial"] = new i["P"]({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: i["o"]
                })),
                    t["DefaultMaterial"]
            }
            function O(t, e, n) {
                for (var i in n.extensions)
                    void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
                        e.userData.gltfExtensions[i] = n.extensions[i])
            }
            function I(t, e) {
                void 0 !== e.extras && ("object" === typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
            }
            function N(t, e, n) {
                for (var i = !1, r = !1, o = 0, s = e.length; o < s; o++) {
                    var a = e[o];
                    if (void 0 !== a.POSITION && (i = !0),
                    void 0 !== a.NORMAL && (r = !0),
                    i && r)
                        break
                }
                if (!i && !r)
                    return Promise.resolve(t);
                var c = []
                    , l = [];
                for (o = 0,
                         s = e.length; o < s; o++) {
                    a = e[o];
                    if (i) {
                        var u = void 0 !== a.POSITION ? n.getDependency("accessor", a.POSITION) : t.attributes.position;
                        c.push(u)
                    }
                    if (r) {
                        u = void 0 !== a.NORMAL ? n.getDependency("accessor", a.NORMAL) : t.attributes.normal;
                        l.push(u)
                    }
                }
                return Promise.all([Promise.all(c), Promise.all(l)]).then((function(e) {
                        var n = e[0]
                            , o = e[1];
                        return i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = o),
                            t.morphTargetsRelative = !0,
                            t
                    }
                ))
            }
            function D(t, e) {
                if (t.updateMorphTargets(),
                void 0 !== e.weights)
                    for (var n = 0, i = e.weights.length; n < i; n++)
                        t.morphTargetInfluences[n] = e.weights[n];
                if (e.extras && Array.isArray(e.extras.targetNames)) {
                    var r = e.extras.targetNames;
                    if (t.morphTargetInfluences.length === r.length) {
                        t.morphTargetDictionary = {};
                        for (n = 0,
                                 i = r.length; n < i; n++)
                            t.morphTargetDictionary[r[n]] = n
                    } else
                        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }
            function F(t) {
                var e, i = t.extensions && t.extensions[n.KHR_DRACO_MESH_COMPRESSION];
                return e = i ? "draco:" + i.bufferView + ":" + i.indices + ":" + k(i.attributes) : t.indices + ":" + k(t.attributes) + ":" + t.mode,
                    e
            }
            function k(t) {
                for (var e = "", n = Object.keys(t).sort(), i = 0, r = n.length; i < r; i++)
                    e += n[i] + ":" + t[n[i]] + ";";
                return e
            }
            function H(t, n) {
                this.json = t || {},
                    this.extensions = {},
                    this.plugins = {},
                    this.options = n || {},
                    this.cache = new e,
                    this.associations = new Map,
                    this.primitiveCache = {},
                    this.meshCache = {
                        refs: {},
                        uses: {}
                    },
                    this.cameraCache = {
                        refs: {},
                        uses: {}
                    },
                    this.lightCache = {
                        refs: {},
                        uses: {}
                    },
                    this.nodeNamesUsed = {},
                    "undefined" !== typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new i["r"](this.options.manager) : this.textureLoader = new i["pb"](this.options.manager),
                    this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                    this.textureLoader.setRequestHeader(this.options.requestHeader),
                    this.fileLoader = new i["l"](this.options.manager),
                    this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            function B(t, e, n) {
                var r = e.attributes
                    , o = new i["c"];
                if (void 0 !== r.POSITION) {
                    var s = n.json.accessors[r.POSITION]
                        , a = s.min
                        , c = s.max;
                    if (void 0 !== a && void 0 !== c) {
                        o.set(new i["tb"](a[0],a[1],a[2]), new i["tb"](c[0],c[1],c[2]));
                        var l = e.targets;
                        if (void 0 !== l) {
                            for (var u = new i["tb"], h = new i["tb"], d = 0, p = l.length; d < p; d++) {
                                var f = l[d];
                                if (void 0 !== f.POSITION) {
                                    s = n.json.accessors[f.POSITION],
                                        a = s.min,
                                        c = s.max;
                                    void 0 !== a && void 0 !== c ? (h.setX(Math.max(Math.abs(a[0]), Math.abs(c[0]))),
                                        h.setY(Math.max(Math.abs(a[1]), Math.abs(c[1]))),
                                        h.setZ(Math.max(Math.abs(a[2]), Math.abs(c[2]))),
                                        u.max(h)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                }
                            }
                            o.expandByVector(u)
                        }
                        t.boundingBox = o;
                        var m = new i["kb"];
                        o.getCenter(m.center),
                            m.radius = o.min.distanceTo(o.max) / 2,
                            t.boundingSphere = m
                    } else
                        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }
            function z(t, e, n) {
                var i = e.attributes
                    , r = [];
                function o(e, i) {
                    return n.getDependency("accessor", e).then((function(e) {
                            t.setAttribute(i, e)
                        }
                    ))
                }
                for (var s in i) {
                    var a = T[s] || s.toLowerCase();
                    a in t.attributes || r.push(o(i[s], a))
                }
                if (void 0 !== e.indices && !t.index) {
                    var c = n.getDependency("accessor", e.indices).then((function(e) {
                            t.setIndex(e)
                        }
                    ));
                    r.push(c)
                }
                return I(t, e),
                    B(t, e, n),
                    Promise.all(r).then((function() {
                            return void 0 !== e.targets ? N(t, e.targets, n) : t
                        }
                    ))
            }
            function U(t, e) {
                var n = t.getIndex();
                if (null === n) {
                    var r = []
                        , o = t.getAttribute("position");
                    if (void 0 === o)
                        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                            t;
                    for (var s = 0; s < o.count; s++)
                        r.push(s);
                    t.setIndex(r),
                        n = t.getIndex()
                }
                var a = n.count - 2
                    , c = [];
                if (e === i["qb"])
                    for (s = 1; s <= a; s++)
                        c.push(n.getX(0)),
                            c.push(n.getX(s)),
                            c.push(n.getX(s + 1));
                else
                    for (s = 0; s < a; s++)
                        s % 2 === 0 ? (c.push(n.getX(s)),
                            c.push(n.getX(s + 1)),
                            c.push(n.getX(s + 2))) : (c.push(n.getX(s + 2)),
                            c.push(n.getX(s + 1)),
                            c.push(n.getX(s)));
                c.length / 3 !== a && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                var l = t.clone();
                return l.setIndex(c),
                    l
            }
            return H.prototype.setExtensions = function(t) {
                this.extensions = t
            }
                ,
                H.prototype.setPlugins = function(t) {
                    this.plugins = t
                }
                ,
                H.prototype.parse = function(t, e) {
                    var n = this
                        , i = this.json
                        , r = this.extensions;
                    this.cache.removeAll(),
                        this._invokeAll((function(t) {
                                return t._markDefs && t._markDefs()
                            }
                        )),
                        Promise.all(this._invokeAll((function(t) {
                                return t.beforeRoot && t.beforeRoot()
                            }
                        ))).then((function() {
                                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                            }
                        )).then((function(e) {
                                var o = {
                                    scene: e[0][i.scene || 0],
                                    scenes: e[0],
                                    animations: e[1],
                                    cameras: e[2],
                                    asset: i.asset,
                                    parser: n,
                                    userData: {}
                                };
                                O(r, o, i),
                                    I(o, i),
                                    Promise.all(n._invokeAll((function(t) {
                                            return t.afterRoot && t.afterRoot(o)
                                        }
                                    ))).then((function() {
                                            t(o)
                                        }
                                    ))
                            }
                        )).catch(e)
                }
                ,
                H.prototype._markDefs = function() {
                    for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], i = 0, r = e.length; i < r; i++)
                        for (var o = e[i].joints, s = 0, a = o.length; s < a; s++)
                            t[o[s]].isBone = !0;
                    for (var c = 0, l = t.length; c < l; c++) {
                        var u = t[c];
                        void 0 !== u.mesh && (this._addNodeRef(this.meshCache, u.mesh),
                        void 0 !== u.skin && (n[u.mesh].isSkinnedMesh = !0)),
                        void 0 !== u.camera && this._addNodeRef(this.cameraCache, u.camera)
                    }
                }
                ,
                H.prototype._addNodeRef = function(t, e) {
                    void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                        t.refs[e]++)
                }
                ,
                H.prototype._getNodeRef = function(t, e, n) {
                    if (t.refs[e] <= 1)
                        return n;
                    var i = n.clone();
                    return i.name += "_instance_" + t.uses[e]++,
                        i
                }
                ,
                H.prototype._invokeOne = function(t) {
                    var e = Object.values(this.plugins);
                    e.push(this);
                    for (var n = 0; n < e.length; n++) {
                        var i = t(e[n]);
                        if (i)
                            return i
                    }
                }
                ,
                H.prototype._invokeAll = function(t) {
                    var e = Object.values(this.plugins);
                    e.unshift(this);
                    for (var n = [], i = 0; i < e.length; i++) {
                        var r = t(e[i]);
                        r && n.push(r)
                    }
                    return n
                }
                ,
                H.prototype.getDependency = function(t, e) {
                    var n = t + ":" + e
                        , i = this.cache.get(n);
                    if (!i) {
                        switch (t) {
                            case "scene":
                                i = this.loadScene(e);
                                break;
                            case "node":
                                i = this.loadNode(e);
                                break;
                            case "mesh":
                                i = this._invokeOne((function(t) {
                                        return t.loadMesh && t.loadMesh(e)
                                    }
                                ));
                                break;
                            case "accessor":
                                i = this.loadAccessor(e);
                                break;
                            case "bufferView":
                                i = this._invokeOne((function(t) {
                                        return t.loadBufferView && t.loadBufferView(e)
                                    }
                                ));
                                break;
                            case "buffer":
                                i = this.loadBuffer(e);
                                break;
                            case "material":
                                i = this._invokeOne((function(t) {
                                        return t.loadMaterial && t.loadMaterial(e)
                                    }
                                ));
                                break;
                            case "texture":
                                i = this._invokeOne((function(t) {
                                        return t.loadTexture && t.loadTexture(e)
                                    }
                                ));
                                break;
                            case "skin":
                                i = this.loadSkin(e);
                                break;
                            case "animation":
                                i = this.loadAnimation(e);
                                break;
                            case "camera":
                                i = this.loadCamera(e);
                                break;
                            default:
                                throw new Error("Unknown type: " + t)
                        }
                        this.cache.add(n, i)
                    }
                    return i
                }
                ,
                H.prototype.getDependencies = function(t) {
                    var e = this.cache.get(t);
                    if (!e) {
                        var n = this
                            , i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                        e = Promise.all(i.map((function(e, i) {
                                return n.getDependency(t, i)
                            }
                        ))),
                            this.cache.add(t, e)
                    }
                    return e
                }
                ,
                H.prototype.loadBuffer = function(t) {
                    var e = this.json.buffers[t]
                        , i = this.fileLoader;
                    if (e.type && "arraybuffer" !== e.type)
                        throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                    if (void 0 === e.uri && 0 === t)
                        return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                    var r = this.options;
                    return new Promise((function(t, n) {
                            i.load(C(e.uri, r.path), t, void 0, (function() {
                                    n(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                                }
                            ))
                        }
                    ))
                }
                ,
                H.prototype.loadBufferView = function(t) {
                    var e = this.json.bufferViews[t];
                    return this.getDependency("buffer", e.buffer).then((function(t) {
                            var n = e.byteLength || 0
                                , i = e.byteOffset || 0;
                            return t.slice(i, i + n)
                        }
                    ))
                }
                ,
                H.prototype.loadAccessor = function(t) {
                    var e = this
                        , n = this.json
                        , r = this.json.accessors[t];
                    if (void 0 === r.bufferView && void 0 === r.sparse)
                        return Promise.resolve(null);
                    var o = [];
                    return void 0 !== r.bufferView ? o.push(this.getDependency("bufferView", r.bufferView)) : o.push(null),
                    void 0 !== r.sparse && (o.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                        o.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
                        Promise.all(o).then((function(t) {
                                var o, s, a = t[0], c = E[r.type], l = w[r.componentType], u = l.BYTES_PER_ELEMENT, h = u * c, d = r.byteOffset || 0, p = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0, f = !0 === r.normalized;
                                if (p && p !== h) {
                                    var m = Math.floor(d / p)
                                        , g = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + m + ":" + r.count
                                        , v = e.cache.get(g);
                                    v || (o = new l(a,m * p,r.count * p / u),
                                        v = new i["s"](o,p / u),
                                        e.cache.add(g, v)),
                                        s = new i["t"](v,c,d % p / u,f)
                                } else
                                    o = null === a ? new l(r.count * c) : new l(a,d,r.count * c),
                                        s = new i["d"](o,c,f);
                                if (void 0 !== r.sparse) {
                                    var y = E.SCALAR
                                        , _ = w[r.sparse.indices.componentType]
                                        , x = r.sparse.indices.byteOffset || 0
                                        , b = r.sparse.values.byteOffset || 0
                                        , M = new _(t[1],x,r.sparse.count * y)
                                        , S = new l(t[2],b,r.sparse.count * c);
                                    null !== a && (s = new i["d"](s.array.slice(),s.itemSize,s.normalized));
                                    for (var T = 0, A = M.length; T < A; T++) {
                                        var L = M[T];
                                        if (s.setX(L, S[T * c]),
                                        c >= 2 && s.setY(L, S[T * c + 1]),
                                        c >= 3 && s.setZ(L, S[T * c + 2]),
                                        c >= 4 && s.setW(L, S[T * c + 3]),
                                        c >= 5)
                                            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                    }
                                }
                                return s
                            }
                        ))
                }
                ,
                H.prototype.loadTexture = function(t) {
                    var e = this.json
                        , n = this.options
                        , i = e.textures[t]
                        , r = e.images[i.source]
                        , o = this.textureLoader;
                    if (r.uri) {
                        var s = n.manager.getHandler(r.uri);
                        null !== s && (o = s)
                    }
                    return this.loadTextureImage(t, r, o)
                }
                ,
                H.prototype.loadTextureImage = function(t, e, n) {
                    var r = this
                        , o = this.json
                        , s = this.options
                        , a = o.textures[t]
                        , c = self.URL || self.webkitURL
                        , l = e.uri
                        , u = !1
                        , h = !0;
                    if ("image/jpeg" === e.mimeType && (h = !1),
                    void 0 !== e.bufferView)
                        l = r.getDependency("bufferView", e.bufferView).then((function(t) {
                                if ("image/png" === e.mimeType) {
                                    var n = new DataView(t,25,1).getUint8(0, !1);
                                    h = 6 === n || 4 === n || 3 === n
                                }
                                u = !0;
                                var i = new Blob([t],{
                                    type: e.mimeType
                                });
                                return l = c.createObjectURL(i),
                                    l
                            }
                        ));
                    else if (void 0 === e.uri)
                        throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                    return Promise.resolve(l).then((function(t) {
                            return new Promise((function(e, r) {
                                    var o = e;
                                    !0 === n.isImageBitmapLoader && (o = function(t) {
                                            e(new i["f"](t))
                                        }
                                    ),
                                        n.load(C(t, s.path), o, void 0, r)
                                }
                            ))
                        }
                    )).then((function(e) {
                            !0 === u && c.revokeObjectURL(l),
                                e.flipY = !1,
                            a.name && (e.name = a.name),
                            h || (e.format = i["eb"]);
                            var n = o.samplers || {}
                                , s = n[a.sampler] || {};
                            return e.magFilter = M[s.magFilter] || i["B"],
                                e.minFilter = M[s.minFilter] || i["C"],
                                e.wrapS = S[s.wrapS] || i["fb"],
                                e.wrapT = S[s.wrapT] || i["fb"],
                                r.associations.set(e, {
                                    type: "textures",
                                    index: t
                                }),
                                e
                        }
                    ))
                }
                ,
                H.prototype.assignTexture = function(t, e, i) {
                    var r = this;
                    return this.getDependency("texture", i.index).then((function(o) {
                            if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === e && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + e + " not yet supported."),
                                r.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                                var s = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (s) {
                                    var a = r.associations.get(o);
                                    o = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(o, s),
                                        r.associations.set(o, a)
                                }
                            }
                            t[e] = o
                        }
                    ))
                }
                ,
                H.prototype.assignFinalMaterial = function(t) {
                    var e = t.geometry
                        , n = t.material
                        , r = void 0 !== e.attributes.tangent
                        , o = void 0 !== e.attributes.color
                        , s = void 0 === e.attributes.normal
                        , a = !0 === t.isSkinnedMesh
                        , c = Object.keys(e.morphAttributes).length > 0
                        , l = c && void 0 !== e.morphAttributes.normal;
                    if (t.isPoints) {
                        var u = "PointsMaterial:" + n.uuid
                            , h = this.cache.get(u);
                        h || (h = new i["ab"],
                            i["I"].prototype.copy.call(h, n),
                            h.color.copy(n.color),
                            h.map = n.map,
                            h.sizeAttenuation = !1,
                            this.cache.add(u, h)),
                            n = h
                    } else if (t.isLine) {
                        u = "LineBasicMaterial:" + n.uuid;
                        var d = this.cache.get(u);
                        d || (d = new i["y"],
                            i["I"].prototype.copy.call(d, n),
                            d.color.copy(n.color),
                            this.cache.add(u, d)),
                            n = d
                    }
                    if (r || o || s || a || c) {
                        u = "ClonedMaterial:" + n.uuid + ":";
                        n.isGLTFSpecularGlossinessMaterial && (u += "specular-glossiness:"),
                        a && (u += "skinning:"),
                        r && (u += "vertex-tangents:"),
                        o && (u += "vertex-colors:"),
                        s && (u += "flat-shading:"),
                        c && (u += "morph-targets:"),
                        l && (u += "morph-normals:");
                        var p = this.cache.get(u);
                        p || (p = n.clone(),
                        a && (p.skinning = !0),
                        o && (p.vertexColors = !0),
                        s && (p.flatShading = !0),
                        c && (p.morphTargets = !0),
                        l && (p.morphNormals = !0),
                        r && (p.vertexTangents = !0,
                        p.normalScale && (p.normalScale.y *= -1),
                        p.clearcoatNormalScale && (p.clearcoatNormalScale.y *= -1)),
                            this.cache.add(u, p),
                            this.associations.set(p, this.associations.get(n))),
                            n = p
                    }
                    n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv),
                        t.material = n
                }
                ,
                H.prototype.getMaterialType = function() {
                    return i["P"]
                }
                ,
                H.prototype.loadMaterial = function(t) {
                    var e, r = this, o = this.json, s = this.extensions, a = o.materials[t], c = {}, l = a.extensions || {}, u = [];
                    if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        var h = s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        e = h.getMaterialType(),
                            u.push(h.extendParams(c, a, r))
                    } else if (l[n.KHR_MATERIALS_UNLIT]) {
                        var d = s[n.KHR_MATERIALS_UNLIT];
                        e = d.getMaterialType(),
                            u.push(d.extendParams(c, a, r))
                    } else {
                        var p = a.pbrMetallicRoughness || {};
                        if (c.color = new i["h"](1,1,1),
                            c.opacity = 1,
                            Array.isArray(p.baseColorFactor)) {
                            var f = p.baseColorFactor;
                            c.color.fromArray(f),
                                c.opacity = f[3]
                        }
                        void 0 !== p.baseColorTexture && u.push(r.assignTexture(c, "map", p.baseColorTexture)),
                            c.metalness = void 0 !== p.metallicFactor ? p.metallicFactor : 1,
                            c.roughness = void 0 !== p.roughnessFactor ? p.roughnessFactor : 1,
                        void 0 !== p.metallicRoughnessTexture && (u.push(r.assignTexture(c, "metalnessMap", p.metallicRoughnessTexture)),
                            u.push(r.assignTexture(c, "roughnessMap", p.metallicRoughnessTexture))),
                            e = this._invokeOne((function(e) {
                                    return e.getMaterialType && e.getMaterialType(t)
                                }
                            )),
                            u.push(Promise.all(this._invokeAll((function(e) {
                                    return e.extendMaterialParams && e.extendMaterialParams(t, c)
                                }
                            ))))
                    }
                    !0 === a.doubleSided && (c.side = i["j"]);
                    var m = a.alphaMode || R.OPAQUE;
                    return m === R.BLEND ? (c.transparent = !0,
                        c.depthWrite = !1) : (c.transparent = !1,
                    m === R.MASK && (c.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)),
                    void 0 !== a.normalTexture && e !== i["M"] && (u.push(r.assignTexture(c, "normalMap", a.normalTexture)),
                        c.normalScale = new i["sb"](1,-1),
                    void 0 !== a.normalTexture.scale && c.normalScale.set(a.normalTexture.scale, -a.normalTexture.scale)),
                    void 0 !== a.occlusionTexture && e !== i["M"] && (u.push(r.assignTexture(c, "aoMap", a.occlusionTexture)),
                    void 0 !== a.occlusionTexture.strength && (c.aoMapIntensity = a.occlusionTexture.strength)),
                    void 0 !== a.emissiveFactor && e !== i["M"] && (c.emissive = (new i["h"]).fromArray(a.emissiveFactor)),
                    void 0 !== a.emissiveTexture && e !== i["M"] && u.push(r.assignTexture(c, "emissiveMap", a.emissiveTexture)),
                        Promise.all(u).then((function() {
                                var o;
                                return o = e === v ? s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(c) : new e(c),
                                a.name && (o.name = a.name),
                                o.map && (o.map.encoding = i["wb"]),
                                o.emissiveMap && (o.emissiveMap.encoding = i["wb"]),
                                    I(o, a),
                                    r.associations.set(o, {
                                        type: "materials",
                                        index: t
                                    }),
                                a.extensions && O(s, o, a),
                                    o
                            }
                        ))
                }
                ,
                H.prototype.createUniqueName = function(t) {
                    for (var e = i["bb"].sanitizeNodeName(t || ""), n = e, r = 1; this.nodeNamesUsed[n]; ++r)
                        n = e + "_" + r;
                    return this.nodeNamesUsed[n] = !0,
                        n
                }
                ,
                H.prototype.loadGeometries = function(t) {
                    var e = this
                        , r = this.extensions
                        , o = this.primitiveCache;
                    function s(t) {
                        return r[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                                return z(n, t, e)
                            }
                        ))
                    }
                    for (var a = [], c = 0, l = t.length; c < l; c++) {
                        var u, h = t[c], d = F(h), p = o[d];
                        if (p)
                            a.push(p.promise);
                        else
                            u = h.extensions && h.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? s(h) : z(new i["e"], h, e),
                                o[d] = {
                                    primitive: h,
                                    promise: u
                                },
                                a.push(u)
                    }
                    return Promise.all(a)
                }
                ,
                H.prototype.loadMesh = function(t) {
                    for (var e = this, n = this.json, r = this.extensions, o = n.meshes[t], s = o.primitives, a = [], c = 0, l = s.length; c < l; c++) {
                        var u = void 0 === s[c].material ? P(this.cache) : this.getDependency("material", s[c].material);
                        a.push(u)
                    }
                    return a.push(e.loadGeometries(s)),
                        Promise.all(a).then((function(n) {
                                for (var a = n.slice(0, n.length - 1), c = n[n.length - 1], l = [], u = 0, h = c.length; u < h; u++) {
                                    var d, p = c[u], f = s[u], m = a[u];
                                    if (f.mode === b.TRIANGLES || f.mode === b.TRIANGLE_STRIP || f.mode === b.TRIANGLE_FAN || void 0 === f.mode)
                                        d = !0 === o.isSkinnedMesh ? new i["jb"](p,m) : new i["L"](p,m),
                                        !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(),
                                            f.mode === b.TRIANGLE_STRIP ? d.geometry = U(d.geometry, i["rb"]) : f.mode === b.TRIANGLE_FAN && (d.geometry = U(d.geometry, i["qb"]));
                                    else if (f.mode === b.LINES)
                                        d = new i["A"](p,m);
                                    else if (f.mode === b.LINE_STRIP)
                                        d = new i["x"](p,m);
                                    else if (f.mode === b.LINE_LOOP)
                                        d = new i["z"](p,m);
                                    else {
                                        if (f.mode !== b.POINTS)
                                            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + f.mode);
                                        d = new i["Z"](p,m)
                                    }
                                    Object.keys(d.geometry.morphAttributes).length > 0 && D(d, o),
                                        d.name = e.createUniqueName(o.name || "mesh_" + t),
                                        I(d, o),
                                    f.extensions && O(r, d, f),
                                        e.assignFinalMaterial(d),
                                        l.push(d)
                                }
                                if (1 === l.length)
                                    return l[0];
                                var g = new i["p"];
                                for (u = 0,
                                         h = l.length; u < h; u++)
                                    g.add(l[u]);
                                return g
                            }
                        ))
                }
                ,
                H.prototype.loadCamera = function(t) {
                    var e, n = this.json.cameras[t], r = n[n.type];
                    if (r)
                        return "perspective" === n.type ? e = new i["X"](i["J"].radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : "orthographic" === n.type && (e = new i["W"](-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
                        n.name && (e.name = this.createUniqueName(n.name)),
                            I(e, n),
                            Promise.resolve(e);
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }
                ,
                H.prototype.loadSkin = function(t) {
                    var e = this.json.skins[t]
                        , n = {
                        joints: e.joints
                    };
                    return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                            return n.inverseBindMatrices = t,
                                n
                        }
                    ))
                }
                ,
                H.prototype.loadAnimation = function(t) {
                    for (var e = this.json, n = e.animations[t], r = [], o = [], s = [], a = [], c = [], l = 0, u = n.channels.length; l < u; l++) {
                        var h = n.channels[l]
                            , d = n.samplers[h.sampler]
                            , p = h.target
                            , f = void 0 !== p.node ? p.node : p.id
                            , m = void 0 !== n.parameters ? n.parameters[d.input] : d.input
                            , g = void 0 !== n.parameters ? n.parameters[d.output] : d.output;
                        r.push(this.getDependency("node", f)),
                            o.push(this.getDependency("accessor", m)),
                            s.push(this.getDependency("accessor", g)),
                            a.push(d),
                            c.push(p)
                    }
                    return Promise.all([Promise.all(r), Promise.all(o), Promise.all(s), Promise.all(a), Promise.all(c)]).then((function(e) {
                            for (var r = e[0], o = e[1], s = e[2], a = e[3], c = e[4], l = [], u = 0, h = r.length; u < h; u++) {
                                var d = r[u]
                                    , p = o[u]
                                    , f = s[u]
                                    , m = a[u]
                                    , g = c[u];
                                if (void 0 !== d) {
                                    var v;
                                    switch (d.updateMatrix(),
                                        d.matrixAutoUpdate = !0,
                                        A[g.path]) {
                                        case A.weights:
                                            v = i["U"];
                                            break;
                                        case A.rotation:
                                            v = i["db"];
                                            break;
                                        case A.position:
                                        case A.scale:
                                        default:
                                            v = i["ub"];
                                            break
                                    }
                                    var y = d.name ? d.name : d.uuid
                                        , _ = void 0 !== m.interpolation ? L[m.interpolation] : i["w"]
                                        , b = [];
                                    A[g.path] === A.weights ? d.traverse((function(t) {
                                            !0 === t.isMesh && t.morphTargetInfluences && b.push(t.name ? t.name : t.uuid)
                                        }
                                    )) : b.push(y);
                                    var w = f.array;
                                    if (f.normalized) {
                                        var M;
                                        if (w.constructor === Int8Array)
                                            M = 1 / 127;
                                        else if (w.constructor === Uint8Array)
                                            M = 1 / 255;
                                        else if (w.constructor == Int16Array)
                                            M = 1 / 32767;
                                        else {
                                            if (w.constructor !== Uint16Array)
                                                throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                            M = 1 / 65535
                                        }
                                        for (var S = new Float32Array(w.length), E = 0, T = w.length; E < T; E++)
                                            S[E] = w[E] * M;
                                        w = S
                                    }
                                    for (E = 0,
                                             T = b.length; E < T; E++) {
                                        var R = new v(b[E] + "." + A[g.path],p.array,w,_);
                                        "CUBICSPLINE" === m.interpolation && (R.createInterpolant = function(t) {
                                            return new x(this.times,this.values,this.getValueSize() / 3,t)
                                        }
                                            ,
                                            R.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                                            l.push(R)
                                    }
                                }
                            }
                            var C = n.name ? n.name : "animation_" + t;
                            return new i["a"](C,void 0,l)
                        }
                    ))
                }
                ,
                H.prototype.loadNode = function(t) {
                    var e = this.json
                        , n = this.extensions
                        , r = this
                        , o = e.nodes[t]
                        , s = o.name ? r.createUniqueName(o.name) : "";
                    return function() {
                        var e = [];
                        return void 0 !== o.mesh && e.push(r.getDependency("mesh", o.mesh).then((function(t) {
                                var e = r._getNodeRef(r.meshCache, o.mesh, t);
                                return void 0 !== o.weights && e.traverse((function(t) {
                                        if (t.isMesh)
                                            for (var e = 0, n = o.weights.length; e < n; e++)
                                                t.morphTargetInfluences[e] = o.weights[e]
                                    }
                                )),
                                    e
                            }
                        ))),
                        void 0 !== o.camera && e.push(r.getDependency("camera", o.camera).then((function(t) {
                                return r._getNodeRef(r.cameraCache, o.camera, t)
                            }
                        ))),
                            r._invokeAll((function(e) {
                                    return e.createNodeAttachment && e.createNodeAttachment(t)
                                }
                            )).forEach((function(t) {
                                    e.push(t)
                                }
                            )),
                            Promise.all(e)
                    }().then((function(e) {
                            var a;
                            if (a = !0 === o.isBone ? new i["b"] : e.length > 1 ? new i["p"] : 1 === e.length ? e[0] : new i["V"],
                            a !== e[0])
                                for (var c = 0, l = e.length; c < l; c++)
                                    a.add(e[c]);
                            if (o.name && (a.userData.name = o.name,
                                a.name = s),
                                I(a, o),
                            o.extensions && O(n, a, o),
                            void 0 !== o.matrix) {
                                var u = new i["K"];
                                u.fromArray(o.matrix),
                                    a.applyMatrix4(u)
                            } else
                                void 0 !== o.translation && a.position.fromArray(o.translation),
                                void 0 !== o.rotation && a.quaternion.fromArray(o.rotation),
                                void 0 !== o.scale && a.scale.fromArray(o.scale);
                            return r.associations.set(a, {
                                type: "nodes",
                                index: t
                            }),
                                a
                        }
                    ))
                }
                ,
                H.prototype.loadScene = function() {
                    function t(e, n, r, o) {
                        var s = r.nodes[e];
                        return o.getDependency("node", e).then((function(t) {
                                return void 0 === s.skin ? t : o.getDependency("skin", s.skin).then((function(t) {
                                        e = t;
                                        for (var n = [], i = 0, r = e.joints.length; i < r; i++)
                                            n.push(o.getDependency("node", e.joints[i]));
                                        return Promise.all(n)
                                    }
                                )).then((function(n) {
                                        return t.traverse((function(t) {
                                                if (t.isMesh) {
                                                    for (var r = [], o = [], s = 0, a = n.length; s < a; s++) {
                                                        var c = n[s];
                                                        if (c) {
                                                            r.push(c);
                                                            var l = new i["K"];
                                                            void 0 !== e.inverseBindMatrices && l.fromArray(e.inverseBindMatrices.array, 16 * s),
                                                                o.push(l)
                                                        } else
                                                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[s])
                                                    }
                                                    t.bind(new i["ib"](r,o), t.matrixWorld)
                                                }
                                            }
                                        )),
                                            t
                                    }
                                ));
                                var e
                            }
                        )).then((function(e) {
                                n.add(e);
                                var i = [];
                                if (s.children)
                                    for (var a = s.children, c = 0, l = a.length; c < l; c++) {
                                        var u = a[c];
                                        i.push(t(u, e, r, o))
                                    }
                                return Promise.all(i)
                            }
                        ))
                    }
                    return function(e) {
                        var n = this.json
                            , r = this.extensions
                            , o = this.json.scenes[e]
                            , s = this
                            , a = new i["p"];
                        o.name && (a.name = s.createUniqueName(o.name)),
                            I(a, o),
                        o.extensions && O(r, a, o);
                        for (var c = o.nodes || [], l = [], u = 0, h = c.length; u < h; u++)
                            l.push(t(c[u], a, n, s));
                        return Promise.all(l).then((function() {
                                return a
                            }
                        ))
                    }
                }(),
                t
        }()
    },
    "35a1": function(t, e, n) {
        var i = n("f5df")
            , r = n("3f8c")
            , o = n("b622")
            , s = o("iterator");
        t.exports = function(t) {
            if (void 0 != t)
                return t[s] || t["@@iterator"] || r[i(t)]
        }
    },
    "37e8": function(t, e, n) {
        var i = n("83ab")
            , r = n("9bf2")
            , o = n("825a")
            , s = n("df75");
        t.exports = i ? Object.defineProperties : function(t, e) {
            o(t);
            var n, i = s(e), a = i.length, c = 0;
            while (a > c)
                r.f(t, n = i[c++], e[n]);
            return t
        }
    },
    "3a7b": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").findIndex
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("findIndex", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    "3bbe": function(t, e, n) {
        var i = n("861d");
        t.exports = function(t) {
            if (!i(t) && null !== t)
                throw TypeError("Can't set " + String(t) + " as a prototype");
            return t
        }
    },
    "3c5d": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("50c4")
            , o = n("182d")
            , s = n("7b0b")
            , a = n("d039")
            , c = i.aTypedArray
            , l = i.exportTypedArrayMethod
            , u = a((function() {
                new Int8Array(1).set({})
            }
        ));
        l("set", (function(t) {
                c(this);
                var e = o(arguments.length > 1 ? arguments[1] : void 0, 1)
                    , n = this.length
                    , i = s(t)
                    , a = r(i.length)
                    , l = 0;
                if (a + e > n)
                    throw RangeError("Wrong length");
                while (l < a)
                    this[e + l] = i[l++]
            }
        ), u)
    },
    "3f8c": function(t, e) {
        t.exports = {}
    },
    "3fcc": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").map
            , o = n("4840")
            , s = i.aTypedArray
            , a = i.aTypedArrayConstructor
            , c = i.exportTypedArrayMethod;
        c("map", (function(t) {
                return r(s(this), t, arguments.length > 1 ? arguments[1] : void 0, (function(t, e) {
                        return new (a(o(t, t.constructor)))(e)
                    }
                ))
            }
        ))
    },
    "428f": function(t, e, n) {
        var i = n("da84");
        t.exports = i
    },
    "44ad": function(t, e, n) {
        var i = n("d039")
            , r = n("c6b6")
            , o = "".split;
        t.exports = i((function() {
                return !Object("z").propertyIsEnumerable(0)
            }
        )) ? function(t) {
                return "String" == r(t) ? o.call(t, "") : Object(t)
            }
            : Object
    },
    "44d2": function(t, e, n) {
        var i = n("b622")
            , r = n("7c73")
            , o = n("9bf2")
            , s = i("unscopables")
            , a = Array.prototype;
        void 0 == a[s] && o.f(a, s, {
            configurable: !0,
            value: r(null)
        }),
            t.exports = function(t) {
                a[s][t] = !0
            }
    },
    "44de": function(t, e, n) {
        var i = n("da84");
        t.exports = function(t, e) {
            var n = i.console;
            n && n.error && (1 === arguments.length ? n.error(t) : n.error(t, e))
        }
    },
    4721: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
                return r
            }
        ));
        var i = n("5a89")
            , r = function(t, e) {
            void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
            e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
                this.object = t,
                this.domElement = e,
                this.enabled = !0,
                this.target = new i["tb"],
                this.minDistance = 0,
                this.maxDistance = 1 / 0,
                this.minZoom = 0,
                this.maxZoom = 1 / 0,
                this.minPolarAngle = 0,
                this.maxPolarAngle = Math.PI,
                this.minAzimuthAngle = -1 / 0,
                this.maxAzimuthAngle = 1 / 0,
                this.enableDamping = !1,
                this.dampingFactor = .05,
                this.enableZoom = !0,
                this.zoomSpeed = 1,
                this.enableRotate = !0,
                this.rotateSpeed = 1,
                this.enablePan = !0,
                this.panSpeed = 1,
                this.screenSpacePanning = !0,
                this.keyPanSpeed = 7,
                this.autoRotate = !1,
                this.autoRotateSpeed = 2,
                this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                },
                this.mouseButtons = {
                    LEFT: i["H"].ROTATE,
                    MIDDLE: i["H"].DOLLY,
                    RIGHT: i["H"].PAN
                },
                this.touches = {
                    ONE: i["nb"].ROTATE,
                    TWO: i["nb"].DOLLY_PAN
                },
                this.target0 = this.target.clone(),
                this.position0 = this.object.position.clone(),
                this.zoom0 = this.object.zoom,
                this._domElementKeyEvents = null,
                this.getPolarAngle = function() {
                    return u.phi
                }
                ,
                this.getAzimuthalAngle = function() {
                    return u.theta
                }
                ,
                this.listenToKeyEvents = function(t) {
                    t.addEventListener("keydown", st),
                        this._domElementKeyEvents = t
                }
                ,
                this.saveState = function() {
                    n.target0.copy(n.target),
                        n.position0.copy(n.object.position),
                        n.zoom0 = n.object.zoom
                }
                ,
                this.reset = function() {
                    n.target.copy(n.target0),
                        n.object.position.copy(n.position0),
                        n.object.zoom = n.zoom0,
                        n.object.updateProjectionMatrix(),
                        n.dispatchEvent(r),
                        n.update(),
                        c = a.NONE
                }
                ,
                this.update = function() {
                    var e = new i["tb"]
                        , o = (new i["cb"]).setFromUnitVectors(t.up, new i["tb"](0,1,0))
                        , s = o.clone().invert()
                        , m = new i["tb"]
                        , g = new i["cb"]
                        , v = 2 * Math.PI;
                    return function() {
                        var t = n.object.position;
                        e.copy(t).sub(n.target),
                            e.applyQuaternion(o),
                            u.setFromVector3(e),
                        n.autoRotate && c === a.NONE && T(S()),
                            n.enableDamping ? (u.theta += h.theta * n.dampingFactor,
                                u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta,
                                u.phi += h.phi);
                        var i = n.minAzimuthAngle
                            , y = n.maxAzimuthAngle;
                        return isFinite(i) && isFinite(y) && (i < -Math.PI ? i += v : i > Math.PI && (i -= v),
                            y < -Math.PI ? y += v : y > Math.PI && (y -= v),
                            u.theta = i <= y ? Math.max(i, Math.min(y, u.theta)) : u.theta > (i + y) / 2 ? Math.max(i, u.theta) : Math.min(y, u.theta)),
                            u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)),
                            u.makeSafe(),
                            u.radius *= d,
                            u.radius = Math.max(n.minDistance, Math.min(n.maxDistance, u.radius)),
                            !0 === n.enableDamping ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p),
                            e.setFromSpherical(u),
                            e.applyQuaternion(s),
                            t.copy(n.target).add(e),
                            n.object.lookAt(n.target),
                            !0 === n.enableDamping ? (h.theta *= 1 - n.dampingFactor,
                                h.phi *= 1 - n.dampingFactor,
                                p.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0),
                                p.set(0, 0, 0)),
                            d = 1,
                        !!(f || m.distanceToSquared(n.object.position) > l || 8 * (1 - g.dot(n.object.quaternion)) > l) && (n.dispatchEvent(r),
                            m.copy(n.object.position),
                            g.copy(n.object.quaternion),
                            f = !1,
                            !0)
                    }
                }(),
                this.dispose = function() {
                    n.domElement.removeEventListener("contextmenu", ut),
                        n.domElement.removeEventListener("pointerdown", $),
                        n.domElement.removeEventListener("wheel", ot),
                        n.domElement.removeEventListener("touchstart", at),
                        n.domElement.removeEventListener("touchend", lt),
                        n.domElement.removeEventListener("touchmove", ct),
                        n.domElement.ownerDocument.removeEventListener("pointermove", tt),
                        n.domElement.ownerDocument.removeEventListener("pointerup", et),
                    null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", st)
                }
            ;
            var n = this
                , r = {
                type: "change"
            }
                , o = {
                type: "start"
            }
                , s = {
                type: "end"
            }
                , a = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            }
                , c = a.NONE
                , l = 1e-6
                , u = new i["lb"]
                , h = new i["lb"]
                , d = 1
                , p = new i["tb"]
                , f = !1
                , m = new i["sb"]
                , g = new i["sb"]
                , v = new i["sb"]
                , y = new i["sb"]
                , _ = new i["sb"]
                , x = new i["sb"]
                , b = new i["sb"]
                , w = new i["sb"]
                , M = new i["sb"];
            function S() {
                return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
            }
            function E() {
                return Math.pow(.95, n.zoomSpeed)
            }
            function T(t) {
                h.theta -= t
            }
            function A(t) {
                h.phi -= t
            }
            var L = function() {
                var t = new i["tb"];
                return function(e, n) {
                    t.setFromMatrixColumn(n, 0),
                        t.multiplyScalar(-e),
                        p.add(t)
                }
            }()
                , R = function() {
                var t = new i["tb"];
                return function(e, i) {
                    !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0),
                        t.crossVectors(n.object.up, t)),
                        t.multiplyScalar(e),
                        p.add(t)
                }
            }()
                , C = function() {
                var t = new i["tb"];
                return function(e, i) {
                    var r = n.domElement;
                    if (n.object.isPerspectiveCamera) {
                        var o = n.object.position;
                        t.copy(o).sub(n.target);
                        var s = t.length();
                        s *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                            L(2 * e * s / r.clientHeight, n.object.matrix),
                            R(2 * i * s / r.clientHeight, n.object.matrix)
                    } else
                        n.object.isOrthographicCamera ? (L(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                            R(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                            n.enablePan = !1)
                }
            }();
            function P(t) {
                n.object.isPerspectiveCamera ? d /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)),
                    n.object.updateProjectionMatrix(),
                    f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
            }
            function O(t) {
                n.object.isPerspectiveCamera ? d *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)),
                    n.object.updateProjectionMatrix(),
                    f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
            }
            function I(t) {
                m.set(t.clientX, t.clientY)
            }
            function N(t) {
                b.set(t.clientX, t.clientY)
            }
            function D(t) {
                y.set(t.clientX, t.clientY)
            }
            function F(t) {
                g.set(t.clientX, t.clientY),
                    v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                var e = n.domElement;
                T(2 * Math.PI * v.x / e.clientHeight),
                    A(2 * Math.PI * v.y / e.clientHeight),
                    m.copy(g),
                    n.update()
            }
            function k(t) {
                w.set(t.clientX, t.clientY),
                    M.subVectors(w, b),
                    M.y > 0 ? P(E()) : M.y < 0 && O(E()),
                    b.copy(w),
                    n.update()
            }
            function H(t) {
                _.set(t.clientX, t.clientY),
                    x.subVectors(_, y).multiplyScalar(n.panSpeed),
                    C(x.x, x.y),
                    y.copy(_),
                    n.update()
            }
            function B() {}
            function z(t) {
                t.deltaY < 0 ? O(E()) : t.deltaY > 0 && P(E()),
                    n.update()
            }
            function U(t) {
                var e = !1;
                switch (t.code) {
                    case n.keys.UP:
                        C(0, n.keyPanSpeed),
                            e = !0;
                        break;
                    case n.keys.BOTTOM:
                        C(0, -n.keyPanSpeed),
                            e = !0;
                        break;
                    case n.keys.LEFT:
                        C(n.keyPanSpeed, 0),
                            e = !0;
                        break;
                    case n.keys.RIGHT:
                        C(-n.keyPanSpeed, 0),
                            e = !0;
                        break
                }
                e && (t.preventDefault(),
                    n.update())
            }
            function j(t) {
                if (1 == t.touches.length)
                    m.set(t.touches[0].pageX, t.touches[0].pageY);
                else {
                    var e = .5 * (t.touches[0].pageX + t.touches[1].pageX)
                        , n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                    m.set(e, n)
                }
            }
            function G(t) {
                if (1 == t.touches.length)
                    y.set(t.touches[0].pageX, t.touches[0].pageY);
                else {
                    var e = .5 * (t.touches[0].pageX + t.touches[1].pageX)
                        , n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                    y.set(e, n)
                }
            }
            function V(t) {
                var e = t.touches[0].pageX - t.touches[1].pageX
                    , n = t.touches[0].pageY - t.touches[1].pageY
                    , i = Math.sqrt(e * e + n * n);
                b.set(0, i)
            }
            function W(t) {
                n.enableZoom && V(t),
                n.enablePan && G(t)
            }
            function q(t) {
                n.enableZoom && V(t),
                n.enableRotate && j(t)
            }
            function X(t) {
                if (1 == t.touches.length)
                    g.set(t.touches[0].pageX, t.touches[0].pageY);
                else {
                    var e = .5 * (t.touches[0].pageX + t.touches[1].pageX)
                        , i = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                    g.set(e, i)
                }
                v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                var r = n.domElement;
                T(2 * Math.PI * v.x / r.clientHeight),
                    A(2 * Math.PI * v.y / r.clientHeight),
                    m.copy(g)
            }
            function Y(t) {
                if (1 == t.touches.length)
                    _.set(t.touches[0].pageX, t.touches[0].pageY);
                else {
                    var e = .5 * (t.touches[0].pageX + t.touches[1].pageX)
                        , i = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                    _.set(e, i)
                }
                x.subVectors(_, y).multiplyScalar(n.panSpeed),
                    C(x.x, x.y),
                    y.copy(_)
            }
            function Z(t) {
                var e = t.touches[0].pageX - t.touches[1].pageX
                    , i = t.touches[0].pageY - t.touches[1].pageY
                    , r = Math.sqrt(e * e + i * i);
                w.set(0, r),
                    M.set(0, Math.pow(w.y / b.y, n.zoomSpeed)),
                    P(M.y),
                    b.copy(w)
            }
            function J(t) {
                n.enableZoom && Z(t),
                n.enablePan && Y(t)
            }
            function K(t) {
                n.enableZoom && Z(t),
                n.enableRotate && X(t)
            }
            function Q() {}
            function $(t) {
                if (!1 !== n.enabled)
                    switch (t.pointerType) {
                        case "mouse":
                        case "pen":
                            nt(t);
                            break
                    }
            }
            function tt(t) {
                if (!1 !== n.enabled)
                    switch (t.pointerType) {
                        case "mouse":
                        case "pen":
                            it(t);
                            break
                    }
            }
            function et(t) {
                switch (t.pointerType) {
                    case "mouse":
                    case "pen":
                        rt(t);
                        break
                }
            }
            function nt(t) {
                var e;
                switch (t.preventDefault(),
                    n.domElement.focus ? n.domElement.focus() : window.focus(),
                    t.button) {
                    case 0:
                        e = n.mouseButtons.LEFT;
                        break;
                    case 1:
                        e = n.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        e = n.mouseButtons.RIGHT;
                        break;
                    default:
                        e = -1
                }
                switch (e) {
                    case i["H"].DOLLY:
                        if (!1 === n.enableZoom)
                            return;
                        N(t),
                            c = a.DOLLY;
                        break;
                    case i["H"].ROTATE:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan)
                                return;
                            D(t),
                                c = a.PAN
                        } else {
                            if (!1 === n.enableRotate)
                                return;
                            I(t),
                                c = a.ROTATE
                        }
                        break;
                    case i["H"].PAN:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate)
                                return;
                            I(t),
                                c = a.ROTATE
                        } else {
                            if (!1 === n.enablePan)
                                return;
                            D(t),
                                c = a.PAN
                        }
                        break;
                    default:
                        c = a.NONE
                }
                c !== a.NONE && (n.domElement.ownerDocument.addEventListener("pointermove", tt),
                    n.domElement.ownerDocument.addEventListener("pointerup", et),
                    n.dispatchEvent(o))
            }
            function it(t) {
                if (!1 !== n.enabled)
                    switch (t.preventDefault(),
                        c) {
                        case a.ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            F(t);
                            break;
                        case a.DOLLY:
                            if (!1 === n.enableZoom)
                                return;
                            k(t);
                            break;
                        case a.PAN:
                            if (!1 === n.enablePan)
                                return;
                            H(t);
                            break
                    }
            }
            function rt(t) {
                n.domElement.ownerDocument.removeEventListener("pointermove", tt),
                    n.domElement.ownerDocument.removeEventListener("pointerup", et),
                !1 !== n.enabled && (B(t),
                    n.dispatchEvent(s),
                    c = a.NONE)
            }
            function ot(t) {
                !1 === n.enabled || !1 === n.enableZoom || c !== a.NONE && c !== a.ROTATE || (t.preventDefault(),
                    n.dispatchEvent(o),
                    z(t),
                    n.dispatchEvent(s))
            }
            function st(t) {
                !1 !== n.enabled && !1 !== n.enablePan && U(t)
            }
            function at(t) {
                if (!1 !== n.enabled) {
                    switch (t.preventDefault(),
                        t.touches.length) {
                        case 1:
                            switch (n.touches.ONE) {
                                case i["nb"].ROTATE:
                                    if (!1 === n.enableRotate)
                                        return;
                                    j(t),
                                        c = a.TOUCH_ROTATE;
                                    break;
                                case i["nb"].PAN:
                                    if (!1 === n.enablePan)
                                        return;
                                    G(t),
                                        c = a.TOUCH_PAN;
                                    break;
                                default:
                                    c = a.NONE
                            }
                            break;
                        case 2:
                            switch (n.touches.TWO) {
                                case i["nb"].DOLLY_PAN:
                                    if (!1 === n.enableZoom && !1 === n.enablePan)
                                        return;
                                    W(t),
                                        c = a.TOUCH_DOLLY_PAN;
                                    break;
                                case i["nb"].DOLLY_ROTATE:
                                    if (!1 === n.enableZoom && !1 === n.enableRotate)
                                        return;
                                    q(t),
                                        c = a.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    c = a.NONE
                            }
                            break;
                        default:
                            c = a.NONE
                    }
                    c !== a.NONE && n.dispatchEvent(o)
                }
            }
            function ct(t) {
                if (!1 !== n.enabled)
                    switch (t.preventDefault(),
                        c) {
                        case a.TOUCH_ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            X(t),
                                n.update();
                            break;
                        case a.TOUCH_PAN:
                            if (!1 === n.enablePan)
                                return;
                            Y(t),
                                n.update();
                            break;
                        case a.TOUCH_DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                            J(t),
                                n.update();
                            break;
                        case a.TOUCH_DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                            K(t),
                                n.update();
                            break;
                        default:
                            c = a.NONE
                    }
            }
            function lt(t) {
                !1 !== n.enabled && (Q(t),
                    n.dispatchEvent(s),
                    c = a.NONE)
            }
            function ut(t) {
                !1 !== n.enabled && t.preventDefault()
            }
            n.domElement.addEventListener("contextmenu", ut),
                n.domElement.addEventListener("pointerdown", $),
                n.domElement.addEventListener("wheel", ot),
                n.domElement.addEventListener("touchstart", at),
                n.domElement.addEventListener("touchend", lt),
                n.domElement.addEventListener("touchmove", ct),
                this.update()
        };
        r.prototype = Object.create(i["k"].prototype),
            r.prototype.constructor = r;
        var o = function(t, e) {
            r.call(this, t, e),
                this.screenSpacePanning = !1,
                this.mouseButtons.LEFT = i["H"].PAN,
                this.mouseButtons.RIGHT = i["H"].ROTATE,
                this.touches.ONE = i["nb"].PAN,
                this.touches.TWO = i["nb"].DOLLY_ROTATE
        };
        o.prototype = Object.create(i["k"].prototype),
            o.prototype.constructor = o
    },
    4840: function(t, e, n) {
        var i = n("825a")
            , r = n("1c0b")
            , o = n("b622")
            , s = o("species");
        t.exports = function(t, e) {
            var n, o = i(t).constructor;
            return void 0 === o || void 0 == (n = i(o)[s]) ? e : r(n)
        }
    },
    4930: function(t, e, n) {
        var i = n("605d")
            , r = n("2d00")
            , o = n("d039");
        t.exports = !!Object.getOwnPropertySymbols && !o((function() {
                return !Symbol.sham && (i ? 38 === r : r > 37 && r < 41)
            }
        ))
    },
    "4d64": function(t, e, n) {
        var i = n("fc6a")
            , r = n("50c4")
            , o = n("23cb")
            , s = function(t) {
            return function(e, n, s) {
                var a, c = i(e), l = r(c.length), u = o(s, l);
                if (t && n != n) {
                    while (l > u)
                        if (a = c[u++],
                        a != a)
                            return !0
                } else
                    for (; l > u; u++)
                        if ((t || u in c) && c[u] === n)
                            return t || u || 0;
                return !t && -1
            }
        };
        t.exports = {
            includes: s(!0),
            indexOf: s(!1)
        }
    },
    "50c4": function(t, e, n) {
        var i = n("a691")
            , r = Math.min;
        t.exports = function(t) {
            return t > 0 ? r(i(t), 9007199254740991) : 0
        }
    },
    5135: function(t, e) {
        var n = {}.hasOwnProperty;
        t.exports = function(t, e) {
            return n.call(t, e)
        }
    },
    5692: function(t, e, n) {
        var i = n("c430")
            , r = n("c6cd");
        (t.exports = function(t, e) {
                return r[t] || (r[t] = void 0 !== e ? e : {})
            }
        )("versions", []).push({
            version: "3.10.0",
            mode: i ? "pure" : "global",
            copyright: " 2021 Denis Pushkarev (zloirock.ru)"
        })
    },
    "56ef": function(t, e, n) {
        var i = n("d066")
            , r = n("241c")
            , o = n("7418")
            , s = n("825a");
        t.exports = i("Reflect", "ownKeys") || function(t) {
            var e = r.f(s(t))
                , n = o.f;
            return n ? e.concat(n(t)) : e
        }
    },
    "5a89": function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
                return md
            }
        )),
            n.d(e, "b", (function() {
                    return Tu
                }
            )),
            n.d(e, "c", (function() {
                    return Sn
                }
            )),
            n.d(e, "d", (function() {
                    return Ki
                }
            )),
            n.d(e, "e", (function() {
                    return gr
                }
            )),
            n.d(e, "f", (function() {
                    return eh
                }
            )),
            n.d(e, "g", (function() {
                    return lt
                }
            )),
            n.d(e, "h", (function() {
                    return Xi
                }
            )),
            n.d(e, "i", (function() {
                    return xp
                }
            )),
            n.d(e, "j", (function() {
                    return f
                }
            )),
            n.d(e, "k", (function() {
                    return sn
                }
            )),
            n.d(e, "l", (function() {
                    return Md
                }
            )),
            n.d(e, "m", (function() {
                    return sr
                }
            )),
            n.d(e, "n", (function() {
                    return $l
                }
            )),
            n.d(e, "o", (function() {
                    return d
                }
            )),
            n.d(e, "p", (function() {
                    return Wl
                }
            )),
            n.d(e, "q", (function() {
                    return jh
                }
            )),
            n.d(e, "r", (function() {
                    return Lp
                }
            )),
            n.d(e, "s", (function() {
                    return eu
                }
            )),
            n.d(e, "t", (function() {
                    return iu
                }
            )),
            n.d(e, "u", (function() {
                    return id
                }
            )),
            n.d(e, "v", (function() {
                    return Pe
                }
            )),
            n.d(e, "w", (function() {
                    return Oe
                }
            )),
            n.d(e, "x", (function() {
                    return Uu
                }
            )),
            n.d(e, "y", (function() {
                    return Du
                }
            )),
            n.d(e, "z", (function() {
                    return Wu
                }
            )),
            n.d(e, "A", (function() {
                    return Vu
                }
            )),
            n.d(e, "B", (function() {
                    return ft
                }
            )),
            n.d(e, "C", (function() {
                    return gt
                }
            )),
            n.d(e, "D", (function() {
                    return mt
                }
            )),
            n.d(e, "E", (function() {
                    return bd
                }
            )),
            n.d(e, "F", (function() {
                    return Ep
                }
            )),
            n.d(e, "G", (function() {
                    return _d
                }
            )),
            n.d(e, "H", (function() {
                    return r
                }
            )),
            n.d(e, "I", (function() {
                    return zi
                }
            )),
            n.d(e, "J", (function() {
                    return ln
                }
            )),
            n.d(e, "K", (function() {
                    return Qn
                }
            )),
            n.d(e, "L", (function() {
                    return Nr
                }
            )),
            n.d(e, "M", (function() {
                    return Yi
                }
            )),
            n.d(e, "N", (function() {
                    return td
                }
            )),
            n.d(e, "O", (function() {
                    return Zh
                }
            )),
            n.d(e, "P", (function() {
                    return Yh
                }
            )),
            n.d(e, "Q", (function() {
                    return ut
                }
            )),
            n.d(e, "R", (function() {
                    return ht
                }
            )),
            n.d(e, "S", (function() {
                    return pt
                }
            )),
            n.d(e, "T", (function() {
                    return dt
                }
            )),
            n.d(e, "U", (function() {
                    return ud
                }
            )),
            n.d(e, "V", (function() {
                    return Mi
                }
            )),
            n.d(e, "W", (function() {
                    return yp
                }
            )),
            n.d(e, "X", (function() {
                    return Wr
                }
            )),
            n.d(e, "Y", (function() {
                    return vp
                }
            )),
            n.d(e, "Z", (function() {
                    return Ku
                }
            )),
            n.d(e, "ab", (function() {
                    return qu
                }
            )),
            n.d(e, "bb", (function() {
                    return Qp
                }
            )),
            n.d(e, "cb", (function() {
                    return xn
                }
            )),
            n.d(e, "db", (function() {
                    return dd
                }
            )),
            n.d(e, "eb", (function() {
                    return Ct
                }
            )),
            n.d(e, "fb", (function() {
                    return ct
                }
            )),
            n.d(e, "gb", (function() {
                    return tu
                }
            )),
            n.d(e, "hb", (function() {
                    return Gr
                }
            )),
            n.d(e, "ib", (function() {
                    return Ru
                }
            )),
            n.d(e, "jb", (function() {
                    return Eu
                }
            )),
            n.d(e, "kb", (function() {
                    return Gn
                }
            )),
            n.d(e, "lb", (function() {
                    return lf
                }
            )),
            n.d(e, "mb", (function() {
                    return dp
                }
            )),
            n.d(e, "nb", (function() {
                    return o
                }
            )),
            n.d(e, "ob", (function() {
                    return Qe
                }
            )),
            n.d(e, "pb", (function() {
                    return Ld
                }
            )),
            n.d(e, "qb", (function() {
                    return Ue
                }
            )),
            n.d(e, "rb", (function() {
                    return ze
                }
            )),
            n.d(e, "sb", (function() {
                    return un
                }
            )),
            n.d(e, "tb", (function() {
                    return bn
                }
            )),
            n.d(e, "ub", (function() {
                    return fd
                }
            )),
            n.d(e, "vb", (function() {
                    return Jl
                }
            )),
            n.d(e, "wb", (function() {
                    return Ge
                }
            ));
        /**
         * @license
         * Copyright 2010-2021 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        const i = "127"
            , r = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
            , o = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
            , s = 0
            , a = 1
            , c = 2
            , l = 1
            , u = 2
            , h = 3
            , d = 0
            , p = 1
            , f = 2
            , m = 1
            , g = 0
            , v = 1
            , y = 2
            , _ = 3
            , x = 4
            , b = 5
            , w = 100
            , M = 101
            , S = 102
            , E = 103
            , T = 104
            , A = 200
            , L = 201
            , R = 202
            , C = 203
            , P = 204
            , O = 205
            , I = 206
            , N = 207
            , D = 208
            , F = 209
            , k = 210
            , H = 0
            , B = 1
            , z = 2
            , U = 3
            , j = 4
            , G = 5
            , V = 6
            , W = 7
            , q = 0
            , X = 1
            , Y = 2
            , Z = 0
            , J = 1
            , K = 2
            , Q = 3
            , $ = 4
            , tt = 5
            , et = 300
            , nt = 301
            , it = 302
            , rt = 303
            , ot = 304
            , st = 306
            , at = 307
            , ct = 1e3
            , lt = 1001
            , ut = 1002
            , ht = 1003
            , dt = 1004
            , pt = 1005
            , ft = 1006
            , mt = 1007
            , gt = 1008
            , vt = 1009
            , yt = 1010
            , _t = 1011
            , xt = 1012
            , bt = 1013
            , wt = 1014
            , Mt = 1015
            , St = 1016
            , Et = 1017
            , Tt = 1018
            , At = 1019
            , Lt = 1020
            , Rt = 1021
            , Ct = 1022
            , Pt = 1023
            , Ot = 1024
            , It = 1025
            , Nt = 1026
            , Dt = 1027
            , Ft = 1028
            , kt = 1029
            , Ht = 1030
            , Bt = 1031
            , zt = 1032
            , Ut = 1033
            , jt = 33776
            , Gt = 33777
            , Vt = 33778
            , Wt = 33779
            , qt = 35840
            , Xt = 35841
            , Yt = 35842
            , Zt = 35843
            , Jt = 36196
            , Kt = 37492
            , Qt = 37496
            , $t = 37808
            , te = 37809
            , ee = 37810
            , ne = 37811
            , ie = 37812
            , re = 37813
            , oe = 37814
            , se = 37815
            , ae = 37816
            , ce = 37817
            , le = 37818
            , ue = 37819
            , he = 37820
            , de = 37821
            , pe = 36492
            , fe = 37840
            , me = 37841
            , ge = 37842
            , ve = 37843
            , ye = 37844
            , _e = 37845
            , xe = 37846
            , be = 37847
            , we = 37848
            , Me = 37849
            , Se = 37850
            , Ee = 37851
            , Te = 37852
            , Ae = 37853
            , Le = 2200
            , Re = 2201
            , Ce = 2202
            , Pe = 2300
            , Oe = 2301
            , Ie = 2302
            , Ne = 2400
            , De = 2401
            , Fe = 2402
            , ke = 2500
            , He = 2501
            , Be = 0
            , ze = 1
            , Ue = 2
            , je = 3e3
            , Ge = 3001
            , Ve = 3007
            , We = 3002
            , qe = 3003
            , Xe = 3004
            , Ye = 3005
            , Ze = 3006
            , Je = 3200
            , Ke = 3201
            , Qe = 0
            , $e = 1
            , tn = 7680
            , en = 519
            , nn = 35044
            , rn = 35048
            , on = "300 es";
        function sn() {}
        Object.assign(sn.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners
                    , i = n[t];
                if (void 0 !== i) {
                    const t = i.indexOf(e);
                    -1 !== t && i.splice(t, 1)
                }
            },
            dispatchEvent: function(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners
                    , n = e[t.type];
                if (void 0 !== n) {
                    t.target = this;
                    const e = n.slice(0);
                    for (let n = 0, i = e.length; n < i; n++)
                        e[n].call(this, t);
                    t.target = null
                }
            }
        });
        const an = [];
        for (let Of = 0; Of < 256; Of++)
            an[Of] = (Of < 16 ? "0" : "") + Of.toString(16);
        let cn = 1234567;
        const ln = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                const t = 4294967295 * Math.random() | 0
                    , e = 4294967295 * Math.random() | 0
                    , n = 4294967295 * Math.random() | 0
                    , i = 4294967295 * Math.random() | 0
                    , r = an[255 & t] + an[t >> 8 & 255] + an[t >> 16 & 255] + an[t >> 24 & 255] + "-" + an[255 & e] + an[e >> 8 & 255] + "-" + an[e >> 16 & 15 | 64] + an[e >> 24 & 255] + "-" + an[63 & n | 128] + an[n >> 8 & 255] + "-" + an[n >> 16 & 255] + an[n >> 24 & 255] + an[255 & i] + an[i >> 8 & 255] + an[i >> 16 & 255] + an[i >> 24 & 255];
                return r.toUpperCase()
            },
            clamp: function(t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            inverseLerp: function(t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: function(t, e, n) {
                return (1 - n) * t + n * e
            },
            damp: function(t, e, n, i) {
                return ln.lerp(t, e, 1 - Math.exp(-n * i))
            },
            pingpong: function(t, e=1) {
                return e - Math.abs(ln.euclideanModulo(t, 2 * e) - e)
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
                t * t * (3 - 2 * t))
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
                t * t * t * (t * (6 * t - 15) + 10))
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function(t) {
                return void 0 !== t && (cn = t % 2147483647),
                    cn = 16807 * cn % 2147483647,
                (cn - 1) / 2147483646
            },
            degToRad: function(t) {
                return t * ln.DEG2RAD
            },
            radToDeg: function(t) {
                return t * ln.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 === (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(t, e, n, i, r) {
                const o = Math.cos
                    , s = Math.sin
                    , a = o(n / 2)
                    , c = s(n / 2)
                    , l = o((e + i) / 2)
                    , u = s((e + i) / 2)
                    , h = o((e - i) / 2)
                    , d = s((e - i) / 2)
                    , p = o((i - e) / 2)
                    , f = s((i - e) / 2);
                switch (r) {
                    case "XYX":
                        t.set(a * u, c * h, c * d, a * l);
                        break;
                    case "YZY":
                        t.set(c * d, a * u, c * h, a * l);
                        break;
                    case "ZXZ":
                        t.set(c * h, c * d, a * u, a * l);
                        break;
                    case "XZX":
                        t.set(a * u, c * f, c * p, a * l);
                        break;
                    case "YXY":
                        t.set(c * p, a * u, c * f, a * l);
                        break;
                    case "ZYZ":
                        t.set(c * f, c * p, a * u, a * l);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            }
        };
        class un {
            constructor(t=0, e=0) {
                this.x = t,
                    this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                    this.y = e,
                    this
            }
            setScalar(t) {
                return this.x = t,
                    this.y = t,
                    this
            }
            setX(t) {
                return this.x = t,
                    this
            }
            setY(t) {
                return this.y = t,
                    this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                    this.y = t.y,
                    this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this)
            }
            addScalar(t) {
                return this.x += t,
                    this.y += t,
                    this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                    this.y += t.y * e,
                    this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this)
            }
            subScalar(t) {
                return this.x -= t,
                    this.y -= t,
                    this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this
            }
            multiply(t) {
                return this.x *= t.x,
                    this.y *= t.y,
                    this
            }
            multiplyScalar(t) {
                return this.x *= t,
                    this.y *= t,
                    this
            }
            divide(t) {
                return this.x /= t.x,
                    this.y /= t.y,
                    this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                    , n = this.y
                    , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6],
                    this.y = i[1] * e + i[4] * n + i[7],
                    this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                    this.y = Math.max(t, Math.min(e, this.y)),
                    this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this
            }
            round() {
                return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this
            }
            negate() {
                return this.x = -this.x,
                    this.y = -this.y,
                    this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                const t = Math.atan2(-this.y, -this.x) + Math.PI;
                return t
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                    , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                    this.y = t.y + (e.y - t.y) * n,
                    this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                    this.y = t[e + 1],
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                    t[e + 1] = this.y,
                    t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                    this.x = t.getX(e),
                    this.y = t.getY(e),
                    this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                    , i = Math.sin(e)
                    , r = this.x - t.x
                    , o = this.y - t.y;
                return this.x = r * n - o * i + t.x,
                    this.y = r * i + o * n + t.y,
                    this
            }
            random() {
                return this.x = Math.random(),
                    this.y = Math.random(),
                    this
            }
        }
        un.prototype.isVector2 = !0;
        class hn {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, o, s, a, c) {
                const l = this.elements;
                return l[0] = t,
                    l[1] = i,
                    l[2] = s,
                    l[3] = e,
                    l[4] = r,
                    l[5] = a,
                    l[6] = n,
                    l[7] = o,
                    l[8] = c,
                    this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                    this
            }
            copy(t) {
                const e = this.elements
                    , n = t.elements;
                return e[0] = n[0],
                    e[1] = n[1],
                    e[2] = n[2],
                    e[3] = n[3],
                    e[4] = n[4],
                    e[5] = n[5],
                    e[6] = n[6],
                    e[7] = n[7],
                    e[8] = n[8],
                    this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                    e.setFromMatrix3Column(this, 1),
                    n.setFromMatrix3Column(this, 2),
                    this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                    this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                    , i = e.elements
                    , r = this.elements
                    , o = n[0]
                    , s = n[3]
                    , a = n[6]
                    , c = n[1]
                    , l = n[4]
                    , u = n[7]
                    , h = n[2]
                    , d = n[5]
                    , p = n[8]
                    , f = i[0]
                    , m = i[3]
                    , g = i[6]
                    , v = i[1]
                    , y = i[4]
                    , _ = i[7]
                    , x = i[2]
                    , b = i[5]
                    , w = i[8];
                return r[0] = o * f + s * v + a * x,
                    r[3] = o * m + s * y + a * b,
                    r[6] = o * g + s * _ + a * w,
                    r[1] = c * f + l * v + u * x,
                    r[4] = c * m + l * y + u * b,
                    r[7] = c * g + l * _ + u * w,
                    r[2] = h * f + d * v + p * x,
                    r[5] = h * m + d * y + p * b,
                    r[8] = h * g + d * _ + p * w,
                    this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                    e[3] *= t,
                    e[6] *= t,
                    e[1] *= t,
                    e[4] *= t,
                    e[7] *= t,
                    e[2] *= t,
                    e[5] *= t,
                    e[8] *= t,
                    this
            }
            determinant() {
                const t = this.elements
                    , e = t[0]
                    , n = t[1]
                    , i = t[2]
                    , r = t[3]
                    , o = t[4]
                    , s = t[5]
                    , a = t[6]
                    , c = t[7]
                    , l = t[8];
                return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a
            }
            invert() {
                const t = this.elements
                    , e = t[0]
                    , n = t[1]
                    , i = t[2]
                    , r = t[3]
                    , o = t[4]
                    , s = t[5]
                    , a = t[6]
                    , c = t[7]
                    , l = t[8]
                    , u = l * o - s * c
                    , h = s * a - l * r
                    , d = c * r - o * a
                    , p = e * u + n * h + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f,
                    t[1] = (i * c - l * n) * f,
                    t[2] = (s * n - i * o) * f,
                    t[3] = h * f,
                    t[4] = (l * e - i * a) * f,
                    t[5] = (i * r - s * e) * f,
                    t[6] = d * f,
                    t[7] = (n * a - c * e) * f,
                    t[8] = (o * e - n * r) * f,
                    this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                    e[1] = e[3],
                    e[3] = t,
                    t = e[2],
                    e[2] = e[6],
                    e[6] = t,
                    t = e[5],
                    e[5] = e[7],
                    e[7] = t,
                    this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                    t[1] = e[3],
                    t[2] = e[6],
                    t[3] = e[1],
                    t[4] = e[4],
                    t[5] = e[7],
                    t[6] = e[2],
                    t[7] = e[5],
                    t[8] = e[8],
                    this
            }
            setUvTransform(t, e, n, i, r, o, s) {
                const a = Math.cos(r)
                    , c = Math.sin(r);
                return this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1),
                    this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t,
                    n[3] *= t,
                    n[6] *= t,
                    n[1] *= e,
                    n[4] *= e,
                    n[7] *= e,
                    this
            }
            rotate(t) {
                const e = Math.cos(t)
                    , n = Math.sin(t)
                    , i = this.elements
                    , r = i[0]
                    , o = i[3]
                    , s = i[6]
                    , a = i[1]
                    , c = i[4]
                    , l = i[7];
                return i[0] = e * r + n * a,
                    i[3] = e * o + n * c,
                    i[6] = e * s + n * l,
                    i[1] = -n * r + e * a,
                    i[4] = -n * o + e * c,
                    i[7] = -n * s + e * l,
                    this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2],
                    n[3] += t * n[5],
                    n[6] += t * n[8],
                    n[1] += e * n[2],
                    n[4] += e * n[5],
                    n[7] += e * n[8],
                    this
            }
            equals(t) {
                const e = this.elements
                    , n = t.elements;
                for (let i = 0; i < 9; i++)
                    if (e[i] !== n[i])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                    t[e + 1] = n[1],
                    t[e + 2] = n[2],
                    t[e + 3] = n[3],
                    t[e + 4] = n[4],
                    t[e + 5] = n[5],
                    t[e + 6] = n[6],
                    t[e + 7] = n[7],
                    t[e + 8] = n[8],
                    t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        let dn;
        hn.prototype.isMatrix3 = !0;
        const pn = {
            getDataURL: function(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === dn && (dn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                        dn.width = t.width,
                        dn.height = t.height;
                    const n = dn.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                        e = dn
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                    e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
        };
        let fn = 0;
        class mn extends sn {
            constructor(t=mn.DEFAULT_IMAGE, e=mn.DEFAULT_MAPPING, n=lt, i=lt, r=ft, o=gt, s=Pt, a=vt, c=1, l=je) {
                super(),
                    Object.defineProperty(this, "id", {
                        value: fn++
                    }),
                    this.uuid = ln.generateUUID(),
                    this.name = "",
                    this.image = t,
                    this.mipmaps = [],
                    this.mapping = e,
                    this.wrapS = n,
                    this.wrapT = i,
                    this.magFilter = r,
                    this.minFilter = o,
                    this.anisotropy = c,
                    this.format = s,
                    this.internalFormat = null,
                    this.type = a,
                    this.offset = new un(0,0),
                    this.repeat = new un(1,1),
                    this.center = new un(0,0),
                    this.rotation = 0,
                    this.matrixAutoUpdate = !0,
                    this.matrix = new hn,
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.encoding = l,
                    this.version = 0,
                    this.onUpdate = null
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                    this.image = t.image,
                    this.mipmaps = t.mipmaps.slice(0),
                    this.mapping = t.mapping,
                    this.wrapS = t.wrapS,
                    this.wrapT = t.wrapT,
                    this.magFilter = t.magFilter,
                    this.minFilter = t.minFilter,
                    this.anisotropy = t.anisotropy,
                    this.format = t.format,
                    this.internalFormat = t.internalFormat,
                    this.type = t.type,
                    this.offset.copy(t.offset),
                    this.repeat.copy(t.repeat),
                    this.center.copy(t.center),
                    this.rotation = t.rotation,
                    this.matrixAutoUpdate = t.matrixAutoUpdate,
                    this.matrix.copy(t.matrix),
                    this.generateMipmaps = t.generateMipmaps,
                    this.premultiplyAlpha = t.premultiplyAlpha,
                    this.flipY = t.flipY,
                    this.unpackAlignment = t.unpackAlignment,
                    this.encoding = t.encoding,
                    this
            }
            toJSON(t) {
                const e = void 0 === t || "string" === typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const i = this.image;
                    if (void 0 === i.uuid && (i.uuid = ln.generateUUID()),
                    !e && void 0 === t.images[i.uuid]) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++)
                                i[t].isDataTexture ? e.push(gn(i[t].image)) : e.push(gn(i[t]))
                        } else
                            e = gn(i);
                        t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: e
                        }
                    }
                    n.image = i.uuid
                }
                return e || (t.textures[this.uuid] = n),
                    n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (this.mapping !== et)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                        case ct:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case lt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case ut:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
                            break
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                        case ct:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case lt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case ut:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
                            break
                    }
                return this.flipY && (t.y = 1 - t.y),
                    t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        function gn(t) {
            return "undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap ? pn.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                {})
        }
        mn.DEFAULT_IMAGE = void 0,
            mn.DEFAULT_MAPPING = et,
            mn.prototype.isTexture = !0;
        class vn {
            constructor(t=0, e=0, n=0, i=1) {
                this.x = t,
                    this.y = e,
                    this.z = n,
                    this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t,
                    this.y = e,
                    this.z = n,
                    this.w = i,
                    this
            }
            setScalar(t) {
                return this.x = t,
                    this.y = t,
                    this.z = t,
                    this.w = t,
                    this
            }
            setX(t) {
                return this.x = t,
                    this
            }
            setY(t) {
                return this.y = t,
                    this
            }
            setZ(t) {
                return this.z = t,
                    this
            }
            setW(t) {
                return this.w = t,
                    this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                    this.y = t.y,
                    this.z = t.z,
                    this.w = void 0 !== t.w ? t.w : 1,
                    this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this.z += t.z,
                    this.w += t.w,
                    this)
            }
            addScalar(t) {
                return this.x += t,
                    this.y += t,
                    this.z += t,
                    this.w += t,
                    this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this.z = t.z + e.z,
                    this.w = t.w + e.w,
                    this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                    this.y += t.y * e,
                    this.z += t.z * e,
                    this.w += t.w * e,
                    this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this.z -= t.z,
                    this.w -= t.w,
                    this)
            }
            subScalar(t) {
                return this.x -= t,
                    this.y -= t,
                    this.z -= t,
                    this.w -= t,
                    this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this.z = t.z - e.z,
                    this.w = t.w - e.w,
                    this
            }
            multiply(t) {
                return this.x *= t.x,
                    this.y *= t.y,
                    this.z *= t.z,
                    this.w *= t.w,
                    this
            }
            multiplyScalar(t) {
                return this.x *= t,
                    this.y *= t,
                    this.z *= t,
                    this.w *= t,
                    this
            }
            applyMatrix4(t) {
                const e = this.x
                    , n = this.y
                    , i = this.z
                    , r = this.w
                    , o = t.elements;
                return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r,
                    this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r,
                    this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r,
                    this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r,
                    this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                    this.y = 0,
                    this.z = 0) : (this.x = t.x / e,
                    this.y = t.y / e,
                    this.z = t.z / e),
                    this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const o = .01
                    , s = .1
                    , a = t.elements
                    , c = a[0]
                    , l = a[4]
                    , u = a[8]
                    , h = a[1]
                    , d = a[5]
                    , p = a[9]
                    , f = a[2]
                    , m = a[6]
                    , g = a[10];
                if (Math.abs(l - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(l + h) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(c + d + g - 3) < s)
                        return this.set(1, 0, 0, 0),
                            this;
                    e = Math.PI;
                    const t = (c + 1) / 2
                        , a = (d + 1) / 2
                        , v = (g + 1) / 2
                        , y = (l + h) / 4
                        , _ = (u + f) / 4
                        , x = (p + m) / 4;
                    return t > a && t > v ? t < o ? (n = 0,
                        i = .707106781,
                        r = .707106781) : (n = Math.sqrt(t),
                        i = y / n,
                        r = _ / n) : a > v ? a < o ? (n = .707106781,
                        i = 0,
                        r = .707106781) : (i = Math.sqrt(a),
                        n = y / i,
                        r = x / i) : v < o ? (n = .707106781,
                        i = .707106781,
                        r = 0) : (r = Math.sqrt(v),
                        n = _ / r,
                        i = x / r),
                        this.set(n, i, r, e),
                        this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
                return Math.abs(v) < .001 && (v = 1),
                    this.x = (m - p) / v,
                    this.y = (u - f) / v,
                    this.z = (h - l) / v,
                    this.w = Math.acos((c + d + g - 1) / 2),
                    this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this.z = Math.min(this.z, t.z),
                    this.w = Math.min(this.w, t.w),
                    this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this.z = Math.max(this.z, t.z),
                    this.w = Math.max(this.w, t.w),
                    this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this.z = Math.max(t.z, Math.min(e.z, this.z)),
                    this.w = Math.max(t.w, Math.min(e.w, this.w)),
                    this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                    this.y = Math.max(t, Math.min(e, this.y)),
                    this.z = Math.max(t, Math.min(e, this.z)),
                    this.w = Math.max(t, Math.min(e, this.w)),
                    this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this.w = Math.floor(this.w),
                    this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this.w = Math.ceil(this.w),
                    this
            }
            round() {
                return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this.w = Math.round(this.w),
                    this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                    this
            }
            negate() {
                return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this.w = -this.w,
                    this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this.z += (t.z - this.z) * e,
                    this.w += (t.w - this.w) * e,
                    this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                    this.y = t.y + (e.y - t.y) * n,
                    this.z = t.z + (e.z - t.z) * n,
                    this.w = t.w + (e.w - t.w) * n,
                    this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                    this.y = t[e + 1],
                    this.z = t[e + 2],
                    this.w = t[e + 3],
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                    t[e + 1] = this.y,
                    t[e + 2] = this.z,
                    t[e + 3] = this.w,
                    t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                    this.x = t.getX(e),
                    this.y = t.getY(e),
                    this.z = t.getZ(e),
                    this.w = t.getW(e),
                    this
            }
            random() {
                return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this.w = Math.random(),
                    this
            }
        }
        vn.prototype.isVector4 = !0;
        class yn extends sn {
            constructor(t, e, n) {
                super(),
                    this.width = t,
                    this.height = e,
                    this.depth = 1,
                    this.scissor = new vn(0,0,t,e),
                    this.scissorTest = !1,
                    this.viewport = new vn(0,0,t,e),
                    n = n || {},
                    this.texture = new mn(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                    this.texture.image = {},
                    this.texture.image.width = t,
                    this.texture.image.height = e,
                    this.texture.image.depth = 1,
                    this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
                    this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ft,
                    this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                    this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
                    this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                },
                    this.texture = t
            }
            setSize(t, e, n=1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t,
                    this.height = e,
                    this.depth = n,
                    this.texture.image.width = t,
                    this.texture.image.height = e,
                    this.texture.image.depth = n,
                    this.dispose()),
                    this.viewport.set(0, 0, t, e),
                    this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width,
                    this.height = t.height,
                    this.depth = t.depth,
                    this.viewport.copy(t.viewport),
                    this.texture = t.texture.clone(),
                    this.depthBuffer = t.depthBuffer,
                    this.stencilBuffer = t.stencilBuffer,
                    this.depthTexture = t.depthTexture,
                    this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        yn.prototype.isWebGLRenderTarget = !0;
        class _n extends yn {
            constructor(t, e, n) {
                super(t, e, n),
                    this.samples = 4
            }
            copy(t) {
                return super.copy.call(this, t),
                    this.samples = t.samples,
                    this
            }
        }
        _n.prototype.isWebGLMultisampleRenderTarget = !0;
        class xn {
            constructor(t=0, e=0, n=0, i=1) {
                this._x = t,
                    this._y = e,
                    this._z = n,
                    this._w = i
            }
            static slerp(t, e, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
                    n.slerpQuaternions(t, e, i)
            }
            static slerpFlat(t, e, n, i, r, o, s) {
                let a = n[i + 0]
                    , c = n[i + 1]
                    , l = n[i + 2]
                    , u = n[i + 3];
                const h = r[o + 0]
                    , d = r[o + 1]
                    , p = r[o + 2]
                    , f = r[o + 3];
                if (0 === s)
                    return t[e + 0] = a,
                        t[e + 1] = c,
                        t[e + 2] = l,
                        void (t[e + 3] = u);
                if (1 === s)
                    return t[e + 0] = h,
                        t[e + 1] = d,
                        t[e + 2] = p,
                        void (t[e + 3] = f);
                if (u !== f || a !== h || c !== d || l !== p) {
                    let t = 1 - s;
                    const e = a * h + c * d + l * p + u * f
                        , n = e >= 0 ? 1 : -1
                        , i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                            , o = Math.atan2(r, e * n);
                        t = Math.sin(t * o) / r,
                            s = Math.sin(s * o) / r
                    }
                    const r = s * n;
                    if (a = a * t + h * r,
                        c = c * t + d * r,
                        l = l * t + p * r,
                        u = u * t + f * r,
                    t === 1 - s) {
                        const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
                        a *= t,
                            c *= t,
                            l *= t,
                            u *= t
                    }
                }
                t[e] = a,
                    t[e + 1] = c,
                    t[e + 2] = l,
                    t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, o) {
                const s = n[i]
                    , a = n[i + 1]
                    , c = n[i + 2]
                    , l = n[i + 3]
                    , u = r[o]
                    , h = r[o + 1]
                    , d = r[o + 2]
                    , p = r[o + 3];
                return t[e] = s * p + l * u + a * d - c * h,
                    t[e + 1] = a * p + l * h + c * u - s * d,
                    t[e + 2] = c * p + l * d + s * h - a * u,
                    t[e + 3] = l * p - s * u - a * h - c * d,
                    t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                    this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                    this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                    this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                    this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                    this._y = e,
                    this._z = n,
                    this._w = i,
                    this._onChangeCallback(),
                    this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                    this._y = t.y,
                    this._z = t.z,
                    this._w = t.w,
                    this._onChangeCallback(),
                    this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x
                    , i = t._y
                    , r = t._z
                    , o = t._order
                    , s = Math.cos
                    , a = Math.sin
                    , c = s(n / 2)
                    , l = s(i / 2)
                    , u = s(r / 2)
                    , h = a(n / 2)
                    , d = a(i / 2)
                    , p = a(r / 2);
                switch (o) {
                    case "XYZ":
                        this._x = h * l * u + c * d * p,
                            this._y = c * d * u - h * l * p,
                            this._z = c * l * p + h * d * u,
                            this._w = c * l * u - h * d * p;
                        break;
                    case "YXZ":
                        this._x = h * l * u + c * d * p,
                            this._y = c * d * u - h * l * p,
                            this._z = c * l * p - h * d * u,
                            this._w = c * l * u + h * d * p;
                        break;
                    case "ZXY":
                        this._x = h * l * u - c * d * p,
                            this._y = c * d * u + h * l * p,
                            this._z = c * l * p + h * d * u,
                            this._w = c * l * u - h * d * p;
                        break;
                    case "ZYX":
                        this._x = h * l * u - c * d * p,
                            this._y = c * d * u + h * l * p,
                            this._z = c * l * p - h * d * u,
                            this._w = c * l * u + h * d * p;
                        break;
                    case "YZX":
                        this._x = h * l * u + c * d * p,
                            this._y = c * d * u + h * l * p,
                            this._z = c * l * p - h * d * u,
                            this._w = c * l * u - h * d * p;
                        break;
                    case "XZY":
                        this._x = h * l * u - c * d * p,
                            this._y = c * d * u - h * l * p,
                            this._z = c * l * p + h * d * u,
                            this._w = c * l * u + h * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !1 !== e && this._onChangeCallback(),
                    this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                    , i = Math.sin(n);
                return this._x = t.x * i,
                    this._y = t.y * i,
                    this._z = t.z * i,
                    this._w = Math.cos(n),
                    this._onChangeCallback(),
                    this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                    , n = e[0]
                    , i = e[4]
                    , r = e[8]
                    , o = e[1]
                    , s = e[5]
                    , a = e[9]
                    , c = e[2]
                    , l = e[6]
                    , u = e[10]
                    , h = n + s + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t,
                        this._x = (l - a) * t,
                        this._y = (r - c) * t,
                        this._z = (o - i) * t
                } else if (n > s && n > u) {
                    const t = 2 * Math.sqrt(1 + n - s - u);
                    this._w = (l - a) / t,
                        this._x = .25 * t,
                        this._y = (i + o) / t,
                        this._z = (r + c) / t
                } else if (s > u) {
                    const t = 2 * Math.sqrt(1 + s - n - u);
                    this._w = (r - c) / t,
                        this._x = (i + o) / t,
                        this._y = .25 * t,
                        this._z = (a + l) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - s);
                    this._w = (o - i) / t,
                        this._x = (r + c) / t,
                        this._y = (a + l) / t,
                        this._z = .25 * t
                }
                return this._onChangeCallback(),
                    this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                    Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                        this._y = t.x,
                        this._z = 0,
                        this._w = n) : (this._x = 0,
                        this._y = -t.z,
                        this._z = t.y,
                        this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                    this._y = t.z * e.x - t.x * e.z,
                    this._z = t.x * e.y - t.y * e.x,
                    this._w = n),
                    this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(ln.clamp(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i),
                    this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                    this._y *= -1,
                    this._z *= -1,
                    this._onChangeCallback(),
                    this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                    this._y = 0,
                    this._z = 0,
                    this._w = 1) : (t = 1 / t,
                    this._x = this._x * t,
                    this._y = this._y * t,
                    this._z = this._z * t,
                    this._w = this._w * t),
                    this._onChangeCallback(),
                    this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                    this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                    , i = t._y
                    , r = t._z
                    , o = t._w
                    , s = e._x
                    , a = e._y
                    , c = e._z
                    , l = e._w;
                return this._x = n * l + o * s + i * c - r * a,
                    this._y = i * l + o * a + r * s - n * c,
                    this._z = r * l + o * c + n * a - i * s,
                    this._w = o * l - n * s - i * a - r * c,
                    this._onChangeCallback(),
                    this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                    , i = this._y
                    , r = this._z
                    , o = this._w;
                let s = o * t._w + n * t._x + i * t._y + r * t._z;
                if (s < 0 ? (this._w = -t._w,
                    this._x = -t._x,
                    this._y = -t._y,
                    this._z = -t._z,
                    s = -s) : this.copy(t),
                s >= 1)
                    return this._w = o,
                        this._x = n,
                        this._y = i,
                        this._z = r,
                        this;
                const a = 1 - s * s;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * o + e * this._w,
                        this._x = t * n + e * this._x,
                        this._y = t * i + e * this._y,
                        this._z = t * r + e * this._z,
                        this.normalize(),
                        this._onChangeCallback(),
                        this
                }
                const c = Math.sqrt(a)
                    , l = Math.atan2(c, s)
                    , u = Math.sin((1 - e) * l) / c
                    , h = Math.sin(e * l) / c;
                return this._w = o * u + this._w * h,
                    this._x = n * u + this._x * h,
                    this._y = i * u + this._y * h,
                    this._z = r * u + this._z * h,
                    this._onChangeCallback(),
                    this
            }
            slerpQuaternions(t, e, n) {
                this.copy(t).slerp(e, n)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                    this._y = t[e + 1],
                    this._z = t[e + 2],
                    this._w = t[e + 3],
                    this._onChangeCallback(),
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                    t[e + 1] = this._y,
                    t[e + 2] = this._z,
                    t[e + 3] = this._w,
                    t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                    this._y = t.getY(e),
                    this._z = t.getZ(e),
                    this._w = t.getW(e),
                    this
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                    this
            }
            _onChangeCallback() {}
        }
        xn.prototype.isQuaternion = !0;
        class bn {
            constructor(t=0, e=0, n=0) {
                this.x = t,
                    this.y = e,
                    this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                    this.x = t,
                    this.y = e,
                    this.z = n,
                    this
            }
            setScalar(t) {
                return this.x = t,
                    this.y = t,
                    this.z = t,
                    this
            }
            setX(t) {
                return this.x = t,
                    this
            }
            setY(t) {
                return this.y = t,
                    this
            }
            setZ(t) {
                return this.z = t,
                    this
            }
            setComponent(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                    this.y = t.y,
                    this.z = t.z,
                    this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                    this.addVectors(t, e)) : (this.x += t.x,
                    this.y += t.y,
                    this.z += t.z,
                    this)
            }
            addScalar(t) {
                return this.x += t,
                    this.y += t,
                    this.z += t,
                    this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                    this.y = t.y + e.y,
                    this.z = t.z + e.z,
                    this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                    this.y += t.y * e,
                    this.z += t.z * e,
                    this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                    this.subVectors(t, e)) : (this.x -= t.x,
                    this.y -= t.y,
                    this.z -= t.z,
                    this)
            }
            subScalar(t) {
                return this.x -= t,
                    this.y -= t,
                    this.z -= t,
                    this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                    this.y = t.y - e.y,
                    this.z = t.z - e.z,
                    this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                    this.multiplyVectors(t, e)) : (this.x *= t.x,
                    this.y *= t.y,
                    this.z *= t.z,
                    this)
            }
            multiplyScalar(t) {
                return this.x *= t,
                    this.y *= t,
                    this.z *= t,
                    this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                    this.y = t.y * e.y,
                    this.z = t.z * e.z,
                    this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                    this.applyQuaternion(Mn.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(Mn.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                    , n = this.y
                    , i = this.z
                    , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i,
                    this.y = r[1] * e + r[4] * n + r[7] * i,
                    this.z = r[2] * e + r[5] * n + r[8] * i,
                    this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                    , n = this.y
                    , i = this.z
                    , r = t.elements
                    , o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o,
                    this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o,
                    this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o,
                    this
            }
            applyQuaternion(t) {
                const e = this.x
                    , n = this.y
                    , i = this.z
                    , r = t.x
                    , o = t.y
                    , s = t.z
                    , a = t.w
                    , c = a * e + o * i - s * n
                    , l = a * n + s * e - r * i
                    , u = a * i + r * n - o * e
                    , h = -r * e - o * n - s * i;
                return this.x = c * a + h * -r + l * -s - u * -o,
                    this.y = l * a + h * -o + u * -r - c * -s,
                    this.z = u * a + h * -s + c * -o - l * -r,
                    this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                    , n = this.y
                    , i = this.z
                    , r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i,
                    this.y = r[1] * e + r[5] * n + r[9] * i,
                    this.z = r[2] * e + r[6] * n + r[10] * i,
                    this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                    this.y /= t.y,
                    this.z /= t.z,
                    this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                    this.y = Math.min(this.y, t.y),
                    this.z = Math.min(this.z, t.z),
                    this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                    this.y = Math.max(this.y, t.y),
                    this.z = Math.max(this.z, t.z),
                    this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                    this.y = Math.max(t.y, Math.min(e.y, this.y)),
                    this.z = Math.max(t.z, Math.min(e.z, this.z)),
                    this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                    this.y = Math.max(t, Math.min(e, this.y)),
                    this.z = Math.max(t, Math.min(e, this.z)),
                    this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this
            }
            round() {
                return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                    this
            }
            negate() {
                return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                    this.y += (t.y - this.y) * e,
                    this.z += (t.z - this.z) * e,
                    this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                    this.y = t.y + (e.y - t.y) * n,
                    this.z = t.z + (e.z - t.z) * n,
                    this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                    this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                    , i = t.y
                    , r = t.z
                    , o = e.x
                    , s = e.y
                    , a = e.z;
                return this.x = i * a - r * s,
                    this.y = r * o - n * a,
                    this.z = n * s - i * o,
                    this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return wn.copy(this).projectOnVector(t),
                    this.sub(wn)
            }
            reflect(t) {
                return this.sub(wn.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(ln.clamp(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                    , n = this.y - t.y
                    , i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n),
                    this.y = Math.cos(e) * t,
                    this.z = i * Math.cos(n),
                    this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                    this.y = n,
                    this.z = t * Math.cos(e),
                    this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                    this.y = e[13],
                    this.z = e[14],
                    this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                    , n = this.setFromMatrixColumn(t, 1).length()
                    , i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                    this.y = n,
                    this.z = i,
                    this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                    this.y = t[e + 1],
                    this.z = t[e + 2],
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                    t[e + 1] = this.y,
                    t[e + 2] = this.z,
                    t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                    this.x = t.getX(e),
                    this.y = t.getY(e),
                    this.z = t.getZ(e),
                    this
            }
            random() {
                return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this
            }
        }
        bn.prototype.isVector3 = !0;
        const wn = new bn
            , Mn = new xn;
        class Sn {
            constructor(t=new bn(1 / 0,1 / 0,1 / 0), e=new bn(-1 / 0,-1 / 0,-1 / 0)) {
                this.min = t,
                    this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                    this.max.copy(e),
                    this
            }
            setFromArray(t) {
                let e = 1 / 0
                    , n = 1 / 0
                    , i = 1 / 0
                    , r = -1 / 0
                    , o = -1 / 0
                    , s = -1 / 0;
                for (let a = 0, c = t.length; a < c; a += 3) {
                    const c = t[a]
                        , l = t[a + 1]
                        , u = t[a + 2];
                    c < e && (e = c),
                    l < n && (n = l),
                    u < i && (i = u),
                    c > r && (r = c),
                    l > o && (o = l),
                    u > s && (s = u)
                }
                return this.min.set(e, n, i),
                    this.max.set(r, o, s),
                    this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0
                    , n = 1 / 0
                    , i = 1 / 0
                    , r = -1 / 0
                    , o = -1 / 0
                    , s = -1 / 0;
                for (let a = 0, c = t.count; a < c; a++) {
                    const c = t.getX(a)
                        , l = t.getY(a)
                        , u = t.getZ(a);
                    c < e && (e = c),
                    l < n && (n = l),
                    u < i && (i = u),
                    c > r && (r = c),
                    l > o && (o = l),
                    u > s && (s = u)
                }
                return this.min.set(e, n, i),
                    this.max.set(r, o, s),
                    this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = Tn.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                    this.max.copy(t).add(n),
                    this
            }
            setFromObject(t) {
                return this.makeEmpty(),
                    this.expandByObject(t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                    this.max.copy(t.max),
                    this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                    this.max.x = this.max.y = this.max.z = -1 / 0,
                    this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
                    t = new bn),
                    this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
                    t = new bn),
                    this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                    this.max.max(t),
                    this
            }
            expandByVector(t) {
                return this.min.sub(t),
                    this.max.add(t),
                    this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                    this.max.addScalar(t),
                    this
            }
            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
                    An.copy(e.boundingBox),
                    An.applyMatrix4(t.matrixWorld),
                    this.union(An));
                const n = t.children;
                for (let i = 0, r = n.length; i < r; i++)
                    this.expandByObject(n[i]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
                    e = new bn),
                    e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, Tn),
                Tn.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                    n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                    n = t.normal.x * this.min.x),
                    t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                        n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                        n += t.normal.y * this.min.y),
                    t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                        n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                        n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(Nn),
                    Dn.subVectors(this.max, Nn),
                    Ln.subVectors(t.a, Nn),
                    Rn.subVectors(t.b, Nn),
                    Cn.subVectors(t.c, Nn),
                    Pn.subVectors(Rn, Ln),
                    On.subVectors(Cn, Rn),
                    In.subVectors(Ln, Cn);
                let e = [0, -Pn.z, Pn.y, 0, -On.z, On.y, 0, -In.z, In.y, Pn.z, 0, -Pn.x, On.z, 0, -On.x, In.z, 0, -In.x, -Pn.y, Pn.x, 0, -On.y, On.x, 0, -In.y, In.x, 0];
                return !!Hn(e, Ln, Rn, Cn, Dn) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Hn(e, Ln, Rn, Cn, Dn) && (Fn.crossVectors(Pn, On),
                    e = [Fn.x, Fn.y, Fn.z],
                    Hn(e, Ln, Rn, Cn, Dn)))
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
                    e = new bn),
                    e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                const e = Tn.copy(t).clamp(this.min, this.max);
                return e.sub(t).length()
            }
            getBoundingSphere(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
                    this.getCenter(t.center),
                    t.radius = .5 * this.getSize(Tn).length(),
                    t
            }
            intersect(t) {
                return this.min.max(t.min),
                    this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                    this
            }
            union(t) {
                return this.min.min(t.min),
                    this.max.max(t.max),
                    this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (En[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                    En[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                    En[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                    En[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                    En[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                    En[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                    En[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                    En[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                    this.setFromPoints(En)),
                    this
            }
            translate(t) {
                return this.min.add(t),
                    this.max.add(t),
                    this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        Sn.prototype.isBox3 = !0;
        const En = [new bn, new bn, new bn, new bn, new bn, new bn, new bn, new bn]
            , Tn = new bn
            , An = new Sn
            , Ln = new bn
            , Rn = new bn
            , Cn = new bn
            , Pn = new bn
            , On = new bn
            , In = new bn
            , Nn = new bn
            , Dn = new bn
            , Fn = new bn
            , kn = new bn;
        function Hn(t, e, n, i, r) {
            for (let o = 0, s = t.length - 3; o <= s; o += 3) {
                kn.fromArray(t, o);
                const s = r.x * Math.abs(kn.x) + r.y * Math.abs(kn.y) + r.z * Math.abs(kn.z)
                    , a = e.dot(kn)
                    , c = n.dot(kn)
                    , l = i.dot(kn);
                if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s)
                    return !1
            }
            return !0
        }
        const Bn = new Sn
            , zn = new bn
            , Un = new bn
            , jn = new bn;
        class Gn {
            constructor(t=new bn, e=-1) {
                this.center = t,
                    this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                    this.radius = e,
                    this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Bn.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let r = 0, o = t.length; r < o; r++)
                    i = Math.max(i, n.distanceToSquared(t[r]));
                return this.radius = Math.sqrt(i),
                    this
            }
            copy(t) {
                return this.center.copy(t.center),
                    this.radius = t.radius,
                    this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                    this.radius = -1,
                    this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
                    e = new bn),
                    e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                    e.multiplyScalar(this.radius).add(this.center)),
                    e
            }
            getBoundingBox(t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
                    t = new Sn),
                    this.isEmpty() ? (t.makeEmpty(),
                        t) : (t.set(this.center, this.center),
                        t.expandByScalar(this.radius),
                        t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                    this.radius = this.radius * t.getMaxScaleOnAxis(),
                    this
            }
            translate(t) {
                return this.center.add(t),
                    this
            }
            expandByPoint(t) {
                jn.subVectors(t, this.center);
                const e = jn.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                        , n = .5 * (t - this.radius);
                    this.center.add(jn.multiplyScalar(n / t)),
                        this.radius += n
                }
                return this
            }
            union(t) {
                return Un.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
                    this.expandByPoint(zn.copy(t.center).add(Un)),
                    this.expandByPoint(zn.copy(t.center).sub(Un)),
                    this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Vn = new bn
            , Wn = new bn
            , qn = new bn
            , Xn = new bn
            , Yn = new bn
            , Zn = new bn
            , Jn = new bn;
        class Kn {
            constructor(t=new bn, e=new bn(0,0,-1)) {
                this.origin = t,
                    this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                    this.direction.copy(e),
                    this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                    this.direction.copy(t.direction),
                    this
            }
            at(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
                    e = new bn),
                    e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                    this
            }
            recast(t) {
                return this.origin.copy(this.at(t, Vn)),
                    this
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
                    e = new bn),
                    e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = Vn.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (Vn.copy(this.direction).multiplyScalar(e).add(this.origin),
                    Vn.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Wn.copy(t).add(e).multiplyScalar(.5),
                    qn.copy(e).sub(t).normalize(),
                    Xn.copy(this.origin).sub(Wn);
                const r = .5 * t.distanceTo(e)
                    , o = -this.direction.dot(qn)
                    , s = Xn.dot(this.direction)
                    , a = -Xn.dot(qn)
                    , c = Xn.lengthSq()
                    , l = Math.abs(1 - o * o);
                let u, h, d, p;
                if (l > 0)
                    if (u = o * a - s,
                        h = o * s - a,
                        p = r * l,
                    u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const t = 1 / l;
                                u *= t,
                                    h *= t,
                                    d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + c
                            } else
                                h = r,
                                    u = Math.max(0, -(o * h + s)),
                                    d = -u * u + h * (h + 2 * a) + c;
                        else
                            h = -r,
                                u = Math.max(0, -(o * h + s)),
                                d = -u * u + h * (h + 2 * a) + c;
                    else
                        h <= -p ? (u = Math.max(0, -(-o * r + s)),
                            h = u > 0 ? -r : Math.min(Math.max(-r, -a), r),
                            d = -u * u + h * (h + 2 * a) + c) : h <= p ? (u = 0,
                            h = Math.min(Math.max(-r, -a), r),
                            d = h * (h + 2 * a) + c) : (u = Math.max(0, -(o * r + s)),
                            h = u > 0 ? r : Math.min(Math.max(-r, -a), r),
                            d = -u * u + h * (h + 2 * a) + c);
                else
                    h = o > 0 ? -r : r,
                        u = Math.max(0, -(o * h + s)),
                        d = -u * u + h * (h + 2 * a) + c;
                return n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
                i && i.copy(qn).multiplyScalar(h).add(Wn),
                    d
            }
            intersectSphere(t, e) {
                Vn.subVectors(t.center, this.origin);
                const n = Vn.dot(this.direction)
                    , i = Vn.dot(Vn) - n * n
                    , r = t.radius * t.radius;
                if (i > r)
                    return null;
                const o = Math.sqrt(r - i)
                    , s = n - o
                    , a = n + o;
                return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e)
                    return !0;
                const n = t.normal.dot(this.direction);
                return n * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, o, s, a;
                const c = 1 / this.direction.x
                    , l = 1 / this.direction.y
                    , u = 1 / this.direction.z
                    , h = this.origin;
                return c >= 0 ? (n = (t.min.x - h.x) * c,
                    i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c,
                    i = (t.min.x - h.x) * c),
                    l >= 0 ? (r = (t.min.y - h.y) * l,
                        o = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l,
                        o = (t.min.y - h.y) * l),
                    n > o || r > i ? null : ((r > n || n !== n) && (n = r),
                    (o < i || i !== i) && (i = o),
                        u >= 0 ? (s = (t.min.z - h.z) * u,
                            a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u,
                            a = (t.min.z - h.z) * u),
                        n > a || s > i ? null : ((s > n || n !== n) && (n = s),
                        (a < i || i !== i) && (i = a),
                            i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, Vn)
            }
            intersectTriangle(t, e, n, i, r) {
                Yn.subVectors(e, t),
                    Zn.subVectors(n, t),
                    Jn.crossVectors(Yn, Zn);
                let o, s = this.direction.dot(Jn);
                if (s > 0) {
                    if (i)
                        return null;
                    o = 1
                } else {
                    if (!(s < 0))
                        return null;
                    o = -1,
                        s = -s
                }
                Xn.subVectors(this.origin, t);
                const a = o * this.direction.dot(Zn.crossVectors(Xn, Zn));
                if (a < 0)
                    return null;
                const c = o * this.direction.dot(Yn.cross(Xn));
                if (c < 0)
                    return null;
                if (a + c > s)
                    return null;
                const l = -o * Xn.dot(Jn);
                return l < 0 ? null : this.at(l / s, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                    this.direction.transformDirection(t),
                    this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Qn {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, o, s, a, c, l, u, h, d, p, f, m) {
                const g = this.elements;
                return g[0] = t,
                    g[4] = e,
                    g[8] = n,
                    g[12] = i,
                    g[1] = r,
                    g[5] = o,
                    g[9] = s,
                    g[13] = a,
                    g[2] = c,
                    g[6] = l,
                    g[10] = u,
                    g[14] = h,
                    g[3] = d,
                    g[7] = p,
                    g[11] = f,
                    g[15] = m,
                    this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
            }
            clone() {
                return (new Qn).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                    , n = t.elements;
                return e[0] = n[0],
                    e[1] = n[1],
                    e[2] = n[2],
                    e[3] = n[3],
                    e[4] = n[4],
                    e[5] = n[5],
                    e[6] = n[6],
                    e[7] = n[7],
                    e[8] = n[8],
                    e[9] = n[9],
                    e[10] = n[10],
                    e[11] = n[11],
                    e[12] = n[12],
                    e[13] = n[13],
                    e[14] = n[14],
                    e[15] = n[15],
                    this
            }
            copyPosition(t) {
                const e = this.elements
                    , n = t.elements;
                return e[12] = n[12],
                    e[13] = n[13],
                    e[14] = n[14],
                    this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                    this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                    e.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                    this
            }
            extractRotation(t) {
                const e = this.elements
                    , n = t.elements
                    , i = 1 / $n.setFromMatrixColumn(t, 0).length()
                    , r = 1 / $n.setFromMatrixColumn(t, 1).length()
                    , o = 1 / $n.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i,
                    e[1] = n[1] * i,
                    e[2] = n[2] * i,
                    e[3] = 0,
                    e[4] = n[4] * r,
                    e[5] = n[5] * r,
                    e[6] = n[6] * r,
                    e[7] = 0,
                    e[8] = n[8] * o,
                    e[9] = n[9] * o,
                    e[10] = n[10] * o,
                    e[11] = 0,
                    e[12] = 0,
                    e[13] = 0,
                    e[14] = 0,
                    e[15] = 1,
                    this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements
                    , n = t.x
                    , i = t.y
                    , r = t.z
                    , o = Math.cos(n)
                    , s = Math.sin(n)
                    , a = Math.cos(i)
                    , c = Math.sin(i)
                    , l = Math.cos(r)
                    , u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = o * l
                        , n = o * u
                        , i = s * l
                        , r = s * u;
                    e[0] = a * l,
                        e[4] = -a * u,
                        e[8] = c,
                        e[1] = n + i * c,
                        e[5] = t - r * c,
                        e[9] = -s * a,
                        e[2] = r - t * c,
                        e[6] = i + n * c,
                        e[10] = o * a
                } else if ("YXZ" === t.order) {
                    const t = a * l
                        , n = a * u
                        , i = c * l
                        , r = c * u;
                    e[0] = t + r * s,
                        e[4] = i * s - n,
                        e[8] = o * c,
                        e[1] = o * u,
                        e[5] = o * l,
                        e[9] = -s,
                        e[2] = n * s - i,
                        e[6] = r + t * s,
                        e[10] = o * a
                } else if ("ZXY" === t.order) {
                    const t = a * l
                        , n = a * u
                        , i = c * l
                        , r = c * u;
                    e[0] = t - r * s,
                        e[4] = -o * u,
                        e[8] = i + n * s,
                        e[1] = n + i * s,
                        e[5] = o * l,
                        e[9] = r - t * s,
                        e[2] = -o * c,
                        e[6] = s,
                        e[10] = o * a
                } else if ("ZYX" === t.order) {
                    const t = o * l
                        , n = o * u
                        , i = s * l
                        , r = s * u;
                    e[0] = a * l,
                        e[4] = i * c - n,
                        e[8] = t * c + r,
                        e[1] = a * u,
                        e[5] = r * c + t,
                        e[9] = n * c - i,
                        e[2] = -c,
                        e[6] = s * a,
                        e[10] = o * a
                } else if ("YZX" === t.order) {
                    const t = o * a
                        , n = o * c
                        , i = s * a
                        , r = s * c;
                    e[0] = a * l,
                        e[4] = r - t * u,
                        e[8] = i * u + n,
                        e[1] = u,
                        e[5] = o * l,
                        e[9] = -s * l,
                        e[2] = -c * l,
                        e[6] = n * u + i,
                        e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = o * a
                        , n = o * c
                        , i = s * a
                        , r = s * c;
                    e[0] = a * l,
                        e[4] = -u,
                        e[8] = c * l,
                        e[1] = t * u + r,
                        e[5] = o * l,
                        e[9] = n * u - i,
                        e[2] = i * u - n,
                        e[6] = s * l,
                        e[10] = r * u + t
                }
                return e[3] = 0,
                    e[7] = 0,
                    e[11] = 0,
                    e[12] = 0,
                    e[13] = 0,
                    e[14] = 0,
                    e[15] = 1,
                    this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(ei, t, ni)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return oi.subVectors(t, e),
                0 === oi.lengthSq() && (oi.z = 1),
                    oi.normalize(),
                    ii.crossVectors(n, oi),
                0 === ii.lengthSq() && (1 === Math.abs(n.z) ? oi.x += 1e-4 : oi.z += 1e-4,
                    oi.normalize(),
                    ii.crossVectors(n, oi)),
                    ii.normalize(),
                    ri.crossVectors(oi, ii),
                    i[0] = ii.x,
                    i[4] = ri.x,
                    i[8] = oi.x,
                    i[1] = ii.y,
                    i[5] = ri.y,
                    i[9] = oi.y,
                    i[2] = ii.z,
                    i[6] = ri.z,
                    i[10] = oi.z,
                    this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                    this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                    , i = e.elements
                    , r = this.elements
                    , o = n[0]
                    , s = n[4]
                    , a = n[8]
                    , c = n[12]
                    , l = n[1]
                    , u = n[5]
                    , h = n[9]
                    , d = n[13]
                    , p = n[2]
                    , f = n[6]
                    , m = n[10]
                    , g = n[14]
                    , v = n[3]
                    , y = n[7]
                    , _ = n[11]
                    , x = n[15]
                    , b = i[0]
                    , w = i[4]
                    , M = i[8]
                    , S = i[12]
                    , E = i[1]
                    , T = i[5]
                    , A = i[9]
                    , L = i[13]
                    , R = i[2]
                    , C = i[6]
                    , P = i[10]
                    , O = i[14]
                    , I = i[3]
                    , N = i[7]
                    , D = i[11]
                    , F = i[15];
                return r[0] = o * b + s * E + a * R + c * I,
                    r[4] = o * w + s * T + a * C + c * N,
                    r[8] = o * M + s * A + a * P + c * D,
                    r[12] = o * S + s * L + a * O + c * F,
                    r[1] = l * b + u * E + h * R + d * I,
                    r[5] = l * w + u * T + h * C + d * N,
                    r[9] = l * M + u * A + h * P + d * D,
                    r[13] = l * S + u * L + h * O + d * F,
                    r[2] = p * b + f * E + m * R + g * I,
                    r[6] = p * w + f * T + m * C + g * N,
                    r[10] = p * M + f * A + m * P + g * D,
                    r[14] = p * S + f * L + m * O + g * F,
                    r[3] = v * b + y * E + _ * R + x * I,
                    r[7] = v * w + y * T + _ * C + x * N,
                    r[11] = v * M + y * A + _ * P + x * D,
                    r[15] = v * S + y * L + _ * O + x * F,
                    this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                    e[4] *= t,
                    e[8] *= t,
                    e[12] *= t,
                    e[1] *= t,
                    e[5] *= t,
                    e[9] *= t,
                    e[13] *= t,
                    e[2] *= t,
                    e[6] *= t,
                    e[10] *= t,
                    e[14] *= t,
                    e[3] *= t,
                    e[7] *= t,
                    e[11] *= t,
                    e[15] *= t,
                    this
            }
            determinant() {
                const t = this.elements
                    , e = t[0]
                    , n = t[4]
                    , i = t[8]
                    , r = t[12]
                    , o = t[1]
                    , s = t[5]
                    , a = t[9]
                    , c = t[13]
                    , l = t[2]
                    , u = t[6]
                    , h = t[10]
                    , d = t[14]
                    , p = t[3]
                    , f = t[7]
                    , m = t[11]
                    , g = t[15];
                return p * (+r * a * u - i * c * u - r * s * h + n * c * h + i * s * d - n * a * d) + f * (+e * a * d - e * c * h + r * o * h - i * o * d + i * c * l - r * a * l) + m * (+e * c * u - e * s * d - r * o * u + n * o * d + r * s * l - n * c * l) + g * (-i * s * l - e * a * u + e * s * h + i * o * u - n * o * h + n * a * l)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                    t[1] = t[4],
                    t[4] = e,
                    e = t[2],
                    t[2] = t[8],
                    t[8] = e,
                    e = t[6],
                    t[6] = t[9],
                    t[9] = e,
                    e = t[3],
                    t[3] = t[12],
                    t[12] = e,
                    e = t[7],
                    t[7] = t[13],
                    t[13] = e,
                    e = t[11],
                    t[11] = t[14],
                    t[14] = e,
                    this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x,
                    i[13] = t.y,
                    i[14] = t.z) : (i[12] = t,
                    i[13] = e,
                    i[14] = n),
                    this
            }
            invert() {
                const t = this.elements
                    , e = t[0]
                    , n = t[1]
                    , i = t[2]
                    , r = t[3]
                    , o = t[4]
                    , s = t[5]
                    , a = t[6]
                    , c = t[7]
                    , l = t[8]
                    , u = t[9]
                    , h = t[10]
                    , d = t[11]
                    , p = t[12]
                    , f = t[13]
                    , m = t[14]
                    , g = t[15]
                    , v = u * m * c - f * h * c + f * a * d - s * m * d - u * a * g + s * h * g
                    , y = p * h * c - l * m * c - p * a * d + o * m * d + l * a * g - o * h * g
                    , _ = l * f * c - p * u * c + p * s * d - o * f * d - l * s * g + o * u * g
                    , x = p * u * a - l * f * a - p * s * h + o * f * h + l * s * m - o * u * m
                    , b = e * v + n * y + i * _ + r * x;
                if (0 === b)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / b;
                return t[0] = v * w,
                    t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w,
                    t[2] = (s * m * r - f * a * r + f * i * c - n * m * c - s * i * g + n * a * g) * w,
                    t[3] = (u * a * r - s * h * r - u * i * c + n * h * c + s * i * d - n * a * d) * w,
                    t[4] = y * w,
                    t[5] = (l * m * r - p * h * r + p * i * d - e * m * d - l * i * g + e * h * g) * w,
                    t[6] = (p * a * r - o * m * r - p * i * c + e * m * c + o * i * g - e * a * g) * w,
                    t[7] = (o * h * r - l * a * r + l * i * c - e * h * c - o * i * d + e * a * d) * w,
                    t[8] = _ * w,
                    t[9] = (p * u * r - l * f * r - p * n * d + e * f * d + l * n * g - e * u * g) * w,
                    t[10] = (o * f * r - p * s * r + p * n * c - e * f * c - o * n * g + e * s * g) * w,
                    t[11] = (l * s * r - o * u * r - l * n * c + e * u * c + o * n * d - e * s * d) * w,
                    t[12] = x * w,
                    t[13] = (l * f * i - p * u * i + p * n * h - e * f * h - l * n * m + e * u * m) * w,
                    t[14] = (p * s * i - o * f * i - p * n * a + e * f * a + o * n * m - e * s * m) * w,
                    t[15] = (o * u * i - l * s * i + l * n * a - e * u * a - o * n * h + e * s * h) * w,
                    this
            }
            scale(t) {
                const e = this.elements
                    , n = t.x
                    , i = t.y
                    , r = t.z;
                return e[0] *= n,
                    e[4] *= i,
                    e[8] *= r,
                    e[1] *= n,
                    e[5] *= i,
                    e[9] *= r,
                    e[2] *= n,
                    e[6] *= i,
                    e[10] *= r,
                    e[3] *= n,
                    e[7] *= i,
                    e[11] *= r,
                    this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                    , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                    , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                    , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                    this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                    , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                    this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                    , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                    this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                    , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                    , i = Math.sin(e)
                    , r = 1 - n
                    , o = t.x
                    , s = t.y
                    , a = t.z
                    , c = r * o
                    , l = r * s;
                return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1),
                    this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
            }
            makeShear(t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
                    this
            }
            compose(t, e, n) {
                const i = this.elements
                    , r = e._x
                    , o = e._y
                    , s = e._z
                    , a = e._w
                    , c = r + r
                    , l = o + o
                    , u = s + s
                    , h = r * c
                    , d = r * l
                    , p = r * u
                    , f = o * l
                    , m = o * u
                    , g = s * u
                    , v = a * c
                    , y = a * l
                    , _ = a * u
                    , x = n.x
                    , b = n.y
                    , w = n.z;
                return i[0] = (1 - (f + g)) * x,
                    i[1] = (d + _) * x,
                    i[2] = (p - y) * x,
                    i[3] = 0,
                    i[4] = (d - _) * b,
                    i[5] = (1 - (h + g)) * b,
                    i[6] = (m + v) * b,
                    i[7] = 0,
                    i[8] = (p + y) * w,
                    i[9] = (m - v) * w,
                    i[10] = (1 - (h + f)) * w,
                    i[11] = 0,
                    i[12] = t.x,
                    i[13] = t.y,
                    i[14] = t.z,
                    i[15] = 1,
                    this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = $n.set(i[0], i[1], i[2]).length();
                const o = $n.set(i[4], i[5], i[6]).length()
                    , s = $n.set(i[8], i[9], i[10]).length()
                    , a = this.determinant();
                a < 0 && (r = -r),
                    t.x = i[12],
                    t.y = i[13],
                    t.z = i[14],
                    ti.copy(this);
                const c = 1 / r
                    , l = 1 / o
                    , u = 1 / s;
                return ti.elements[0] *= c,
                    ti.elements[1] *= c,
                    ti.elements[2] *= c,
                    ti.elements[4] *= l,
                    ti.elements[5] *= l,
                    ti.elements[6] *= l,
                    ti.elements[8] *= u,
                    ti.elements[9] *= u,
                    ti.elements[10] *= u,
                    e.setFromRotationMatrix(ti),
                    n.x = r,
                    n.y = o,
                    n.z = s,
                    this
            }
            makePerspective(t, e, n, i, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const s = this.elements
                    , a = 2 * r / (e - t)
                    , c = 2 * r / (n - i)
                    , l = (e + t) / (e - t)
                    , u = (n + i) / (n - i)
                    , h = -(o + r) / (o - r)
                    , d = -2 * o * r / (o - r);
                return s[0] = a,
                    s[4] = 0,
                    s[8] = l,
                    s[12] = 0,
                    s[1] = 0,
                    s[5] = c,
                    s[9] = u,
                    s[13] = 0,
                    s[2] = 0,
                    s[6] = 0,
                    s[10] = h,
                    s[14] = d,
                    s[3] = 0,
                    s[7] = 0,
                    s[11] = -1,
                    s[15] = 0,
                    this
            }
            makeOrthographic(t, e, n, i, r, o) {
                const s = this.elements
                    , a = 1 / (e - t)
                    , c = 1 / (n - i)
                    , l = 1 / (o - r)
                    , u = (e + t) * a
                    , h = (n + i) * c
                    , d = (o + r) * l;
                return s[0] = 2 * a,
                    s[4] = 0,
                    s[8] = 0,
                    s[12] = -u,
                    s[1] = 0,
                    s[5] = 2 * c,
                    s[9] = 0,
                    s[13] = -h,
                    s[2] = 0,
                    s[6] = 0,
                    s[10] = -2 * l,
                    s[14] = -d,
                    s[3] = 0,
                    s[7] = 0,
                    s[11] = 0,
                    s[15] = 1,
                    this
            }
            equals(t) {
                const e = this.elements
                    , n = t.elements;
                for (let i = 0; i < 16; i++)
                    if (e[i] !== n[i])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                    t[e + 1] = n[1],
                    t[e + 2] = n[2],
                    t[e + 3] = n[3],
                    t[e + 4] = n[4],
                    t[e + 5] = n[5],
                    t[e + 6] = n[6],
                    t[e + 7] = n[7],
                    t[e + 8] = n[8],
                    t[e + 9] = n[9],
                    t[e + 10] = n[10],
                    t[e + 11] = n[11],
                    t[e + 12] = n[12],
                    t[e + 13] = n[13],
                    t[e + 14] = n[14],
                    t[e + 15] = n[15],
                    t
            }
        }
        Qn.prototype.isMatrix4 = !0;
        const $n = new bn
            , ti = new Qn
            , ei = new bn(0,0,0)
            , ni = new bn(1,1,1)
            , ii = new bn
            , ri = new bn
            , oi = new bn
            , si = new Qn
            , ai = new xn;
        class ci {
            constructor(t=0, e=0, n=0, i=ci.DefaultOrder) {
                this._x = t,
                    this._y = e,
                    this._z = n,
                    this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                    this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                    this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                    this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                    this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                    this._y = e,
                    this._z = n,
                    this._order = i || this._order,
                    this._onChangeCallback(),
                    this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                    this._y = t._y,
                    this._z = t._z,
                    this._order = t._order,
                    this._onChangeCallback(),
                    this
            }
            setFromRotationMatrix(t, e, n) {
                const i = ln.clamp
                    , r = t.elements
                    , o = r[0]
                    , s = r[4]
                    , a = r[8]
                    , c = r[1]
                    , l = r[5]
                    , u = r[9]
                    , h = r[2]
                    , d = r[6]
                    , p = r[10];
                switch (e = e || this._order,
                    e) {
                    case "XYZ":
                        this._y = Math.asin(i(a, -1, 1)),
                            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p),
                                this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, l),
                                this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-i(u, -1, 1)),
                            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p),
                                this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o),
                                this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(i(d, -1, 1)),
                            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p),
                                this._z = Math.atan2(-s, l)) : (this._y = 0,
                                this._z = Math.atan2(c, o));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-i(h, -1, 1)),
                            Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p),
                                this._z = Math.atan2(c, o)) : (this._x = 0,
                                this._z = Math.atan2(-s, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(i(c, -1, 1)),
                            Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l),
                                this._y = Math.atan2(-h, o)) : (this._x = 0,
                                this._y = Math.atan2(a, p));
                        break;
                    case "XZY":
                        this._z = Math.asin(-i(s, -1, 1)),
                            Math.abs(s) < .9999999 ? (this._x = Math.atan2(d, l),
                                this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, p),
                                this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !1 !== n && this._onChangeCallback(),
                    this
            }
            setFromQuaternion(t, e, n) {
                return si.makeRotationFromQuaternion(t),
                    this.setFromRotationMatrix(si, e, n)
            }
            setFromVector3(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }
            reorder(t) {
                return ai.setFromEuler(this),
                    this.setFromQuaternion(ai, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                    this._y = t[1],
                    this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                    this._onChangeCallback(),
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                    t[e + 1] = this._y,
                    t[e + 2] = this._z,
                    t[e + 3] = this._order,
                    t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new bn(this._x,this._y,this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                    this
            }
            _onChangeCallback() {}
        }
        ci.prototype.isEuler = !0,
            ci.DefaultOrder = "XYZ",
            ci.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class li {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 !== (this.mask & t.mask)
            }
        }
        let ui = 0;
        const hi = new bn
            , di = new xn
            , pi = new Qn
            , fi = new bn
            , mi = new bn
            , gi = new bn
            , vi = new xn
            , yi = new bn(1,0,0)
            , _i = new bn(0,1,0)
            , xi = new bn(0,0,1)
            , bi = {
            type: "added"
        }
            , wi = {
            type: "removed"
        };
        function Mi() {
            Object.defineProperty(this, "id", {
                value: ui++
            }),
                this.uuid = ln.generateUUID(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Mi.DefaultUp.clone();
            const t = new bn
                , e = new ci
                , n = new xn
                , i = new bn(1,1,1);
            function r() {
                n.setFromEuler(e, !1)
            }
            function o() {
                e.setFromQuaternion(n, void 0, !1)
            }
            e._onChange(r),
                n._onChange(o),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Qn
                    },
                    normalMatrix: {
                        value: new hn
                    }
                }),
                this.matrix = new Qn,
                this.matrixWorld = new Qn,
                this.matrixAutoUpdate = Mi.DefaultMatrixAutoUpdate,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new li,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
        }
        Mi.DefaultUp = new bn(0,1,0),
            Mi.DefaultMatrixAutoUpdate = !0,
            Mi.prototype = Object.assign(Object.create(sn.prototype), {
                constructor: Mi,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                        this.matrix.premultiply(t),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t),
                        this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return di.setFromAxisAngle(t, e),
                        this.quaternion.multiply(di),
                        this
                },
                rotateOnWorldAxis: function(t, e) {
                    return di.setFromAxisAngle(t, e),
                        this.quaternion.premultiply(di),
                        this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(yi, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(_i, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(xi, t)
                },
                translateOnAxis: function(t, e) {
                    return hi.copy(t).applyQuaternion(this.quaternion),
                        this.position.add(hi.multiplyScalar(e)),
                        this
                },
                translateX: function(t) {
                    return this.translateOnAxis(yi, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(_i, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(xi, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(pi.copy(this.matrixWorld).invert())
                },
                lookAt: function(t, e, n) {
                    t.isVector3 ? fi.copy(t) : fi.set(t, e, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1),
                        mi.setFromMatrixPosition(this.matrixWorld),
                        this.isCamera || this.isLight ? pi.lookAt(mi, fi, this.up) : pi.lookAt(fi, mi, this.up),
                        this.quaternion.setFromRotationMatrix(pi),
                    i && (pi.extractRotation(i.matrixWorld),
                        di.setFromRotationMatrix(pi),
                        this.quaternion.premultiply(di.invert()))
                },
                add: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++)
                            this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                        this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                        t.parent = this,
                        this.children.push(t),
                        t.dispatchEvent(bi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                        this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++)
                            this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null,
                        this.children.splice(e, 1),
                        t.dispatchEvent(wi)),
                        this
                },
                clear: function() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        e.parent = null,
                            e.dispatchEvent(wi)
                    }
                    return this.children.length = 0,
                        this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1),
                        pi.copy(this.matrixWorld).invert(),
                    null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                        pi.multiply(t.parent.matrixWorld)),
                        t.applyMatrix4(pi),
                        this.add(t),
                        t.updateWorldMatrix(!1, !0),
                        this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e)
                        return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n]
                            , r = i.getObjectByProperty(t, e);
                        if (void 0 !== r)
                            return r
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
                        t = new bn),
                        this.updateWorldMatrix(!0, !1),
                        t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                        t = new xn),
                        this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(mi, t, gi),
                        t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                        t = new bn),
                        this.updateWorldMatrix(!0, !1),
                        this.matrixWorld.decompose(mi, vi, t),
                        t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
                        t = new bn),
                        this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++)
                        e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 === this.visible)
                        return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++)
                        e[n].traverseVisible(t)
                },
                traverseAncestors: function(t) {
                    const e = this.parent;
                    null !== e && (t(e),
                        e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                    (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        this.matrixWorldNeedsUpdate = !1,
                        t = !0);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++)
                        e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    const n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                    this.matrixAutoUpdate && this.updateMatrix(),
                        null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                    !0 === e) {
                        const t = this.children;
                        for (let e = 0, n = t.length; e < n; e++)
                            t[e].updateWorldMatrix(!1, !0)
                    }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t
                        , n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    },
                        n.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                    const i = {};
                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                            n.uuid
                    }
                    if (i.uuid = this.uuid,
                        i.type = this.type,
                    "" !== this.name && (i.name = this.name),
                    !0 === this.castShadow && (i.castShadow = !0),
                    !0 === this.receiveShadow && (i.receiveShadow = !0),
                    !1 === this.visible && (i.visible = !1),
                    !1 === this.frustumCulled && (i.frustumCulled = !1),
                    0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                    "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                        i.layers = this.layers.mask,
                        i.matrix = this.matrix.toArray(),
                    !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                    this.isInstancedMesh && (i.type = "InstancedMesh",
                        i.count = this.count,
                        i.instanceMatrix = this.instanceMatrix.toJSON(),
                    null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                    this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const n = e.shapes;
                            if (Array.isArray(n))
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    r(t.shapes, i)
                                }
                            else
                                r(t.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                        i.bindMatrix = this.bindMatrix.toArray(),
                    void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                        i.skeleton = this.skeleton.uuid)),
                    void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let n = 0, i = this.material.length; n < i; n++)
                                e.push(r(t.materials, this.material[n]));
                            i.material = e
                        } else
                            i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let e = 0; e < this.children.length; e++)
                            i.children.push(this.children[e].toJSON(t).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const n = this.animations[e];
                            i.animations.push(r(t.animations, n))
                        }
                    }
                    if (e) {
                        const e = o(t.geometries)
                            , i = o(t.materials)
                            , r = o(t.textures)
                            , s = o(t.images)
                            , a = o(t.shapes)
                            , c = o(t.skeletons)
                            , l = o(t.animations);
                        e.length > 0 && (n.geometries = e),
                        i.length > 0 && (n.materials = i),
                        r.length > 0 && (n.textures = r),
                        s.length > 0 && (n.images = s),
                        a.length > 0 && (n.shapes = a),
                        c.length > 0 && (n.skeletons = c),
                        l.length > 0 && (n.animations = l)
                    }
                    return n.object = i,
                        n;
                    function o(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata,
                                e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e=!0) {
                    if (this.name = t.name,
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        this.rotation.order = t.rotation.order,
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                        this.layers.mask = t.layers.mask,
                        this.visible = t.visible,
                        this.castShadow = t.castShadow,
                        this.receiveShadow = t.receiveShadow,
                        this.frustumCulled = t.frustumCulled,
                        this.renderOrder = t.renderOrder,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                    !0 === e)
                        for (let n = 0; n < t.children.length; n++) {
                            const e = t.children[n];
                            this.add(e.clone())
                        }
                    return this
                }
            });
        const Si = new bn
            , Ei = new bn
            , Ti = new hn;
        class Ai {
            constructor(t=new bn(1,0,0), e=0) {
                this.normal = t,
                    this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                    this.constant = e,
                    this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n),
                    this.constant = i,
                    this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                    this.constant = -e.dot(this.normal),
                    this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = Si.subVectors(n, e).cross(Ei.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t),
                    this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                    this.constant = t.constant,
                    this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                    this.constant *= t,
                    this
            }
            negate() {
                return this.constant *= -1,
                    this.normal.negate(),
                    this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
                    e = new bn),
                    e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                    e = new bn);
                const n = t.delta(Si)
                    , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                    , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
                    t = new bn),
                    t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Ti.getNormalMatrix(t)
                    , i = this.coplanarPoint(Si).applyMatrix4(t)
                    , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                    this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                    this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        Ai.prototype.isPlane = !0;
        const Li = new bn
            , Ri = new bn
            , Ci = new bn
            , Pi = new bn
            , Oi = new bn
            , Ii = new bn
            , Ni = new bn
            , Di = new bn
            , Fi = new bn
            , ki = new bn;
        class Hi {
            constructor(t=new bn, e=new bn, n=new bn) {
                this.a = t,
                    this.b = e,
                    this.c = n
            }
            static getNormal(t, e, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
                    i = new bn),
                    i.subVectors(n, e),
                    Li.subVectors(t, e),
                    i.cross(Li);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                Li.subVectors(i, e),
                    Ri.subVectors(n, e),
                    Ci.subVectors(t, e);
                const o = Li.dot(Li)
                    , s = Li.dot(Ri)
                    , a = Li.dot(Ci)
                    , c = Ri.dot(Ri)
                    , l = Ri.dot(Ci)
                    , u = o * c - s * s;
                if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                    r = new bn),
                0 === u)
                    return r.set(-2, -1, -1);
                const h = 1 / u
                    , d = (c * a - s * l) * h
                    , p = (o * l - s * a) * h;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, Pi),
                Pi.x >= 0 && Pi.y >= 0 && Pi.x + Pi.y <= 1
            }
            static getUV(t, e, n, i, r, o, s, a) {
                return this.getBarycoord(t, e, n, i, Pi),
                    a.set(0, 0),
                    a.addScaledVector(r, Pi.x),
                    a.addScaledVector(o, Pi.y),
                    a.addScaledVector(s, Pi.z),
                    a
            }
            static isFrontFacing(t, e, n, i) {
                return Li.subVectors(n, e),
                    Ri.subVectors(t, e),
                Li.cross(Ri).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                    this.b.copy(e),
                    this.c.copy(n),
                    this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]),
                    this.b.copy(t[n]),
                    this.c.copy(t[i]),
                    this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                    this.b.copy(t.b),
                    this.c.copy(t.c),
                    this
            }
            getArea() {
                return Li.subVectors(this.c, this.b),
                    Ri.subVectors(this.a, this.b),
                .5 * Li.cross(Ri).length()
            }
            getMidpoint(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
                    t = new bn),
                    t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return Hi.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
                    t = new Ai),
                    t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return Hi.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return Hi.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return Hi.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return Hi.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
                    e = new bn);
                const n = this.a
                    , i = this.b
                    , r = this.c;
                let o, s;
                Oi.subVectors(i, n),
                    Ii.subVectors(r, n),
                    Di.subVectors(t, n);
                const a = Oi.dot(Di)
                    , c = Ii.dot(Di);
                if (a <= 0 && c <= 0)
                    return e.copy(n);
                Fi.subVectors(t, i);
                const l = Oi.dot(Fi)
                    , u = Ii.dot(Fi);
                if (l >= 0 && u <= l)
                    return e.copy(i);
                const h = a * u - l * c;
                if (h <= 0 && a >= 0 && l <= 0)
                    return o = a / (a - l),
                        e.copy(n).addScaledVector(Oi, o);
                ki.subVectors(t, r);
                const d = Oi.dot(ki)
                    , p = Ii.dot(ki);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * c - a * p;
                if (f <= 0 && c >= 0 && p <= 0)
                    return s = c / (c - p),
                        e.copy(n).addScaledVector(Ii, s);
                const m = l * p - d * u;
                if (m <= 0 && u - l >= 0 && d - p >= 0)
                    return Ni.subVectors(r, i),
                        s = (u - l) / (u - l + (d - p)),
                        e.copy(i).addScaledVector(Ni, s);
                const g = 1 / (m + f + h);
                return o = f * g,
                    s = h * g,
                    e.copy(n).addScaledVector(Oi, o).addScaledVector(Ii, s)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let Bi = 0;
        function zi() {
            Object.defineProperty(this, "id", {
                value: Bi++
            }),
                this.uuid = ln.generateUUID(),
                this.name = "",
                this.type = "Material",
                this.fog = !0,
                this.blending = v,
                this.side = d,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.blendSrc = P,
                this.blendDst = O,
                this.blendEquation = w,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = U,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = en,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = tn,
                this.stencilZFail = tn,
                this.stencilZPass = tn,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaTest = 0,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0
        }
        zi.prototype = Object.assign(Object.create(sn.prototype), {
            constructor: zi,
            isMaterial: !0,
            onBeforeCompile: function() {},
            customProgramCacheKey: function() {
                return this.onBeforeCompile.toString()
            },
            setValues: function(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                                this.flatShading = n === m;
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            },
            toJSON: function(t) {
                const e = void 0 === t || "string" === typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                            e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                    n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                    n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                    n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                    n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                    n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                    n.normalMapType = this.normalMapType,
                    n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                    n.displacementScale = this.displacementScale,
                    n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                    n.reflectivity = this.reflectivity,
                    n.refractionRatio = this.refractionRatio,
                void 0 !== this.combine && (n.combine = this.combine),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== v && (n.blending = this.blending),
                this.side !== d && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = this.transparent),
                    n.depthFunc = this.depthFunc,
                    n.depthTest = this.depthTest,
                    n.depthWrite = this.depthWrite,
                    n.colorWrite = this.colorWrite,
                    n.stencilWrite = this.stencilWrite,
                    n.stencilWriteMask = this.stencilWriteMask,
                    n.stencilFunc = this.stencilFunc,
                    n.stencilRef = this.stencilRef,
                    n.stencilFuncMask = this.stencilFuncMask,
                    n.stencilFail = this.stencilFail,
                    n.stencilZFail = this.stencilZFail,
                    n.stencilZPass = this.stencilZPass,
                this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.morphTargets && (n.morphTargets = !0),
                !0 === this.morphNormals && (n.morphNormals = !0),
                !0 === this.skinning && (n.skinning = !0),
                !0 === this.flatShading && (n.flatShading = this.flatShading),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                    e) {
                    const e = i(t.textures)
                        , r = i(t.images);
                    e.length > 0 && (n.textures = e),
                    r.length > 0 && (n.images = r)
                }
                return n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name,
                    this.fog = t.fog,
                    this.blending = t.blending,
                    this.side = t.side,
                    this.vertexColors = t.vertexColors,
                    this.opacity = t.opacity,
                    this.transparent = t.transparent,
                    this.blendSrc = t.blendSrc,
                    this.blendDst = t.blendDst,
                    this.blendEquation = t.blendEquation,
                    this.blendSrcAlpha = t.blendSrcAlpha,
                    this.blendDstAlpha = t.blendDstAlpha,
                    this.blendEquationAlpha = t.blendEquationAlpha,
                    this.depthFunc = t.depthFunc,
                    this.depthTest = t.depthTest,
                    this.depthWrite = t.depthWrite,
                    this.stencilWriteMask = t.stencilWriteMask,
                    this.stencilFunc = t.stencilFunc,
                    this.stencilRef = t.stencilRef,
                    this.stencilFuncMask = t.stencilFuncMask,
                    this.stencilFail = t.stencilFail,
                    this.stencilZFail = t.stencilZFail,
                    this.stencilZPass = t.stencilZPass,
                    this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e[i].clone()
                }
                return this.clippingPlanes = n,
                    this.clipIntersection = t.clipIntersection,
                    this.clipShadows = t.clipShadows,
                    this.shadowSide = t.shadowSide,
                    this.colorWrite = t.colorWrite,
                    this.precision = t.precision,
                    this.polygonOffset = t.polygonOffset,
                    this.polygonOffsetFactor = t.polygonOffsetFactor,
                    this.polygonOffsetUnits = t.polygonOffsetUnits,
                    this.dithering = t.dithering,
                    this.alphaTest = t.alphaTest,
                    this.alphaToCoverage = t.alphaToCoverage,
                    this.premultipliedAlpha = t.premultipliedAlpha,
                    this.visible = t.visible,
                    this.toneMapped = t.toneMapped,
                    this.userData = JSON.parse(JSON.stringify(t.userData)),
                    this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }),
            Object.defineProperty(zi.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            });
        const Ui = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
            , ji = {
            h: 0,
            s: 0,
            l: 0
        }
            , Gi = {
            h: 0,
            s: 0,
            l: 0
        };
        function Vi(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
                n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        function Wi(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function qi(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class Xi {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t),
                    this
            }
            setScalar(t) {
                return this.r = t,
                    this.g = t,
                    this.b = t,
                    this
            }
            setHex(t) {
                return t = Math.floor(t),
                    this.r = (t >> 16 & 255) / 255,
                    this.g = (t >> 8 & 255) / 255,
                    this.b = (255 & t) / 255,
                    this
            }
            setRGB(t, e, n) {
                return this.r = t,
                    this.g = e,
                    this.b = n,
                    this
            }
            setHSL(t, e, n) {
                if (t = ln.euclideanModulo(t, 1),
                    e = ln.clamp(e, 0, 1),
                    n = ln.clamp(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e
                        , r = 2 * n - i;
                    this.r = Vi(r, i, t + 1 / 3),
                        this.g = Vi(r, i, t),
                        this.b = Vi(r, i, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = n[1]
                        , r = n[2];
                    switch (i) {
                        case "rgb":
                        case "rgba":
                            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                                return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                                    this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                                    this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                                    e(t[4]),
                                    this;
                            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                                return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                                    this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                                    this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                                    e(t[4]),
                                    this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                const n = parseFloat(t[1]) / 360
                                    , i = parseInt(t[2], 10) / 100
                                    , r = parseInt(t[3], 10) / 100;
                                return e(t[4]),
                                    this.setHSL(n, i, r)
                            }
                            break
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = n[1]
                        , e = t.length;
                    if (3 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                            this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                            this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                            this;
                    if (6 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                            this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                            this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                            this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = Ui[t];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
                    this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                    this.g = t.g,
                    this.b = t.b,
                    this
            }
            copyGammaToLinear(t, e=2) {
                return this.r = Math.pow(t.r, e),
                    this.g = Math.pow(t.g, e),
                    this.b = Math.pow(t.b, e),
                    this
            }
            copyLinearToGamma(t, e=2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n),
                    this.g = Math.pow(t.g, n),
                    this.b = Math.pow(t.b, n),
                    this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t),
                    this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t),
                    this
            }
            copySRGBToLinear(t) {
                return this.r = Wi(t.r),
                    this.g = Wi(t.g),
                    this.b = Wi(t.b),
                    this
            }
            copyLinearToSRGB(t) {
                return this.r = qi(t.r),
                    this.g = qi(t.g),
                    this.b = qi(t.b),
                    this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                    this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                    this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
                    t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                const e = this.r
                    , n = this.g
                    , i = this.b
                    , r = Math.max(e, n, i)
                    , o = Math.min(e, n, i);
                let s, a;
                const c = (o + r) / 2;
                if (o === r)
                    s = 0,
                        a = 0;
                else {
                    const t = r - o;
                    switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o),
                        r) {
                        case e:
                            s = (n - i) / t + (n < i ? 6 : 0);
                            break;
                        case n:
                            s = (i - e) / t + 2;
                            break;
                        case i:
                            s = (e - n) / t + 4;
                            break
                    }
                    s /= 6
                }
                return t.h = s,
                    t.s = a,
                    t.l = c,
                    t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, n) {
                return this.getHSL(ji),
                    ji.h += t,
                    ji.s += e,
                    ji.l += n,
                    this.setHSL(ji.h, ji.s, ji.l),
                    this
            }
            add(t) {
                return this.r += t.r,
                    this.g += t.g,
                    this.b += t.b,
                    this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                    this.g = t.g + e.g,
                    this.b = t.b + e.b,
                    this
            }
            addScalar(t) {
                return this.r += t,
                    this.g += t,
                    this.b += t,
                    this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                    this.g = Math.max(0, this.g - t.g),
                    this.b = Math.max(0, this.b - t.b),
                    this
            }
            multiply(t) {
                return this.r *= t.r,
                    this.g *= t.g,
                    this.b *= t.b,
                    this
            }
            multiplyScalar(t) {
                return this.r *= t,
                    this.g *= t,
                    this.b *= t,
                    this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                    this.g += (t.g - this.g) * e,
                    this.b += (t.b - this.b) * e,
                    this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                    this.g = t.g + (e.g - t.g) * n,
                    this.b = t.b + (e.b - t.b) * n,
                    this
            }
            lerpHSL(t, e) {
                this.getHSL(ji),
                    t.getHSL(Gi);
                const n = ln.lerp(ji.h, Gi.h, e)
                    , i = ln.lerp(ji.s, Gi.s, e)
                    , r = ln.lerp(ji.l, Gi.l, e);
                return this.setHSL(n, i, r),
                    this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                    this.g = t[e + 1],
                    this.b = t[e + 2],
                    this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                    t[e + 1] = this.g,
                    t[e + 2] = this.b,
                    t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                    this.g = t.getY(e),
                    this.b = t.getZ(e),
                !0 === t.normalized && (this.r /= 255,
                    this.g /= 255,
                    this.b /= 255),
                    this
            }
            toJSON() {
                return this.getHex()
            }
        }
        Xi.NAMES = Ui,
            Xi.prototype.isColor = !0,
            Xi.prototype.r = 1,
            Xi.prototype.g = 1,
            Xi.prototype.b = 1;
        class Yi extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshBasicMaterial",
                    this.color = new Xi(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = q,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this
            }
        }
        Yi.prototype.isMeshBasicMaterial = !0;
        const Zi = new bn
            , Ji = new un;
        function Ki(t, e, n) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = !0 === n,
                this.usage = nn,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
        }
        function Qi(t, e, n) {
            Ki.call(this, new Int8Array(t), e, n)
        }
        function $i(t, e, n) {
            Ki.call(this, new Uint8Array(t), e, n)
        }
        function tr(t, e, n) {
            Ki.call(this, new Uint8ClampedArray(t), e, n)
        }
        function er(t, e, n) {
            Ki.call(this, new Int16Array(t), e, n)
        }
        function nr(t, e, n) {
            Ki.call(this, new Uint16Array(t), e, n)
        }
        function ir(t, e, n) {
            Ki.call(this, new Int32Array(t), e, n)
        }
        function rr(t, e, n) {
            Ki.call(this, new Uint32Array(t), e, n)
        }
        function or(t, e, n) {
            Ki.call(this, new Uint16Array(t), e, n)
        }
        function sr(t, e, n) {
            Ki.call(this, new Float32Array(t), e, n)
        }
        function ar(t, e, n) {
            Ki.call(this, new Float64Array(t), e, n)
        }
        function cr(t) {
            if (0 === t.length)
                return -1 / 0;
            let e = t[0];
            for (let n = 1, i = t.length; n < i; ++n)
                t[n] > e && (e = t[n]);
            return e
        }
        Object.defineProperty(Ki.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }),
            Object.assign(Ki.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t,
                        this
                },
                copy: function(t) {
                    return this.name = t.name,
                        this.array = new t.array.constructor(t.array),
                        this.itemSize = t.itemSize,
                        this.count = t.count,
                        this.normalized = t.normalized,
                        this.usage = t.usage,
                        this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize,
                        n *= e.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++)
                        this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t),
                        this
                },
                copyColorsArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                            r = new Xi),
                            e[n++] = r.r,
                            e[n++] = r.g,
                            e[n++] = r.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                            r = new un),
                            e[n++] = r.x,
                            e[n++] = r.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                            r = new bn),
                            e[n++] = r.x,
                            e[n++] = r.y,
                            e[n++] = r.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                            r = new vn),
                            e[n++] = r.x,
                            e[n++] = r.y,
                            e[n++] = r.z,
                            e[n++] = r.w
                    }
                    return this
                },
                applyMatrix3: function(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++)
                            Ji.fromBufferAttribute(this, e),
                                Ji.applyMatrix3(t),
                                this.setXY(e, Ji.x, Ji.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++)
                            Zi.fromBufferAttribute(this, e),
                                Zi.applyMatrix3(t),
                                this.setXYZ(e, Zi.x, Zi.y, Zi.z);
                    return this
                },
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        Zi.x = this.getX(e),
                            Zi.y = this.getY(e),
                            Zi.z = this.getZ(e),
                            Zi.applyMatrix4(t),
                            this.setXYZ(e, Zi.x, Zi.y, Zi.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        Zi.x = this.getX(e),
                            Zi.y = this.getY(e),
                            Zi.z = this.getZ(e),
                            Zi.applyNormalMatrix(t),
                            this.setXYZ(e, Zi.x, Zi.y, Zi.z);
                    return this
                },
                transformDirection: function(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        Zi.x = this.getX(e),
                            Zi.y = this.getY(e),
                            Zi.z = this.getZ(e),
                            Zi.transformDirection(t),
                            this.setXYZ(e, Zi.x, Zi.y, Zi.z);
                    return this
                },
                set: function(t, e=0) {
                    return this.array.set(t, e),
                        this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e,
                        this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e,
                        this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e,
                        this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e,
                        this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this.array[t + 2] = i,
                        this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = n,
                        this.array[t + 2] = i,
                        this.array[t + 3] = r,
                        this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t,
                        this
                },
                clone: function() {
                    return new this.constructor(this.array,this.itemSize).copy(this)
                },
                toJSON: function() {
                    const t = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (t.name = this.name),
                    this.usage !== nn && (t.usage = this.usage),
                    0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
                        t
                }
            }),
            Qi.prototype = Object.create(Ki.prototype),
            Qi.prototype.constructor = Qi,
            $i.prototype = Object.create(Ki.prototype),
            $i.prototype.constructor = $i,
            tr.prototype = Object.create(Ki.prototype),
            tr.prototype.constructor = tr,
            er.prototype = Object.create(Ki.prototype),
            er.prototype.constructor = er,
            nr.prototype = Object.create(Ki.prototype),
            nr.prototype.constructor = nr,
            ir.prototype = Object.create(Ki.prototype),
            ir.prototype.constructor = ir,
            rr.prototype = Object.create(Ki.prototype),
            rr.prototype.constructor = rr,
            or.prototype = Object.create(Ki.prototype),
            or.prototype.constructor = or,
            or.prototype.isFloat16BufferAttribute = !0,
            sr.prototype = Object.create(Ki.prototype),
            sr.prototype.constructor = sr,
            ar.prototype = Object.create(Ki.prototype),
            ar.prototype.constructor = ar;
        Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array;
        let lr = 0;
        const ur = new Qn
            , hr = new Mi
            , dr = new bn
            , pr = new Sn
            , fr = new Sn
            , mr = new bn;
        function gr() {
            Object.defineProperty(this, "id", {
                value: lr++
            }),
                this.uuid = ln.generateUUID(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
        }
        gr.prototype = Object.assign(Object.create(sn.prototype), {
            constructor: gr,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                return Array.isArray(t) ? this.index = new (cr(t) > 65535 ? rr : nr)(t,1) : this.index = t,
                    this
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            setAttribute: function(t, e) {
                return this.attributes[t] = e,
                    this
            },
            deleteAttribute: function(t) {
                return delete this.attributes[t],
                    this
            },
            hasAttribute: function(t) {
                return void 0 !== this.attributes[t]
            },
            addGroup: function(t, e, n=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t,
                    this.drawRange.count = e
            },
            applyMatrix4: function(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                    e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new hn).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                        n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t),
                    i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                    this
            },
            rotateX: function(t) {
                return ur.makeRotationX(t),
                    this.applyMatrix4(ur),
                    this
            },
            rotateY: function(t) {
                return ur.makeRotationY(t),
                    this.applyMatrix4(ur),
                    this
            },
            rotateZ: function(t) {
                return ur.makeRotationZ(t),
                    this.applyMatrix4(ur),
                    this
            },
            translate: function(t, e, n) {
                return ur.makeTranslation(t, e, n),
                    this.applyMatrix4(ur),
                    this
            },
            scale: function(t, e, n) {
                return ur.makeScale(t, e, n),
                    this.applyMatrix4(ur),
                    this
            },
            lookAt: function(t) {
                return hr.lookAt(t),
                    hr.updateMatrix(),
                    this.applyMatrix4(hr.matrix),
                    this
            },
            center: function() {
                return this.computeBoundingBox(),
                    this.boundingBox.getCenter(dr).negate(),
                    this.translate(dr.x, dr.y, dr.z),
                    this
            },
            setFromPoints: function(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new sr(e,3)),
                    this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new Sn);
                const t = this.attributes.position
                    , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                        void this.boundingBox.set(new bn(-1 / 0,-1 / 0,-1 / 0), new bn(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                        e)
                        for (let n = 0, i = e.length; n < i; n++) {
                            const t = e[n];
                            pr.setFromBufferAttribute(t),
                                this.morphTargetsRelative ? (mr.addVectors(this.boundingBox.min, pr.min),
                                    this.boundingBox.expandByPoint(mr),
                                    mr.addVectors(this.boundingBox.max, pr.max),
                                    this.boundingBox.expandByPoint(mr)) : (this.boundingBox.expandByPoint(pr.min),
                                    this.boundingBox.expandByPoint(pr.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Gn);
                const t = this.attributes.position
                    , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                        void this.boundingSphere.set(new bn, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (pr.setFromBufferAttribute(t),
                        e)
                        for (let t = 0, r = e.length; t < r; t++) {
                            const n = e[t];
                            fr.setFromBufferAttribute(n),
                                this.morphTargetsRelative ? (mr.addVectors(pr.min, fr.min),
                                    pr.expandByPoint(mr),
                                    mr.addVectors(pr.max, fr.max),
                                    pr.expandByPoint(mr)) : (pr.expandByPoint(fr.min),
                                    pr.expandByPoint(fr.max))
                        }
                    pr.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        mr.fromBufferAttribute(t, e),
                            i = Math.max(i, n.distanceToSquared(mr));
                    if (e)
                        for (let r = 0, o = e.length; r < o; r++) {
                            const o = e[r]
                                , s = this.morphTargetsRelative;
                            for (let e = 0, r = o.count; e < r; e++)
                                mr.fromBufferAttribute(o, e),
                                s && (dr.fromBufferAttribute(t, e),
                                    mr.add(dr)),
                                    i = Math.max(i, n.distanceToSquared(mr))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function() {},
            computeTangents: function() {
                const t = this.index
                    , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array
                    , i = e.position.array
                    , r = e.normal.array
                    , o = e.uv.array
                    , s = i.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new Ki(new Float32Array(4 * s),4));
                const a = e.tangent.array
                    , c = []
                    , l = [];
                for (let E = 0; E < s; E++)
                    c[E] = new bn,
                        l[E] = new bn;
                const u = new bn
                    , h = new bn
                    , d = new bn
                    , p = new un
                    , f = new un
                    , m = new un
                    , g = new bn
                    , v = new bn;
                function y(t, e, n) {
                    u.fromArray(i, 3 * t),
                        h.fromArray(i, 3 * e),
                        d.fromArray(i, 3 * n),
                        p.fromArray(o, 2 * t),
                        f.fromArray(o, 2 * e),
                        m.fromArray(o, 2 * n),
                        h.sub(u),
                        d.sub(u),
                        f.sub(p),
                        m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                        v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r),
                        c[t].add(g),
                        c[e].add(g),
                        c[n].add(g),
                        l[t].add(v),
                        l[e].add(v),
                        l[n].add(v))
                }
                let _ = this.groups;
                0 === _.length && (_ = [{
                    start: 0,
                    count: n.length
                }]);
                for (let E = 0, T = _.length; E < T; ++E) {
                    const t = _[E]
                        , e = t.start
                        , i = t.count;
                    for (let r = e, o = e + i; r < o; r += 3)
                        y(n[r + 0], n[r + 1], n[r + 2])
                }
                const x = new bn
                    , b = new bn
                    , w = new bn
                    , M = new bn;
                function S(t) {
                    w.fromArray(r, 3 * t),
                        M.copy(w);
                    const e = c[t];
                    x.copy(e),
                        x.sub(w.multiplyScalar(w.dot(e))).normalize(),
                        b.crossVectors(M, e);
                    const n = b.dot(l[t])
                        , i = n < 0 ? -1 : 1;
                    a[4 * t] = x.x,
                        a[4 * t + 1] = x.y,
                        a[4 * t + 2] = x.z,
                        a[4 * t + 3] = i
                }
                for (let E = 0, T = _.length; E < T; ++E) {
                    const t = _[E]
                        , e = t.start
                        , i = t.count;
                    for (let r = e, o = e + i; r < o; r += 3)
                        S(n[r + 0]),
                            S(n[r + 1]),
                            S(n[r + 2])
                }
            },
            computeVertexNormals: function() {
                const t = this.index
                    , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Ki(new Float32Array(3 * e.count),3),
                            this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new bn
                        , r = new bn
                        , o = new bn
                        , s = new bn
                        , a = new bn
                        , c = new bn
                        , l = new bn
                        , u = new bn;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0)
                                , p = t.getX(h + 1)
                                , f = t.getX(h + 2);
                            i.fromBufferAttribute(e, d),
                                r.fromBufferAttribute(e, p),
                                o.fromBufferAttribute(e, f),
                                l.subVectors(o, r),
                                u.subVectors(i, r),
                                l.cross(u),
                                s.fromBufferAttribute(n, d),
                                a.fromBufferAttribute(n, p),
                                c.fromBufferAttribute(n, f),
                                s.add(l),
                                a.add(l),
                                c.add(l),
                                n.setXYZ(d, s.x, s.y, s.z),
                                n.setXYZ(p, a.x, a.y, a.z),
                                n.setXYZ(f, c.x, c.y, c.z)
                        }
                    else
                        for (let t = 0, h = e.count; t < h; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                                r.fromBufferAttribute(e, t + 1),
                                o.fromBufferAttribute(e, t + 2),
                                l.subVectors(o, r),
                                u.subVectors(i, r),
                                l.cross(u),
                                n.setXYZ(t + 0, l.x, l.y, l.z),
                                n.setXYZ(t + 1, l.x, l.y, l.z),
                                n.setXYZ(t + 2, l.x, l.y, l.z);
                    this.normalizeNormals(),
                        n.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (!t || !t.isBufferGeometry)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0,
                    console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === t.attributes[i])
                        continue;
                    const r = n[i]
                        , o = r.array
                        , s = t.attributes[i]
                        , a = s.array
                        , c = s.itemSize * e
                        , l = Math.min(a.length, o.length - c);
                    for (let t = 0, e = c; t < l; t++,
                        e++)
                        o[e] = a[t]
                }
                return this
            },
            normalizeNormals: function() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    mr.fromBufferAttribute(t, e),
                        mr.normalize(),
                        t.setXYZ(e, mr.x, mr.y, mr.z)
            },
            toNonIndexed: function() {
                function t(t, e) {
                    const n = t.array
                        , i = t.itemSize
                        , r = t.normalized
                        , o = new n.constructor(e.length * i);
                    let s = 0
                        , a = 0;
                    for (let c = 0, l = e.length; c < l; c++) {
                        s = e[c] * i;
                        for (let t = 0; t < i; t++)
                            o[a++] = n[s++]
                    }
                    return new Ki(o,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                        this;
                const e = new gr
                    , n = this.index.array
                    , i = this.attributes;
                for (const s in i) {
                    const r = i[s]
                        , o = t(r, n);
                    e.setAttribute(s, o)
                }
                const r = this.morphAttributes;
                for (const s in r) {
                    const i = []
                        , o = r[s];
                    for (let e = 0, r = o.length; e < r; e++) {
                        const r = o[e]
                            , s = t(r, n);
                        i.push(s)
                    }
                    e.morphAttributes[s] = i
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let s = 0, a = o.length; s < a; s++) {
                    const t = o[s];
                    e.addGroup(t.start, t.count, t.materialIndex)
                }
                return e
            },
            toJSON: function() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                    t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const a in n) {
                    const e = n[a];
                    t.data.attributes[a] = e.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const a in this.morphAttributes) {
                    const e = this.morphAttributes[a]
                        , n = [];
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i];
                        n.push(r.toJSON(t.data))
                    }
                    n.length > 0 && (i[a] = n,
                        r = !0)
                }
                r && (t.data.morphAttributes = i,
                    t.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
                const s = this.boundingSphere;
                return null !== s && (t.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }),
                    t
            },
            clone: function() {
                return (new gr).copy(this)
            },
            copy: function(t) {
                this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const c in i) {
                    const t = i[c];
                    this.setAttribute(c, t.clone(e))
                }
                const r = t.morphAttributes;
                for (const c in r) {
                    const t = []
                        , n = r[c];
                    for (let i = 0, r = n.length; i < r; i++)
                        t.push(n[i].clone(e));
                    this.morphAttributes[c] = t
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const o = t.groups;
                for (let c = 0, l = o.length; c < l; c++) {
                    const t = o[c];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const s = t.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()),
                    this.drawRange.start = t.drawRange.start,
                    this.drawRange.count = t.drawRange.count,
                    this.userData = t.userData,
                    this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        const vr = new Qn
            , yr = new Kn
            , _r = new Gn
            , xr = new bn
            , br = new bn
            , wr = new bn
            , Mr = new bn
            , Sr = new bn
            , Er = new bn
            , Tr = new bn
            , Ar = new bn
            , Lr = new bn
            , Rr = new un
            , Cr = new un
            , Pr = new un
            , Or = new bn
            , Ir = new bn;
        function Nr(t=new gr, e=new Yi) {
            Mi.call(this),
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
        }
        function Dr(t, e, n, i, r, o, s, a) {
            let c;
            if (c = e.side === p ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, e.side !== f, a),
            null === c)
                return null;
            Ir.copy(a),
                Ir.applyMatrix4(t.matrixWorld);
            const l = n.ray.origin.distanceTo(Ir);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: Ir.clone(),
                object: t
            }
        }
        function Fr(t, e, n, i, r, o, s, a, c, l, u, h) {
            xr.fromBufferAttribute(r, l),
                br.fromBufferAttribute(r, u),
                wr.fromBufferAttribute(r, h);
            const d = t.morphTargetInfluences;
            if (e.morphTargets && o && d) {
                Tr.set(0, 0, 0),
                    Ar.set(0, 0, 0),
                    Lr.set(0, 0, 0);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = d[t]
                        , n = o[t];
                    0 !== e && (Mr.fromBufferAttribute(n, l),
                        Sr.fromBufferAttribute(n, u),
                        Er.fromBufferAttribute(n, h),
                        s ? (Tr.addScaledVector(Mr, e),
                            Ar.addScaledVector(Sr, e),
                            Lr.addScaledVector(Er, e)) : (Tr.addScaledVector(Mr.sub(xr), e),
                            Ar.addScaledVector(Sr.sub(br), e),
                            Lr.addScaledVector(Er.sub(wr), e)))
                }
                xr.add(Tr),
                    br.add(Ar),
                    wr.add(Lr)
            }
            t.isSkinnedMesh && e.skinning && (t.boneTransform(l, xr),
                t.boneTransform(u, br),
                t.boneTransform(h, wr));
            const p = Dr(t, e, n, i, xr, br, wr, Or);
            if (p) {
                a && (Rr.fromBufferAttribute(a, l),
                    Cr.fromBufferAttribute(a, u),
                    Pr.fromBufferAttribute(a, h),
                    p.uv = Hi.getUV(Or, xr, br, wr, Rr, Cr, Pr, new un)),
                c && (Rr.fromBufferAttribute(c, l),
                    Cr.fromBufferAttribute(c, u),
                    Pr.fromBufferAttribute(c, h),
                    p.uv2 = Hi.getUV(Or, xr, br, wr, Rr, Cr, Pr, new un));
                const t = {
                    a: l,
                    b: u,
                    c: h,
                    normal: new bn,
                    materialIndex: 0
                };
                Hi.getNormal(xr, br, wr, t.normal),
                    p.face = t
            }
            return p
        }
        Nr.prototype = Object.assign(Object.create(Mi.prototype), {
            constructor: Nr,
            isMesh: !0,
            copy: function(t) {
                return Mi.prototype.copy.call(this, t),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                    this.material = t.material,
                    this.geometry = t.geometry,
                    this
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                        , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function(t, e) {
                const n = this.geometry
                    , i = this.material
                    , r = this.matrixWorld;
                if (void 0 === i)
                    return;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                    _r.copy(n.boundingSphere),
                    _r.applyMatrix4(r),
                !1 === t.ray.intersectsSphere(_r))
                    return;
                if (vr.copy(r).invert(),
                    yr.copy(t.ray).applyMatrix4(vr),
                null !== n.boundingBox && !1 === yr.intersectsBox(n.boundingBox))
                    return;
                let o;
                if (n.isBufferGeometry) {
                    const r = n.index
                        , s = n.attributes.position
                        , a = n.morphAttributes.position
                        , c = n.morphTargetsRelative
                        , l = n.attributes.uv
                        , u = n.attributes.uv2
                        , h = n.groups
                        , d = n.drawRange;
                    if (null !== r)
                        if (Array.isArray(i))
                            for (let n = 0, p = h.length; n < p; n++) {
                                const p = h[n]
                                    , f = i[p.materialIndex]
                                    , m = Math.max(p.start, d.start)
                                    , g = Math.min(p.start + p.count, d.start + d.count);
                                for (let n = m, i = g; n < i; n += 3) {
                                    const i = r.getX(n)
                                        , h = r.getX(n + 1)
                                        , d = r.getX(n + 2);
                                    o = Fr(this, f, t, yr, s, a, c, l, u, i, h, d),
                                    o && (o.faceIndex = Math.floor(n / 3),
                                        o.face.materialIndex = p.materialIndex,
                                        e.push(o))
                                }
                            }
                        else {
                            const n = Math.max(0, d.start)
                                , h = Math.min(r.count, d.start + d.count);
                            for (let d = n, p = h; d < p; d += 3) {
                                const n = r.getX(d)
                                    , h = r.getX(d + 1)
                                    , p = r.getX(d + 2);
                                o = Fr(this, i, t, yr, s, a, c, l, u, n, h, p),
                                o && (o.faceIndex = Math.floor(d / 3),
                                    e.push(o))
                            }
                        }
                    else if (void 0 !== s)
                        if (Array.isArray(i))
                            for (let n = 0, p = h.length; n < p; n++) {
                                const r = h[n]
                                    , p = i[r.materialIndex]
                                    , f = Math.max(r.start, d.start)
                                    , m = Math.min(r.start + r.count, d.start + d.count);
                                for (let n = f, i = m; n < i; n += 3) {
                                    const i = n
                                        , h = n + 1
                                        , d = n + 2;
                                    o = Fr(this, p, t, yr, s, a, c, l, u, i, h, d),
                                    o && (o.faceIndex = Math.floor(n / 3),
                                        o.face.materialIndex = r.materialIndex,
                                        e.push(o))
                                }
                            }
                        else {
                            const n = Math.max(0, d.start)
                                , r = Math.min(s.count, d.start + d.count);
                            for (let h = n, d = r; h < d; h += 3) {
                                const n = h
                                    , r = h + 1
                                    , d = h + 2;
                                o = Fr(this, i, t, yr, s, a, c, l, u, n, r, d),
                                o && (o.faceIndex = Math.floor(h / 3),
                                    e.push(o))
                            }
                        }
                } else
                    n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        });
        class kr extends gr {
            constructor(t=1, e=1, n=1, i=1, r=1, o=1) {
                super(),
                    this.type = "BoxGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: o
                    };
                const s = this;
                i = Math.floor(i),
                    r = Math.floor(r),
                    o = Math.floor(o);
                const a = []
                    , c = []
                    , l = []
                    , u = [];
                let h = 0
                    , d = 0;
                function p(t, e, n, i, r, o, p, f, m, g, v) {
                    const y = o / m
                        , _ = p / g
                        , x = o / 2
                        , b = p / 2
                        , w = f / 2
                        , M = m + 1
                        , S = g + 1;
                    let E = 0
                        , T = 0;
                    const A = new bn;
                    for (let s = 0; s < S; s++) {
                        const o = s * _ - b;
                        for (let a = 0; a < M; a++) {
                            const h = a * y - x;
                            A[t] = h * i,
                                A[e] = o * r,
                                A[n] = w,
                                c.push(A.x, A.y, A.z),
                                A[t] = 0,
                                A[e] = 0,
                                A[n] = f > 0 ? 1 : -1,
                                l.push(A.x, A.y, A.z),
                                u.push(a / m),
                                u.push(1 - s / g),
                                E += 1
                        }
                    }
                    for (let s = 0; s < g; s++)
                        for (let t = 0; t < m; t++) {
                            const e = h + t + M * s
                                , n = h + t + M * (s + 1)
                                , i = h + (t + 1) + M * (s + 1)
                                , r = h + (t + 1) + M * s;
                            a.push(e, n, r),
                                a.push(n, i, r),
                                T += 6
                        }
                    s.addGroup(d, T, v),
                        d += T,
                        h += E
                }
                p("z", "y", "x", -1, -1, n, e, t, o, r, 0),
                    p("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
                    p("x", "z", "y", 1, 1, t, n, e, i, o, 2),
                    p("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
                    p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                    p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                    this.setIndex(a),
                    this.setAttribute("position", new sr(c,3)),
                    this.setAttribute("normal", new sr(l,3)),
                    this.setAttribute("uv", new sr(u,2))
            }
        }
        function Hr(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
        function Br(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = Hr(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        const zr = {
            clone: Hr,
            merge: Br
        };
        var Ur = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
            , jr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        function Gr(t) {
            zi.call(this),
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.vertexShader = Ur,
                this.fragmentShader = jr,
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
            void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                this.setValues(t))
        }
        function Vr() {
            Mi.call(this),
                this.type = "Camera",
                this.matrixWorldInverse = new Qn,
                this.projectionMatrix = new Qn,
                this.projectionMatrixInverse = new Qn
        }
        function Wr(t=50, e=1, n=.1, i=2e3) {
            Vr.call(this),
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
        }
        Gr.prototype = Object.create(zi.prototype),
            Gr.prototype.constructor = Gr,
            Gr.prototype.isShaderMaterial = !0,
            Gr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t),
                    this.fragmentShader = t.fragmentShader,
                    this.vertexShader = t.vertexShader,
                    this.uniforms = Hr(t.uniforms),
                    this.defines = Object.assign({}, t.defines),
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.lights = t.lights,
                    this.clipping = t.clipping,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.extensions = Object.assign({}, t.extensions),
                    this.glslVersion = t.glslVersion,
                    this
            }
            ,
            Gr.prototype.toJSON = function(t) {
                const e = zi.prototype.toJSON.call(this, t);
                e.glslVersion = this.glslVersion,
                    e.uniforms = {};
                for (const i in this.uniforms) {
                    const n = this.uniforms[i]
                        , r = n.value;
                    r && r.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[i] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[i] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                    e.vertexShader = this.vertexShader,
                    e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const i in this.extensions)
                    !0 === this.extensions[i] && (n[i] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                    e
            }
            ,
            Vr.prototype = Object.assign(Object.create(Mi.prototype), {
                constructor: Vr,
                isCamera: !0,
                copy: function(t, e) {
                    return Mi.prototype.copy.call(this, t, e),
                        this.matrixWorldInverse.copy(t.matrixWorldInverse),
                        this.projectionMatrix.copy(t.projectionMatrix),
                        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
                        t = new bn),
                        this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    Mi.prototype.updateMatrixWorld.call(this, t),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                updateWorldMatrix: function(t, e) {
                    Mi.prototype.updateWorldMatrix.call(this, t, e),
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }),
            Wr.prototype = Object.assign(Object.create(Vr.prototype), {
                constructor: Wr,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return Vr.prototype.copy.call(this, t, e),
                        this.fov = t.fov,
                        this.zoom = t.zoom,
                        this.near = t.near,
                        this.far = t.far,
                        this.focus = t.focus,
                        this.aspect = t.aspect,
                        this.view = null === t.view ? null : Object.assign({}, t.view),
                        this.filmGauge = t.filmGauge,
                        this.filmOffset = t.filmOffset,
                        this
                },
                setFocalLength: function(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * ln.RAD2DEG * Math.atan(e),
                        this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    const t = Math.tan(.5 * ln.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * ln.RAD2DEG * Math.atan(Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, o) {
                    this.aspect = t / e,
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }),
                        this.view.enabled = !0,
                        this.view.fullWidth = t,
                        this.view.fullHeight = e,
                        this.view.offsetX = n,
                        this.view.offsetY = i,
                        this.view.width = r,
                        this.view.height = o,
                        this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1),
                        this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom
                        , n = 2 * e
                        , i = this.aspect * n
                        , r = -.5 * i;
                    const o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = o.fullWidth
                            , s = o.fullHeight;
                        r += o.offsetX * i / t,
                            e -= o.offsetY * n / s,
                            i *= o.width / t,
                            n *= o.height / s
                    }
                    const s = this.filmOffset;
                    0 !== s && (r += t * s / this.getFilmWidth()),
                        this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                },
                toJSON: function(t) {
                    const e = Mi.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov,
                        e.object.zoom = this.zoom,
                        e.object.near = this.near,
                        e.object.far = this.far,
                        e.object.focus = this.focus,
                        e.object.aspect = this.aspect,
                    null !== this.view && (e.object.view = Object.assign({}, this.view)),
                        e.object.filmGauge = this.filmGauge,
                        e.object.filmOffset = this.filmOffset,
                        e
                }
            });
        const qr = 90
            , Xr = 1;
        class Yr extends Mi {
            constructor(t, e, n) {
                if (super(),
                    this.type = "CubeCamera",
                !0 !== n.isWebGLCubeRenderTarget)
                    return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new Wr(qr,Xr,t,e);
                i.layers = this.layers,
                    i.up.set(0, -1, 0),
                    i.lookAt(new bn(1,0,0)),
                    this.add(i);
                const r = new Wr(qr,Xr,t,e);
                r.layers = this.layers,
                    r.up.set(0, -1, 0),
                    r.lookAt(new bn(-1,0,0)),
                    this.add(r);
                const o = new Wr(qr,Xr,t,e);
                o.layers = this.layers,
                    o.up.set(0, 0, 1),
                    o.lookAt(new bn(0,1,0)),
                    this.add(o);
                const s = new Wr(qr,Xr,t,e);
                s.layers = this.layers,
                    s.up.set(0, 0, -1),
                    s.lookAt(new bn(0,-1,0)),
                    this.add(s);
                const a = new Wr(qr,Xr,t,e);
                a.layers = this.layers,
                    a.up.set(0, -1, 0),
                    a.lookAt(new bn(0,0,1)),
                    this.add(a);
                const c = new Wr(qr,Xr,t,e);
                c.layers = this.layers,
                    c.up.set(0, -1, 0),
                    c.lookAt(new bn(0,0,-1)),
                    this.add(c)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget
                    , [i,r,o,s,a,c] = this.children
                    , l = t.xr.enabled
                    , u = t.getRenderTarget();
                t.xr.enabled = !1;
                const h = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                    t.setRenderTarget(n, 0),
                    t.render(e, i),
                    t.setRenderTarget(n, 1),
                    t.render(e, r),
                    t.setRenderTarget(n, 2),
                    t.render(e, o),
                    t.setRenderTarget(n, 3),
                    t.render(e, s),
                    t.setRenderTarget(n, 4),
                    t.render(e, a),
                    n.texture.generateMipmaps = h,
                    t.setRenderTarget(n, 5),
                    t.render(e, c),
                    t.setRenderTarget(u),
                    t.xr.enabled = l
            }
        }
        class Zr extends mn {
            constructor(t, e, n, i, r, o, s, a, c, l) {
                t = void 0 !== t ? t : [],
                    e = void 0 !== e ? e : nt,
                    s = void 0 !== s ? s : Ct,
                    super(t, e, n, i, r, o, s, a, c, l),
                    this._needsFlipEnvMap = !0,
                    this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        Zr.prototype.isCubeTexture = !0;
        class Jr extends yn {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                    e = n),
                    super(t, t, e),
                    e = e || {},
                    this.texture = new Zr(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
                    this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                    this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : ft,
                    this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                    this.texture.format = Pt,
                    this.texture.encoding = e.encoding,
                    this.texture.generateMipmaps = e.generateMipmaps,
                    this.texture.minFilter = e.minFilter,
                    this.texture.magFilter = e.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                    , i = new kr(5,5,5)
                    , r = new Gr({
                    name: "CubemapFromEquirect",
                    uniforms: Hr(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: p,
                    blending: g
                });
                r.uniforms.tEquirect.value = e;
                const o = new Nr(i,r)
                    , s = e.minFilter;
                e.minFilter === gt && (e.minFilter = ft);
                const a = new Yr(1,10,this);
                return a.update(t, o),
                    e.minFilter = s,
                    o.geometry.dispose(),
                    o.material.dispose(),
                    this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let o = 0; o < 6; o++)
                    t.setRenderTarget(this, o),
                        t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        Jr.prototype.isWebGLCubeRenderTarget = !0;
        class Kr extends mn {
            constructor(t, e, n, i, r, o, s, a, c, l, u, h) {
                super(null, o, s, a, c, l, i, r, u, h),
                    this.image = {
                        data: t || null,
                        width: e || 1,
                        height: n || 1
                    },
                    this.magFilter = void 0 !== c ? c : ht,
                    this.minFilter = void 0 !== l ? l : ht,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1,
                    this.needsUpdate = !0
            }
        }
        Kr.prototype.isDataTexture = !0;
        const Qr = new Gn
            , $r = new bn;
        class to {
            constructor(t=new Ai, e=new Ai, n=new Ai, i=new Ai, r=new Ai, o=new Ai) {
                this.planes = [t, e, n, i, r, o]
            }
            set(t, e, n, i, r, o) {
                const s = this.planes;
                return s[0].copy(t),
                    s[1].copy(e),
                    s[2].copy(n),
                    s[3].copy(i),
                    s[4].copy(r),
                    s[5].copy(o),
                    this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes
                    , n = t.elements
                    , i = n[0]
                    , r = n[1]
                    , o = n[2]
                    , s = n[3]
                    , a = n[4]
                    , c = n[5]
                    , l = n[6]
                    , u = n[7]
                    , h = n[8]
                    , d = n[9]
                    , p = n[10]
                    , f = n[11]
                    , m = n[12]
                    , g = n[13]
                    , v = n[14]
                    , y = n[15];
                return e[0].setComponents(s - i, u - a, f - h, y - m).normalize(),
                    e[1].setComponents(s + i, u + a, f + h, y + m).normalize(),
                    e[2].setComponents(s + r, u + c, f + d, y + g).normalize(),
                    e[3].setComponents(s - r, u - c, f - d, y - g).normalize(),
                    e[4].setComponents(s - o, u - l, f - p, y - v).normalize(),
                    e[5].setComponents(s + o, u + l, f + p, y + v).normalize(),
                    this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(),
                    Qr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                    this.intersectsSphere(Qr)
            }
            intersectsSprite(t) {
                return Qr.center.set(0, 0, 0),
                    Qr.radius = .7071067811865476,
                    Qr.applyMatrix4(t.matrixWorld),
                    this.intersectsSphere(Qr)
            }
            intersectsSphere(t) {
                const e = this.planes
                    , n = t.center
                    , i = -t.radius;
                for (let r = 0; r < 6; r++) {
                    const t = e[r].distanceToPoint(n);
                    if (t < i)
                        return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if ($r.x = i.normal.x > 0 ? t.max.x : t.min.x,
                        $r.y = i.normal.y > 0 ? t.max.y : t.min.y,
                        $r.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint($r) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function eo() {
            let t = null
                , e = !1
                , n = null
                , i = null;
            function r(e, o) {
                n(e, o),
                    i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                        e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i),
                        e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function no(t, e) {
            const n = e.isWebGL2
                , i = new WeakMap;
            function r(e, i) {
                const r = e.array
                    , o = e.usage
                    , s = t.createBuffer();
                t.bindBuffer(i, s),
                    t.bufferData(i, r, o),
                    e.onUploadCallback();
                let a = 5126;
                return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121),
                    {
                        buffer: s,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
            }
            function o(e, i, r) {
                const o = i.array
                    , s = i.updateRange;
                t.bindBuffer(r, e),
                    -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)),
                        s.count = -1)
            }
            function s(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                    i.get(t)
            }
            function a(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const n = i.get(e);
                n && (t.deleteBuffer(n.buffer),
                    i.delete(e))
            }
            function c(t, e) {
                if (t.isGLBufferAttribute) {
                    const e = i.get(t);
                    return void ((!e || e.version < t.version) && i.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }))
                }
                t.isInterleavedBufferAttribute && (t = t.data);
                const n = i.get(t);
                void 0 === n ? i.set(t, r(t, e)) : n.version < t.version && (o(n.buffer, t, e),
                    n.version = t.version)
            }
            return {
                get: s,
                remove: a,
                update: c
            }
        }
        class io extends gr {
            constructor(t=1, e=1, n=1, i=1) {
                super(),
                    this.type = "PlaneGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: i
                    };
                const r = t / 2
                    , o = e / 2
                    , s = Math.floor(n)
                    , a = Math.floor(i)
                    , c = s + 1
                    , l = a + 1
                    , u = t / s
                    , h = e / a
                    , d = []
                    , p = []
                    , f = []
                    , m = [];
                for (let g = 0; g < l; g++) {
                    const t = g * h - o;
                    for (let e = 0; e < c; e++) {
                        const n = e * u - r;
                        p.push(n, -t, 0),
                            f.push(0, 0, 1),
                            m.push(e / s),
                            m.push(1 - g / a)
                    }
                }
                for (let g = 0; g < a; g++)
                    for (let t = 0; t < s; t++) {
                        const e = t + c * g
                            , n = t + c * (g + 1)
                            , i = t + 1 + c * (g + 1)
                            , r = t + 1 + c * g;
                        d.push(e, n, r),
                            d.push(n, i, r)
                    }
                this.setIndex(d),
                    this.setAttribute("position", new sr(p,3)),
                    this.setAttribute("normal", new sr(f,3)),
                    this.setAttribute("uv", new sr(m,2))
            }
        }
        var ro = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif"
            , oo = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
            , so = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif"
            , ao = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif"
            , co = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"
            , lo = "vec3 transformed = vec3( position );"
            , uo = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif"
            , ho = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif"
            , po = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif"
            , fo = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif"
            , mo = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif"
            , go = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif"
            , vo = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif"
            , yo = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif"
            , _o = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif"
            , xo = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif"
            , bo = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif"
            , wo = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}"
            , Mo = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif"
            , So = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif"
            , Eo = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif"
            , To = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif"
            , Ao = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif"
            , Lo = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif"
            , Ro = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
            , Co = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}"
            , Po = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif"
            , Oo = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif"
            , Io = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif"
            , No = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif"
            , Do = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif"
            , Fo = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif"
            , ko = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif"
            , Ho = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif"
            , Bo = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"
            , zo = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}"
            , Uo = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif"
            , jo = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
            , Go = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif"
            , Vo = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif"
            , Wo = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif"
            , qo = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;"
            , Xo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)"
            , Yo = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;"
            , Zo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)"
            , Jo = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif"
            , Ko = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}"
            , Qo = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif"
            , $o = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif"
            , ts = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif"
            , es = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif"
            , ns = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif"
            , is = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif"
            , rs = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif"
            , os = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif"
            , ss = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif"
            , as = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif"
            , cs = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
            , ls = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif"
            , us = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"
            , hs = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif"
            , ds = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif"
            , ps = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif"
            , fs = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;"
            , ms = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif"
            , gs = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif"
            , vs = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif"
            , ys = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif"
            , _s = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif"
            , xs = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}"
            , bs = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif"
            , ws = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;"
            , Ms = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif"
            , Ss = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif"
            , Es = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif"
            , Ts = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
            , As = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif"
            , Ls = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif"
            , Rs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif"
            , Cs = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}"
            , Ps = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
            , Os = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif"
            , Is = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif"
            , Ns = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif"
            , Ds = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"
            , Fs = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"
            , ks = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif"
            , Hs = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }"
            , Bs = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif"
            , zs = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif"
            , Us = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif"
            , js = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif"
            , Gs = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif"
            , Vs = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif"
            , Ws = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif"
            , qs = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif"
            , Xs = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif"
            , Ys = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
            , Zs = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}"
            , Js = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
            , Ks = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}"
            , Qs = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}"
            , $s = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}"
            , ta = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}"
            , ea = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}"
            , na = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
            , ia = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}"
            , ra = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
            , oa = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            , sa = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , aa = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}"
            , ca = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , la = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
            , ua = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , ha = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}"
            , da = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , pa = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
            , fa = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , ma = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
            , ga = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
            , va = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
            , ya = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}"
            , _a = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}"
            , xa = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
            , ba = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}"
            , wa = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
            , Ma = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
            , Sa = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
            , Ea = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
        const Ta = {
            alphamap_fragment: ro,
            alphamap_pars_fragment: oo,
            alphatest_fragment: so,
            aomap_fragment: ao,
            aomap_pars_fragment: co,
            begin_vertex: lo,
            beginnormal_vertex: uo,
            bsdfs: ho,
            bumpmap_pars_fragment: po,
            clipping_planes_fragment: fo,
            clipping_planes_pars_fragment: mo,
            clipping_planes_pars_vertex: go,
            clipping_planes_vertex: vo,
            color_fragment: yo,
            color_pars_fragment: _o,
            color_pars_vertex: xo,
            color_vertex: bo,
            common: wo,
            cube_uv_reflection_fragment: Mo,
            defaultnormal_vertex: So,
            displacementmap_pars_vertex: Eo,
            displacementmap_vertex: To,
            emissivemap_fragment: Ao,
            emissivemap_pars_fragment: Lo,
            encodings_fragment: Ro,
            encodings_pars_fragment: Co,
            envmap_fragment: Po,
            envmap_common_pars_fragment: Oo,
            envmap_pars_fragment: Io,
            envmap_pars_vertex: No,
            envmap_physical_pars_fragment: Wo,
            envmap_vertex: Do,
            fog_vertex: Fo,
            fog_pars_vertex: ko,
            fog_fragment: Ho,
            fog_pars_fragment: Bo,
            gradientmap_pars_fragment: zo,
            lightmap_fragment: Uo,
            lightmap_pars_fragment: jo,
            lights_lambert_vertex: Go,
            lights_pars_begin: Vo,
            lights_toon_fragment: qo,
            lights_toon_pars_fragment: Xo,
            lights_phong_fragment: Yo,
            lights_phong_pars_fragment: Zo,
            lights_physical_fragment: Jo,
            lights_physical_pars_fragment: Ko,
            lights_fragment_begin: Qo,
            lights_fragment_maps: $o,
            lights_fragment_end: ts,
            logdepthbuf_fragment: es,
            logdepthbuf_pars_fragment: ns,
            logdepthbuf_pars_vertex: is,
            logdepthbuf_vertex: rs,
            map_fragment: os,
            map_pars_fragment: ss,
            map_particle_fragment: as,
            map_particle_pars_fragment: cs,
            metalnessmap_fragment: ls,
            metalnessmap_pars_fragment: us,
            morphnormal_vertex: hs,
            morphtarget_pars_vertex: ds,
            morphtarget_vertex: ps,
            normal_fragment_begin: fs,
            normal_fragment_maps: ms,
            normalmap_pars_fragment: gs,
            clearcoat_normal_fragment_begin: vs,
            clearcoat_normal_fragment_maps: ys,
            clearcoat_pars_fragment: _s,
            packing: xs,
            premultiplied_alpha_fragment: bs,
            project_vertex: ws,
            dithering_fragment: Ms,
            dithering_pars_fragment: Ss,
            roughnessmap_fragment: Es,
            roughnessmap_pars_fragment: Ts,
            shadowmap_pars_fragment: As,
            shadowmap_pars_vertex: Ls,
            shadowmap_vertex: Rs,
            shadowmask_pars_fragment: Cs,
            skinbase_vertex: Ps,
            skinning_pars_vertex: Os,
            skinning_vertex: Is,
            skinnormal_vertex: Ns,
            specularmap_fragment: Ds,
            specularmap_pars_fragment: Fs,
            tonemapping_fragment: ks,
            tonemapping_pars_fragment: Hs,
            transmissionmap_fragment: Bs,
            transmissionmap_pars_fragment: zs,
            uv_pars_fragment: Us,
            uv_pars_vertex: js,
            uv_vertex: Gs,
            uv2_pars_fragment: Vs,
            uv2_pars_vertex: Ws,
            uv2_vertex: qs,
            worldpos_vertex: Xs,
            background_frag: Ys,
            background_vert: Zs,
            cube_frag: Js,
            cube_vert: Ks,
            depth_frag: Qs,
            depth_vert: $s,
            distanceRGBA_frag: ta,
            distanceRGBA_vert: ea,
            equirect_frag: na,
            equirect_vert: ia,
            linedashed_frag: ra,
            linedashed_vert: oa,
            meshbasic_frag: sa,
            meshbasic_vert: aa,
            meshlambert_frag: ca,
            meshlambert_vert: la,
            meshmatcap_frag: ua,
            meshmatcap_vert: ha,
            meshtoon_frag: da,
            meshtoon_vert: pa,
            meshphong_frag: fa,
            meshphong_vert: ma,
            meshphysical_frag: ga,
            meshphysical_vert: va,
            normal_frag: ya,
            normal_vert: _a,
            points_frag: xa,
            points_vert: ba,
            shadow_frag: wa,
            shadow_vert: Ma,
            sprite_frag: Sa,
            sprite_vert: Ea
        }
            , Aa = {
            common: {
                diffuse: {
                    value: new Xi(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new hn
                },
                uv2Transform: {
                    value: new hn
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new un(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Xi(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Xi(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new hn
                }
            },
            sprite: {
                diffuse: {
                    value: new Xi(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new un(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new hn
                }
            }
        }
            , La = {
            basic: {
                uniforms: Br([Aa.common, Aa.specularmap, Aa.envmap, Aa.aomap, Aa.lightmap, Aa.fog]),
                vertexShader: Ta.meshbasic_vert,
                fragmentShader: Ta.meshbasic_frag
            },
            lambert: {
                uniforms: Br([Aa.common, Aa.specularmap, Aa.envmap, Aa.aomap, Aa.lightmap, Aa.emissivemap, Aa.fog, Aa.lights, {
                    emissive: {
                        value: new Xi(0)
                    }
                }]),
                vertexShader: Ta.meshlambert_vert,
                fragmentShader: Ta.meshlambert_frag
            },
            phong: {
                uniforms: Br([Aa.common, Aa.specularmap, Aa.envmap, Aa.aomap, Aa.lightmap, Aa.emissivemap, Aa.bumpmap, Aa.normalmap, Aa.displacementmap, Aa.fog, Aa.lights, {
                    emissive: {
                        value: new Xi(0)
                    },
                    specular: {
                        value: new Xi(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ta.meshphong_vert,
                fragmentShader: Ta.meshphong_frag
            },
            standard: {
                uniforms: Br([Aa.common, Aa.envmap, Aa.aomap, Aa.lightmap, Aa.emissivemap, Aa.bumpmap, Aa.normalmap, Aa.displacementmap, Aa.roughnessmap, Aa.metalnessmap, Aa.fog, Aa.lights, {
                    emissive: {
                        value: new Xi(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ta.meshphysical_vert,
                fragmentShader: Ta.meshphysical_frag
            },
            toon: {
                uniforms: Br([Aa.common, Aa.aomap, Aa.lightmap, Aa.emissivemap, Aa.bumpmap, Aa.normalmap, Aa.displacementmap, Aa.gradientmap, Aa.fog, Aa.lights, {
                    emissive: {
                        value: new Xi(0)
                    }
                }]),
                vertexShader: Ta.meshtoon_vert,
                fragmentShader: Ta.meshtoon_frag
            },
            matcap: {
                uniforms: Br([Aa.common, Aa.bumpmap, Aa.normalmap, Aa.displacementmap, Aa.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Ta.meshmatcap_vert,
                fragmentShader: Ta.meshmatcap_frag
            },
            points: {
                uniforms: Br([Aa.points, Aa.fog]),
                vertexShader: Ta.points_vert,
                fragmentShader: Ta.points_frag
            },
            dashed: {
                uniforms: Br([Aa.common, Aa.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ta.linedashed_vert,
                fragmentShader: Ta.linedashed_frag
            },
            depth: {
                uniforms: Br([Aa.common, Aa.displacementmap]),
                vertexShader: Ta.depth_vert,
                fragmentShader: Ta.depth_frag
            },
            normal: {
                uniforms: Br([Aa.common, Aa.bumpmap, Aa.normalmap, Aa.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ta.normal_vert,
                fragmentShader: Ta.normal_frag
            },
            sprite: {
                uniforms: Br([Aa.sprite, Aa.fog]),
                vertexShader: Ta.sprite_vert,
                fragmentShader: Ta.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new hn
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: Ta.background_vert,
                fragmentShader: Ta.background_frag
            },
            cube: {
                uniforms: Br([Aa.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ta.cube_vert,
                fragmentShader: Ta.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Ta.equirect_vert,
                fragmentShader: Ta.equirect_frag
            },
            distanceRGBA: {
                uniforms: Br([Aa.common, Aa.displacementmap, {
                    referencePosition: {
                        value: new bn
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Ta.distanceRGBA_vert,
                fragmentShader: Ta.distanceRGBA_frag
            },
            shadow: {
                uniforms: Br([Aa.lights, Aa.fog, {
                    color: {
                        value: new Xi(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ta.shadow_vert,
                fragmentShader: Ta.shadow_frag
            }
        };
        function Ra(t, e, n, i, r) {
            const o = new Xi(0);
            let s, a, c = 0, l = null, u = 0, h = null;
            function f(n, r, f, g) {
                let v = !0 === r.isScene ? r.background : null;
                v && v.isTexture && (v = e.get(v));
                const y = t.xr
                    , _ = y.getSession && y.getSession();
                _ && "additive" === _.environmentBlendMode && (v = null),
                    null === v ? m(o, c) : v && v.isColor && (m(v, 1),
                        g = !0),
                (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    v && (v.isCubeTexture || v.mapping === st) ? (void 0 === a && (a = new Nr(new kr(1,1,1),new Gr({
                        name: "BackgroundCubeMaterial",
                        uniforms: Hr(La.cube.uniforms),
                        vertexShader: La.cube.vertexShader,
                        fragmentShader: La.cube.fragmentShader,
                        side: p,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                        a.geometry.deleteAttribute("normal"),
                        a.geometry.deleteAttribute("uv"),
                        a.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }
                        ,
                        Object.defineProperty(a.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        i.update(a)),
                        a.material.uniforms.envMap.value = v,
                        a.material.uniforms.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1,
                    l === v && u === v.version && h === t.toneMapping || (a.material.needsUpdate = !0,
                        l = v,
                        u = v.version,
                        h = t.toneMapping),
                        n.unshift(a, a.geometry, a.material, 0, 0, null)) : v && v.isTexture && (void 0 === s && (s = new Nr(new io(2,2),new Gr({
                        name: "BackgroundMaterial",
                        uniforms: Hr(La.background.uniforms),
                        vertexShader: La.background.vertexShader,
                        fragmentShader: La.background.fragmentShader,
                        side: d,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                        s.geometry.deleteAttribute("normal"),
                        Object.defineProperty(s.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        i.update(s)),
                        s.material.uniforms.t2D.value = v,
                    !0 === v.matrixAutoUpdate && v.updateMatrix(),
                        s.material.uniforms.uvTransform.value.copy(v.matrix),
                    l === v && u === v.version && h === t.toneMapping || (s.material.needsUpdate = !0,
                        l = v,
                        u = v.version,
                        h = t.toneMapping),
                        n.unshift(s, s.geometry, s.material, 0, 0, null))
            }
            function m(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, r)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(t, e=1) {
                    o.set(t),
                        c = e,
                        m(o, c)
                },
                getClearAlpha: function() {
                    return c
                },
                setClearAlpha: function(t) {
                    c = t,
                        m(o, c)
                },
                render: f
            }
        }
        function Ca(t, e, n, i) {
            const r = t.getParameter(34921)
                , o = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
                , s = i.isWebGL2 || null !== o
                , a = {}
                , c = m(null);
            let l = c;
            function u(e, i, r, o, a) {
                let c = !1;
                if (s) {
                    const t = f(o, r, i);
                    l !== t && (l = t,
                        d(l.object)),
                        c = g(o, a),
                    c && v(o, a)
                } else {
                    const t = !0 === i.wireframe;
                    l.geometry === o.id && l.program === r.id && l.wireframe === t || (l.geometry = o.id,
                        l.program = r.id,
                        l.wireframe = t,
                        c = !0)
                }
                !0 === e.isInstancedMesh && (c = !0),
                null !== a && n.update(a, 34963),
                c && (M(e, i, r, o),
                null !== a && t.bindBuffer(34963, n.get(a).buffer))
            }
            function h() {
                return i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()
            }
            function d(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
            }
            function p(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
            }
            function f(t, e, n) {
                const i = !0 === n.wireframe;
                let r = a[t.id];
                void 0 === r && (r = {},
                    a[t.id] = r);
                let o = r[e.id];
                void 0 === o && (o = {},
                    r[e.id] = o);
                let s = o[i];
                return void 0 === s && (s = m(h()),
                    o[i] = s),
                    s
            }
            function m(t) {
                const e = []
                    , n = []
                    , i = [];
                for (let o = 0; o < r; o++)
                    e[o] = 0,
                        n[o] = 0,
                        i[o] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function g(t, e) {
                const n = l.attributes
                    , i = t.attributes;
                let r = 0;
                for (const o in i) {
                    const t = n[o]
                        , e = i[o];
                    if (void 0 === t)
                        return !0;
                    if (t.attribute !== e)
                        return !0;
                    if (t.data !== e.data)
                        return !0;
                    r++
                }
                return l.attributesNum !== r || l.index !== e
            }
            function v(t, e) {
                const n = {}
                    , i = t.attributes;
                let r = 0;
                for (const o in i) {
                    const t = i[o]
                        , e = {};
                    e.attribute = t,
                    t.data && (e.data = t.data),
                        n[o] = e,
                        r++
                }
                l.attributes = n,
                    l.attributesNum = r,
                    l.index = e
            }
            function y() {
                const t = l.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function _(t) {
                x(t, 0)
            }
            function x(n, r) {
                const o = l.newAttributes
                    , s = l.enabledAttributes
                    , a = l.attributeDivisors;
                if (o[n] = 1,
                0 === s[n] && (t.enableVertexAttribArray(n),
                    s[n] = 1),
                a[n] !== r) {
                    const o = i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays");
                    o[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                        a[n] = r
                }
            }
            function b() {
                const e = l.newAttributes
                    , n = l.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== e[i] && (t.disableVertexAttribArray(i),
                        n[i] = 0)
            }
            function w(e, n, r, o, s, a) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a)
            }
            function M(r, o, s, a) {
                if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                    return;
                y();
                const c = a.attributes
                    , l = s.getAttributes()
                    , u = o.defaultAttributeValues;
                for (const e in l) {
                    const i = l[e];
                    if (i >= 0) {
                        const o = c[e];
                        if (void 0 !== o) {
                            const e = o.normalized
                                , r = o.itemSize
                                , s = n.get(o);
                            if (void 0 === s)
                                continue;
                            const c = s.buffer
                                , l = s.type
                                , u = s.bytesPerElement;
                            if (o.isInterleavedBufferAttribute) {
                                const n = o.data
                                    , s = n.stride
                                    , h = o.offset;
                                n && n.isInstancedInterleavedBuffer ? (x(i, n.meshPerAttribute),
                                void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : _(i),
                                    t.bindBuffer(34962, c),
                                    w(i, r, l, e, s * u, h * u)
                            } else
                                o.isInstancedBufferAttribute ? (x(i, o.meshPerAttribute),
                                void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : _(i),
                                    t.bindBuffer(34962, c),
                                    w(i, r, l, e, 0, 0)
                        } else if ("instanceMatrix" === e) {
                            const e = n.get(r.instanceMatrix);
                            if (void 0 === e)
                                continue;
                            const o = e.buffer
                                , s = e.type;
                            x(i + 0, 1),
                                x(i + 1, 1),
                                x(i + 2, 1),
                                x(i + 3, 1),
                                t.bindBuffer(34962, o),
                                t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                                t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                                t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                                t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48)
                        } else if ("instanceColor" === e) {
                            const e = n.get(r.instanceColor);
                            if (void 0 === e)
                                continue;
                            const o = e.buffer
                                , s = e.type;
                            x(i, 1),
                                t.bindBuffer(34962, o),
                                t.vertexAttribPointer(i, 3, s, !1, 12, 0)
                        } else if (void 0 !== u) {
                            const n = u[e];
                            if (void 0 !== n)
                                switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(i, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(i, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(i, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(i, n)
                                }
                        }
                    }
                }
                b()
            }
            function S() {
                A();
                for (const t in a) {
                    const e = a[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            p(n[t].object),
                                delete n[t];
                        delete e[t]
                    }
                    delete a[t]
                }
            }
            function E(t) {
                if (void 0 === a[t.id])
                    return;
                const e = a[t.id];
                for (const n in e) {
                    const t = e[n];
                    for (const e in t)
                        p(t[e].object),
                            delete t[e];
                    delete e[n]
                }
                delete a[t.id]
            }
            function T(t) {
                for (const e in a) {
                    const n = a[e];
                    if (void 0 === n[t.id])
                        continue;
                    const i = n[t.id];
                    for (const t in i)
                        p(i[t].object),
                            delete i[t];
                    delete n[t.id]
                }
            }
            function A() {
                L(),
                l !== c && (l = c,
                    d(l.object))
            }
            function L() {
                c.geometry = null,
                    c.program = null,
                    c.wireframe = !1
            }
            return {
                setup: u,
                reset: A,
                resetDefaultState: L,
                dispose: S,
                releaseStatesOfGeometry: E,
                releaseStatesOfProgram: T,
                initAttributes: y,
                enableAttribute: _,
                disableUnusedAttributes: b
            }
        }
        function Pa(t, e, n, i) {
            const r = i.isWebGL2;
            let o;
            function s(t) {
                o = t
            }
            function a(e, i) {
                t.drawArrays(o, e, i),
                    n.update(i, o, 1)
            }
            function c(i, s, a) {
                if (0 === a)
                    return;
                let c, l;
                if (r)
                    c = t,
                        l = "drawArraysInstanced";
                else if (c = e.get("ANGLE_instanced_arrays"),
                    l = "drawArraysInstancedANGLE",
                null === c)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[l](o, i, s, a),
                    n.update(s, o, a)
            }
            this.setMode = s,
                this.render = a,
                this.renderInstances = c
        }
        function Oa(t, e, n) {
            let i;
            function r() {
                if (void 0 !== i)
                    return i;
                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                    const n = e.get("EXT_texture_filter_anisotropic");
                    i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    i = 0;
                return i
            }
            function o(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" !== typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const c = o(a);
            c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."),
                a = c);
            const l = !0 === n.logarithmicDepthBuffer
                , u = t.getParameter(34930)
                , h = t.getParameter(35660)
                , d = t.getParameter(3379)
                , p = t.getParameter(34076)
                , f = t.getParameter(34921)
                , m = t.getParameter(36347)
                , g = t.getParameter(36348)
                , v = t.getParameter(36349)
                , y = h > 0
                , _ = s || e.has("OES_texture_float")
                , x = y && _
                , b = s ? t.getParameter(36183) : 0;
            return {
                isWebGL2: s,
                getMaxAnisotropy: r,
                getMaxPrecision: o,
                precision: a,
                logarithmicDepthBuffer: l,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: _,
                floatVertexTextures: x,
                maxSamples: b
            }
        }
        function Ia(t) {
            const e = this;
            let n = null
                , i = 0
                , r = !1
                , o = !1;
            const s = new Ai
                , a = new hn
                , c = {
                value: null,
                needsUpdate: !1
            };
            function l() {
                c.value !== n && (c.value = n,
                    c.needsUpdate = i > 0),
                    e.numPlanes = i,
                    e.numIntersection = 0
            }
            function u(t, n, i, r) {
                const o = null !== t ? t.length : 0;
                let l = null;
                if (0 !== o) {
                    if (l = c.value,
                    !0 !== r || null === l) {
                        const e = i + 4 * o
                            , r = n.matrixWorldInverse;
                        a.getNormalMatrix(r),
                        (null === l || l.length < e) && (l = new Float32Array(e));
                        for (let n = 0, c = i; n !== o; ++n,
                            c += 4)
                            s.copy(t[n]).applyMatrix4(r, a),
                                s.normal.toArray(l, c),
                                l[c + 3] = s.constant
                    }
                    c.value = l,
                        c.needsUpdate = !0
                }
                return e.numPlanes = o,
                    e.numIntersection = 0,
                    l
            }
            this.uniform = c,
                this.numPlanes = 0,
                this.numIntersection = 0,
                this.init = function(t, e, o) {
                    const s = 0 !== t.length || e || 0 !== i || r;
                    return r = e,
                        n = u(t, o, 0),
                        i = t.length,
                        s
                }
                ,
                this.beginShadows = function() {
                    o = !0,
                        u(null)
                }
                ,
                this.endShadows = function() {
                    o = !1,
                        l()
                }
                ,
                this.setState = function(e, s, a) {
                    const h = e.clippingPlanes
                        , d = e.clipIntersection
                        , p = e.clipShadows
                        , f = t.get(e);
                    if (!r || null === h || 0 === h.length || o && !p)
                        o ? u(null) : l();
                    else {
                        const t = o ? 0 : i
                            , e = 4 * t;
                        let r = f.clippingState || null;
                        c.value = r,
                            r = u(h, s, e, a);
                        for (let i = 0; i !== e; ++i)
                            r[i] = n[i];
                        f.clippingState = r,
                            this.numIntersection = d ? this.numPlanes : 0,
                            this.numPlanes += t
                    }
                }
        }
        function Na(t) {
            let e = new WeakMap;
            function n(t, e) {
                return e === rt ? t.mapping = nt : e === ot && (t.mapping = it),
                    t
            }
            function i(i) {
                if (i && i.isTexture) {
                    const o = i.mapping;
                    if (o === rt || o === ot) {
                        if (e.has(i)) {
                            const t = e.get(i).texture;
                            return n(t, i.mapping)
                        }
                        {
                            const o = i.image;
                            if (o && o.height > 0) {
                                const s = t.getRenderTarget()
                                    , a = new Jr(o.height / 2);
                                return a.fromEquirectangularTexture(t, i),
                                    e.set(i, a),
                                    t.setRenderTarget(s),
                                    i.addEventListener("dispose", r),
                                    n(a.texture, i.mapping)
                            }
                            return null
                        }
                    }
                }
                return i
            }
            function r(t) {
                const n = t.target;
                n.removeEventListener("dispose", r);
                const i = e.get(n);
                void 0 !== i && (e.delete(n),
                    i.dispose())
            }
            function o() {
                e = new WeakMap
            }
            return {
                get: i,
                dispose: o
            }
        }
        function Da(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return e[n] = i,
                    i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                        n("OES_texture_float"),
                        n("OES_texture_half_float"),
                        n("OES_texture_half_float_linear"),
                        n("OES_standard_derivatives"),
                        n("OES_element_index_uint"),
                        n("OES_vertex_array_object"),
                        n("ANGLE_instanced_arrays")),
                        n("OES_texture_float_linear"),
                        n("EXT_color_buffer_half_float")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                        e
                }
            }
        }
        function Fa(t, e, n, i) {
            const r = {}
                , o = new WeakMap;
            function s(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const n in a.attributes)
                    e.remove(a.attributes[n]);
                a.removeEventListener("dispose", s),
                    delete r[a.id];
                const c = o.get(a);
                c && (e.remove(c),
                    o.delete(a)),
                    i.releaseStatesOfGeometry(a),
                !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
                    n.memory.geometries--
            }
            function a(t, e) {
                return !0 === r[e.id] || (e.addEventListener("dispose", s),
                    r[e.id] = !0,
                    n.memory.geometries++),
                    e
            }
            function c(t) {
                const n = t.attributes;
                for (const r in n)
                    e.update(n[r], 34962);
                const i = t.morphAttributes;
                for (const r in i) {
                    const t = i[r];
                    for (let n = 0, i = t.length; n < i; n++)
                        e.update(t[n], 34962)
                }
            }
            function l(t) {
                const n = []
                    , i = t.index
                    , r = t.attributes.position;
                let s = 0;
                if (null !== i) {
                    const t = i.array;
                    s = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0]
                            , r = t[e + 1]
                            , o = t[e + 2];
                        n.push(i, r, r, o, o, i)
                    }
                } else {
                    const t = r.array;
                    s = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0
                            , i = e + 1
                            , r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const a = new (cr(n) > 65535 ? rr : nr)(n,1);
                a.version = s;
                const c = o.get(t);
                c && e.remove(c),
                    o.set(t, a)
            }
            function u(t) {
                const e = o.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && l(t)
                } else
                    l(t);
                return o.get(t)
            }
            return {
                get: a,
                update: c,
                getWireframeAttribute: u
            }
        }
        function ka(t, e, n, i) {
            const r = i.isWebGL2;
            let o, s, a;
            function c(t) {
                o = t
            }
            function l(t) {
                s = t.type,
                    a = t.bytesPerElement
            }
            function u(e, i) {
                t.drawElements(o, i, s, e * a),
                    n.update(i, o, 1)
            }
            function h(i, c, l) {
                if (0 === l)
                    return;
                let u, h;
                if (r)
                    u = t,
                        h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"),
                    h = "drawElementsInstancedANGLE",
                null === u)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](o, c, s, i * a, l),
                    n.update(c, o, l)
            }
            this.setMode = c,
                this.setIndex = l,
                this.render = u,
                this.renderInstances = h
        }
        function Ha(t) {
            const e = {
                geometries: 0,
                textures: 0
            }
                , n = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            function i(t, e, i) {
                switch (n.calls++,
                    e) {
                    case 4:
                        n.triangles += i * (t / 3);
                        break;
                    case 1:
                        n.lines += i * (t / 2);
                        break;
                    case 3:
                        n.lines += i * (t - 1);
                        break;
                    case 2:
                        n.lines += i * t;
                        break;
                    case 0:
                        n.points += i * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", e);
                        break
                }
            }
            function r() {
                n.frame++,
                    n.calls = 0,
                    n.triangles = 0,
                    n.points = 0,
                    n.lines = 0
            }
            return {
                memory: e,
                render: n,
                programs: null,
                autoReset: !0,
                reset: r,
                update: i
            }
        }
        function Ba(t, e) {
            return t[0] - e[0]
        }
        function za(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function Ua(t) {
            const e = {}
                , n = new Float32Array(8)
                , i = [];
            for (let o = 0; o < 8; o++)
                i[o] = [o, 0];
            function r(r, o, s, a) {
                const c = r.morphTargetInfluences
                    , l = void 0 === c ? 0 : c.length;
                let u = e[o.id];
                if (void 0 === u) {
                    u = [];
                    for (let t = 0; t < l; t++)
                        u[t] = [t, 0];
                    e[o.id] = u
                }
                for (let t = 0; t < l; t++) {
                    const e = u[t];
                    e[0] = t,
                        e[1] = c[t]
                }
                u.sort(za);
                for (let t = 0; t < 8; t++)
                    t < l && u[t][1] ? (i[t][0] = u[t][0],
                        i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER,
                        i[t][1] = 0);
                i.sort(Ba);
                const h = s.morphTargets && o.morphAttributes.position
                    , d = s.morphNormals && o.morphAttributes.normal;
                let p = 0;
                for (let t = 0; t < 8; t++) {
                    const e = i[t]
                        , r = e[0]
                        , s = e[1];
                    r !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[r] && o.setAttribute("morphTarget" + t, h[r]),
                    d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]),
                        n[t] = s,
                        p += s) : (h && !0 === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t),
                    d && !0 === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t),
                        n[t] = 0)
                }
                const f = o.morphTargetsRelative ? 1 : 1 - p;
                a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
                    a.getUniforms().setValue(t, "morphTargetInfluences", n)
            }
            return {
                update: r
            }
        }
        function ja(t, e, n, i) {
            let r = new WeakMap;
            function o(t) {
                const o = i.render.frame
                    , s = t.geometry
                    , c = e.get(t, s);
                return r.get(c) !== o && (e.update(c),
                    r.set(c, o)),
                t.isInstancedMesh && (!1 === t.hasEventListener("dispose", a) && t.addEventListener("dispose", a),
                    n.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                    c
            }
            function s() {
                r = new WeakMap
            }
            function a(t) {
                const e = t.target;
                e.removeEventListener("dispose", a),
                    n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: o,
                dispose: s
            }
        }
        La.physical = {
            uniforms: Br([La.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new un(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Xi(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: Ta.meshphysical_vert,
            fragmentShader: Ta.meshphysical_frag
        };
        class Ga extends mn {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                    this.image = {
                        data: t,
                        width: e,
                        height: n,
                        depth: i
                    },
                    this.magFilter = ht,
                    this.minFilter = ht,
                    this.wrapR = lt,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.needsUpdate = !0
            }
        }
        Ga.prototype.isDataTexture2DArray = !0;
        class Va extends mn {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                    this.image = {
                        data: t,
                        width: e,
                        height: n,
                        depth: i
                    },
                    this.magFilter = ht,
                    this.minFilter = ht,
                    this.wrapR = lt,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.needsUpdate = !0
            }
        }
        Va.prototype.isDataTexture3D = !0;
        const Wa = new mn
            , qa = new Ga
            , Xa = new Va
            , Ya = new Zr
            , Za = []
            , Ja = []
            , Ka = new Float32Array(16)
            , Qa = new Float32Array(9)
            , $a = new Float32Array(4);
        function tc(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0)
                return t;
            const r = e * n;
            let o = Za[r];
            if (void 0 === o && (o = new Float32Array(r),
                Za[r] = o),
            0 !== e) {
                i.toArray(o, 0);
                for (let i = 1, r = 0; i !== e; ++i)
                    r += n,
                        t[i].toArray(o, r)
            }
            return o
        }
        function ec(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function nc(t, e) {
            for (let n = 0, i = e.length; n < i; n++)
                t[n] = e[n]
        }
        function ic(t, e) {
            let n = Ja[e];
            void 0 === n && (n = new Int32Array(e),
                Ja[e] = n);
            for (let i = 0; i !== e; ++i)
                n[i] = t.allocateTextureUnit();
            return n
        }
        function rc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
                n[0] = e)
        }
        function oc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                    n[0] = e.x,
                    n[1] = e.y);
            else {
                if (ec(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                    nc(n, e)
            }
        }
        function sc(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                    n[0] = e.x,
                    n[1] = e.y,
                    n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                    n[0] = e.r,
                    n[1] = e.g,
                    n[2] = e.b);
            else {
                if (ec(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                    nc(n, e)
            }
        }
        function ac(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                    n[0] = e.x,
                    n[1] = e.y,
                    n[2] = e.z,
                    n[3] = e.w);
            else {
                if (ec(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                    nc(n, e)
            }
        }
        function cc(t, e) {
            const n = this.cache
                , i = e.elements;
            if (void 0 === i) {
                if (ec(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                    nc(n, e)
            } else {
                if (ec(n, i))
                    return;
                $a.set(i),
                    t.uniformMatrix2fv(this.addr, !1, $a),
                    nc(n, i)
            }
        }
        function lc(t, e) {
            const n = this.cache
                , i = e.elements;
            if (void 0 === i) {
                if (ec(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                    nc(n, e)
            } else {
                if (ec(n, i))
                    return;
                Qa.set(i),
                    t.uniformMatrix3fv(this.addr, !1, Qa),
                    nc(n, i)
            }
        }
        function uc(t, e) {
            const n = this.cache
                , i = e.elements;
            if (void 0 === i) {
                if (ec(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                    nc(n, e)
            } else {
                if (ec(n, i))
                    return;
                Ka.set(i),
                    t.uniformMatrix4fv(this.addr, !1, Ka),
                    nc(n, i)
            }
        }
        function hc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
                n[0] = e)
        }
        function dc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform2iv(this.addr, e),
                nc(n, e))
        }
        function pc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform3iv(this.addr, e),
                nc(n, e))
        }
        function fc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform4iv(this.addr, e),
                nc(n, e))
        }
        function mc(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
                n[0] = e)
        }
        function gc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform2uiv(this.addr, e),
                nc(n, e))
        }
        function vc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform3uiv(this.addr, e),
                nc(n, e))
        }
        function yc(t, e) {
            const n = this.cache;
            ec(n, e) || (t.uniform4uiv(this.addr, e),
                nc(n, e))
        }
        function _c(t, e, n) {
            const i = this.cache
                , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
                i[0] = r),
                n.safeSetTexture2D(e || Wa, r)
        }
        function xc(t, e, n) {
            const i = this.cache
                , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
                i[0] = r),
                n.setTexture3D(e || Xa, r)
        }
        function bc(t, e, n) {
            const i = this.cache
                , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
                i[0] = r),
                n.safeSetTextureCube(e || Ya, r)
        }
        function wc(t, e, n) {
            const i = this.cache
                , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
                i[0] = r),
                n.setTexture2DArray(e || qa, r)
        }
        function Mc(t) {
            switch (t) {
                case 5126:
                    return rc;
                case 35664:
                    return oc;
                case 35665:
                    return sc;
                case 35666:
                    return ac;
                case 35674:
                    return cc;
                case 35675:
                    return lc;
                case 35676:
                    return uc;
                case 5124:
                case 35670:
                    return hc;
                case 35667:
                case 35671:
                    return dc;
                case 35668:
                case 35672:
                    return pc;
                case 35669:
                case 35673:
                    return fc;
                case 5125:
                    return mc;
                case 36294:
                    return gc;
                case 36295:
                    return vc;
                case 36296:
                    return yc;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return _c;
                case 35679:
                case 36299:
                case 36307:
                    return xc;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return bc;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return wc
            }
        }
        function Sc(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function Ec(t, e) {
            const n = tc(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function Tc(t, e) {
            const n = tc(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function Ac(t, e) {
            const n = tc(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function Lc(t, e) {
            const n = tc(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function Rc(t, e) {
            const n = tc(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function Cc(t, e) {
            const n = tc(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function Pc(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function Oc(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function Ic(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function Nc(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function Dc(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function Fc(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function kc(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function Hc(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function Bc(t, e, n) {
            const i = e.length
                , r = ic(n, i);
            t.uniform1iv(this.addr, r);
            for (let o = 0; o !== i; ++o)
                n.safeSetTexture2D(e[o] || Wa, r[o])
        }
        function zc(t, e, n) {
            const i = e.length
                , r = ic(n, i);
            t.uniform1iv(this.addr, r);
            for (let o = 0; o !== i; ++o)
                n.safeSetTextureCube(e[o] || Ya, r[o])
        }
        function Uc(t) {
            switch (t) {
                case 5126:
                    return Sc;
                case 35664:
                    return Ec;
                case 35665:
                    return Tc;
                case 35666:
                    return Ac;
                case 35674:
                    return Lc;
                case 35675:
                    return Rc;
                case 35676:
                    return Cc;
                case 5124:
                case 35670:
                    return Pc;
                case 35667:
                case 35671:
                    return Oc;
                case 35668:
                case 35672:
                    return Ic;
                case 35669:
                case 35673:
                    return Nc;
                case 5125:
                    return Dc;
                case 36294:
                    return Fc;
                case 36295:
                    return kc;
                case 36296:
                    return Hc;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Bc;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return zc
            }
        }
        function jc(t, e, n) {
            this.id = t,
                this.addr = n,
                this.cache = [],
                this.setValue = Mc(e.type)
        }
        function Gc(t, e, n) {
            this.id = t,
                this.addr = n,
                this.cache = [],
                this.size = e.size,
                this.setValue = Uc(e.type)
        }
        function Vc(t) {
            this.id = t,
                this.seq = [],
                this.map = {}
        }
        Gc.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
                nc(e, t)
        }
            ,
            Vc.prototype.setValue = function(t, e, n) {
                const i = this.seq;
                for (let r = 0, o = i.length; r !== o; ++r) {
                    const o = i[r];
                    o.setValue(t, e[o.id], n)
                }
            }
        ;
        const Wc = /(\w+)(\])?(\[|\.)?/g;
        function qc(t, e) {
            t.seq.push(e),
                t.map[e.id] = e
        }
        function Xc(t, e, n) {
            const i = t.name
                , r = i.length;
            Wc.lastIndex = 0;
            while (1) {
                const o = Wc.exec(i)
                    , s = Wc.lastIndex;
                let a = o[1];
                const c = "]" === o[2]
                    , l = o[3];
                if (c && (a |= 0),
                void 0 === l || "[" === l && s + 2 === r) {
                    qc(n, void 0 === l ? new jc(a,t,e) : new Gc(a,t,e));
                    break
                }
                {
                    const t = n.map;
                    let e = t[a];
                    void 0 === e && (e = new Vc(a),
                        qc(n, e)),
                        n = e
                }
            }
        }
        function Yc(t, e) {
            this.seq = [],
                this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i)
                    , r = t.getUniformLocation(e, n.name);
                Xc(n, r, this)
            }
        }
        function Zc(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n),
                t.compileShader(i),
                i
        }
        Yc.prototype.setValue = function(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }
            ,
            Yc.prototype.setOptional = function(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            ,
            Yc.upload = function(t, e, n, i) {
                for (let r = 0, o = e.length; r !== o; ++r) {
                    const o = e[r]
                        , s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(t, s.value, i)
                }
            }
            ,
            Yc.seqWithValue = function(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        ;
        let Jc = 0;
        function Kc(t) {
            const e = t.split("\n");
            for (let n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }
        function Qc(t) {
            switch (t) {
                case je:
                    return ["Linear", "( value )"];
                case Ge:
                    return ["sRGB", "( value )"];
                case We:
                    return ["RGBE", "( value )"];
                case Xe:
                    return ["RGBM", "( value, 7.0 )"];
                case Ye:
                    return ["RGBM", "( value, 16.0 )"];
                case Ze:
                    return ["RGBD", "( value, 256.0 )"];
                case Ve:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case qe:
                    return ["LogLuv", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                        ["Linear", "( value )"]
            }
        }
        function $c(t, e, n) {
            const i = t.getShaderParameter(e, 35713)
                , r = t.getShaderInfoLog(e).trim();
            if (i && "" === r)
                return "";
            const o = t.getShaderSource(e);
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + Kc(o)
        }
        function tl(t, e) {
            const n = Qc(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }
        function el(t, e) {
            const n = Qc(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }
        function nl(t, e) {
            let n;
            switch (e) {
                case J:
                    n = "Linear";
                    break;
                case K:
                    n = "Reinhard";
                    break;
                case Q:
                    n = "OptimizedCineon";
                    break;
                case $:
                    n = "ACESFilmic";
                    break;
                case tt:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                        n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function il(t) {
            const e = [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
            return e.filter(sl).join("\n")
        }
        function rl(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i)
            }
            return e.join("\n")
        }
        function ol(t, e) {
            const n = {}
                , i = t.getProgramParameter(e, 35721);
            for (let r = 0; r < i; r++) {
                const i = t.getActiveAttrib(e, r)
                    , o = i.name;
                n[o] = t.getAttribLocation(e, o)
            }
            return n
        }
        function sl(t) {
            return "" !== t
        }
        function al(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function cl(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const ll = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function ul(t) {
            return t.replace(ll, hl)
        }
        function hl(t, e) {
            const n = Ta[e];
            if (void 0 === n)
                throw new Error("Can not resolve #include <" + e + ">");
            return ul(n)
        }
        const dl = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
            , pl = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function fl(t) {
            return t.replace(pl, gl).replace(dl, ml)
        }
        function ml(t, e, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
                gl(t, e, n, i)
        }
        function gl(t, e, n, i) {
            let r = "";
            for (let o = parseInt(e); o < parseInt(n); o++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
            return r
        }
        function vl(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
                e
        }
        function yl(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === u ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"),
                e
        }
        function _l(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
                switch (t.envMapMode) {
                    case nt:
                    case it:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case st:
                    case at:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break
                }
            return e
        }
        function xl(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
                switch (t.envMapMode) {
                    case it:
                    case at:
                        e = "ENVMAP_MODE_REFRACTION";
                        break
                }
            return e
        }
        function bl(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
                switch (t.combine) {
                    case q:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case X:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case Y:
                        e = "ENVMAP_BLENDING_ADD";
                        break
                }
            return e
        }
        function wl(t, e, n, i) {
            const r = t.getContext()
                , o = n.defines;
            let s = n.vertexShader
                , a = n.fragmentShader;
            const c = yl(n)
                , l = _l(n)
                , u = xl(n)
                , h = bl(n)
                , d = t.gammaFactor > 0 ? t.gammaFactor : 1
                , p = n.isWebGL2 ? "" : il(n)
                , f = rl(o)
                , m = r.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [f].filter(sl).join("\n"),
            g.length > 0 && (g += "\n"),
                v = [p, f].filter(sl).join("\n"),
            v.length > 0 && (v += "\n")) : (g = [vl(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(sl).join("\n"),
                v = [p, vl(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Z ? "#define TONE_MAPPING" : "", n.toneMapping !== Z ? Ta["tonemapping_pars_fragment"] : "", n.toneMapping !== Z ? nl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Ta["encodings_pars_fragment"], n.map ? tl("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? tl("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? tl("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? tl("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? tl("lightMapTexelToLinear", n.lightMapEncoding) : "", el("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(sl).join("\n")),
                s = ul(s),
                s = al(s, n),
                s = cl(s, n),
                a = ul(a),
                a = al(a, n),
                a = cl(a, n),
                s = fl(s),
                a = fl(a),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
                g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
                v = ["#define varying in", n.glslVersion === on ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === on ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const _ = y + g + s
                , x = y + v + a
                , b = Zc(r, 35633, _)
                , w = Zc(r, 35632, x);
            if (r.attachShader(m, b),
                r.attachShader(m, w),
                void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
                r.linkProgram(m),
                t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim()
                    , e = r.getShaderInfoLog(b).trim()
                    , n = r.getShaderInfoLog(w).trim();
                let i = !0
                    , o = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    i = !1;
                    const e = $c(r, b, "vertex")
                        , n = $c(r, w, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
                } else
                    "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
                o && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: n,
                        prefix: v
                    }
                })
            }
            let M, S;
            return r.deleteShader(b),
                r.deleteShader(w),
                this.getUniforms = function() {
                    return void 0 === M && (M = new Yc(r,m)),
                        M
                }
                ,
                this.getAttributes = function() {
                    return void 0 === S && (S = ol(r, m)),
                        S
                }
                ,
                this.destroy = function() {
                    i.releaseStatesOfProgram(this),
                        r.deleteProgram(m),
                        this.program = void 0
                }
                ,
                this.name = n.shaderName,
                this.id = Jc++,
                this.cacheKey = e,
                this.usedTimes = 1,
                this.program = m,
                this.vertexShader = b,
                this.fragmentShader = w,
                this
        }
        function Ml(t, e, n, i, r, o) {
            const s = []
                , a = i.isWebGL2
                , c = i.logarithmicDepthBuffer
                , l = i.floatVertexTextures
                , u = i.maxVertexUniforms
                , h = i.vertexTextures;
            let d = i.precision;
            const m = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            }
                , g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
            function v(t) {
                const e = t.skeleton
                    , n = e.bones;
                if (l)
                    return 1024;
                {
                    const t = u
                        , e = Math.floor((t - 20) / 4)
                        , i = Math.min(e, n.length);
                    return i < n.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + n.length + " bones. This GPU supports " + i + "."),
                        0) : i
                }
            }
            function y(t) {
                let e;
                return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                    e = t.texture.encoding) : e = je,
                    e
            }
            function _(r, s, u, g, _) {
                const x = g.fog
                    , b = r.isMeshStandardMaterial ? g.environment : null
                    , w = e.get(r.envMap || b)
                    , M = m[r.type]
                    , S = _.isSkinnedMesh ? v(_) : 0;
                let E, T;
                if (null !== r.precision && (d = i.getMaxPrecision(r.precision),
                d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")),
                    M) {
                    const t = La[M];
                    E = t.vertexShader,
                        T = t.fragmentShader
                } else
                    E = r.vertexShader,
                        T = r.fragmentShader;
                const A = t.getRenderTarget()
                    , L = {
                    isWebGL2: a,
                    shaderID: M,
                    shaderName: r.type,
                    vertexShader: E,
                    fragmentShader: T,
                    defines: r.defines,
                    isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                    glslVersion: r.glslVersion,
                    precision: d,
                    instancing: !0 === _.isInstancedMesh,
                    instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                    supportsVertexTextures: h,
                    outputEncoding: null !== A ? y(A.texture) : t.outputEncoding,
                    map: !!r.map,
                    mapEncoding: y(r.map),
                    matcap: !!r.matcap,
                    matcapEncoding: y(r.matcap),
                    envMap: !!w,
                    envMapMode: w && w.mapping,
                    envMapEncoding: y(w),
                    envMapCubeUV: !!w && (w.mapping === st || w.mapping === at),
                    lightMap: !!r.lightMap,
                    lightMapEncoding: y(r.lightMap),
                    aoMap: !!r.aoMap,
                    emissiveMap: !!r.emissiveMap,
                    emissiveMapEncoding: y(r.emissiveMap),
                    bumpMap: !!r.bumpMap,
                    normalMap: !!r.normalMap,
                    objectSpaceNormalMap: r.normalMapType === $e,
                    tangentSpaceNormalMap: r.normalMapType === Qe,
                    clearcoatMap: !!r.clearcoatMap,
                    clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!r.clearcoatNormalMap,
                    displacementMap: !!r.displacementMap,
                    roughnessMap: !!r.roughnessMap,
                    metalnessMap: !!r.metalnessMap,
                    specularMap: !!r.specularMap,
                    alphaMap: !!r.alphaMap,
                    gradientMap: !!r.gradientMap,
                    sheen: !!r.sheen,
                    transmissionMap: !!r.transmissionMap,
                    combine: r.combine,
                    vertexTangents: r.normalMap && r.vertexTangents,
                    vertexColors: r.vertexColors,
                    vertexAlphas: !0 === r.vertexColors && _.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
                    vertexUvs: !!r.map || !!r.bumpMap || !!r.normalMap || !!r.specularMap || !!r.alphaMap || !!r.emissiveMap || !!r.roughnessMap || !!r.metalnessMap || !!r.clearcoatMap || !!r.clearcoatRoughnessMap || !!r.clearcoatNormalMap || !!r.displacementMap || !!r.transmissionMap,
                    uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap) && !!r.displacementMap,
                    fog: !!x,
                    useFog: r.fog,
                    fogExp2: x && x.isFogExp2,
                    flatShading: !!r.flatShading,
                    sizeAttenuation: r.sizeAttenuation,
                    logarithmicDepthBuffer: c,
                    skinning: r.skinning && S > 0,
                    maxBones: S,
                    useVertexTexture: l,
                    morphTargets: r.morphTargets,
                    morphNormals: r.morphNormals,
                    numDirLights: s.directional.length,
                    numPointLights: s.point.length,
                    numSpotLights: s.spot.length,
                    numRectAreaLights: s.rectArea.length,
                    numHemiLights: s.hemi.length,
                    numDirLightShadows: s.directionalShadowMap.length,
                    numPointLightShadows: s.pointShadowMap.length,
                    numSpotLightShadows: s.spotShadowMap.length,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    dithering: r.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: r.toneMapped ? t.toneMapping : Z,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: r.premultipliedAlpha,
                    alphaTest: r.alphaTest,
                    doubleSided: r.side === f,
                    flipSided: r.side === p,
                    depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                    index0AttributeName: r.index0AttributeName,
                    extensionDerivatives: r.extensions && r.extensions.derivatives,
                    extensionFragDepth: r.extensions && r.extensions.fragDepth,
                    extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                    extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: r.customProgramCacheKey()
                };
                return L
            }
            function x(e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader),
                    n.push(e.vertexShader)),
                void 0 !== e.defines)
                    for (const t in e.defines)
                        n.push(t),
                            n.push(e.defines[t]);
                if (!1 === e.isRawShaderMaterial) {
                    for (let t = 0; t < g.length; t++)
                        n.push(e[g[t]]);
                    n.push(t.outputEncoding),
                        n.push(t.gammaFactor)
                }
                return n.push(e.customProgramCacheKey),
                    n.join()
            }
            function b(t) {
                const e = m[t.type];
                let n;
                if (e) {
                    const t = La[e];
                    n = zr.clone(t.uniforms)
                } else
                    n = t.uniforms;
                return n
            }
            function w(e, n) {
                let i;
                for (let t = 0, r = s.length; t < r; t++) {
                    const e = s[t];
                    if (e.cacheKey === n) {
                        i = e,
                            ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new wl(t,n,e,r),
                    s.push(i)),
                    i
            }
            function M(t) {
                if (0 === --t.usedTimes) {
                    const e = s.indexOf(t);
                    s[e] = s[s.length - 1],
                        s.pop(),
                        t.destroy()
                }
            }
            return {
                getParameters: _,
                getProgramCacheKey: x,
                getUniforms: b,
                acquireProgram: w,
                releaseProgram: M,
                programs: s
            }
        }
        function Sl() {
            let t = new WeakMap;
            function e(e) {
                let n = t.get(e);
                return void 0 === n && (n = {},
                    t.set(e, n)),
                    n
            }
            function n(e) {
                t.delete(e)
            }
            function i(e, n, i) {
                t.get(e)[n] = i
            }
            function r() {
                t = new WeakMap
            }
            return {
                get: e,
                remove: n,
                update: i,
                dispose: r
            }
        }
        function El(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function Tl(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function Al(t) {
            const e = [];
            let n = 0;
            const i = []
                , r = []
                , o = {
                id: -1
            };
            function s() {
                n = 0,
                    i.length = 0,
                    r.length = 0
            }
            function a(i, r, s, a, c, l) {
                let u = e[n];
                const h = t.get(s);
                return void 0 === u ? (u = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: s,
                    program: h.program || o,
                    groupOrder: a,
                    renderOrder: i.renderOrder,
                    z: c,
                    group: l
                },
                    e[n] = u) : (u.id = i.id,
                    u.object = i,
                    u.geometry = r,
                    u.material = s,
                    u.program = h.program || o,
                    u.groupOrder = a,
                    u.renderOrder = i.renderOrder,
                    u.z = c,
                    u.group = l),
                    n++,
                    u
            }
            function c(t, e, n, o, s, c) {
                const l = a(t, e, n, o, s, c);
                (!0 === n.transparent ? r : i).push(l)
            }
            function l(t, e, n, o, s, c) {
                const l = a(t, e, n, o, s, c);
                (!0 === n.transparent ? r : i).unshift(l)
            }
            function u(t, e) {
                i.length > 1 && i.sort(t || El),
                r.length > 1 && r.sort(e || Tl)
            }
            function h() {
                for (let t = n, i = e.length; t < i; t++) {
                    const n = e[t];
                    if (null === n.id)
                        break;
                    n.id = null,
                        n.object = null,
                        n.geometry = null,
                        n.material = null,
                        n.program = null,
                        n.group = null
                }
            }
            return {
                opaque: i,
                transparent: r,
                init: s,
                push: c,
                unshift: l,
                finish: h,
                sort: u
            }
        }
        function Ll(t) {
            let e = new WeakMap;
            function n(n, i) {
                let r;
                return !1 === e.has(n) ? (r = new Al(t),
                    e.set(n, [r])) : i >= e.get(n).length ? (r = new Al(t),
                    e.get(n).push(r)) : r = e.get(n)[i],
                    r
            }
            function i() {
                e = new WeakMap
            }
            return {
                get: n,
                dispose: i
            }
        }
        function Rl() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new bn,
                                color: new Xi
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new bn,
                                direction: new bn,
                                color: new Xi,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new bn,
                                color: new Xi,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new bn,
                                skyColor: new Xi,
                                groundColor: new Xi
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new Xi,
                                position: new bn,
                                halfWidth: new bn,
                                halfHeight: new bn
                            };
                            break
                    }
                    return t[e.id] = n,
                        n
                }
            }
        }
        function Cl() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new un
                            };
                            break;
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new un
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new un,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break
                    }
                    return t[e.id] = n,
                        n
                }
            }
        }
        let Pl = 0;
        function Ol(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function Il(t, e) {
            const n = new Rl
                , i = Cl()
                , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let u = 0; u < 9; u++)
                r.probe.push(new bn);
            const o = new bn
                , s = new Qn
                , a = new Qn;
            function c(o) {
                let s = 0
                    , a = 0
                    , c = 0;
                for (let t = 0; t < 9; t++)
                    r.probe[t].set(0, 0, 0);
                let l = 0
                    , u = 0
                    , h = 0
                    , d = 0
                    , p = 0
                    , f = 0
                    , m = 0
                    , g = 0;
                o.sort(Ol);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = o[t]
                        , v = e.color
                        , y = e.intensity
                        , _ = e.distance
                        , x = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                    if (e.isAmbientLight)
                        s += v.r * y,
                            a += v.g * y,
                            c += v.b * y;
                    else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++)
                            r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                    else if (e.isDirectionalLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            e.castShadow) {
                            const t = e.shadow
                                , n = i.get(e);
                            n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.directionalShadow[l] = n,
                                r.directionalShadowMap[l] = x,
                                r.directionalShadowMatrix[l] = e.shadow.matrix,
                                f++
                        }
                        r.directional[l] = t,
                            l++
                    } else if (e.isSpotLight) {
                        const t = n.get(e);
                        if (t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(v).multiplyScalar(y),
                            t.distance = _,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            e.castShadow) {
                            const t = e.shadow
                                , n = i.get(e);
                            n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.spotShadow[h] = n,
                                r.spotShadowMap[h] = x,
                                r.spotShadowMatrix[h] = e.shadow.matrix,
                                g++
                        }
                        r.spot[h] = t,
                            h++
                    } else if (e.isRectAreaLight) {
                        const t = n.get(e);
                        t.color.copy(v).multiplyScalar(y),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            r.rectArea[d] = t,
                            d++
                    } else if (e.isPointLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                            const t = e.shadow
                                , n = i.get(e);
                            n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                n.shadowCameraNear = t.camera.near,
                                n.shadowCameraFar = t.camera.far,
                                r.pointShadow[u] = n,
                                r.pointShadowMap[u] = x,
                                r.pointShadowMatrix[u] = e.shadow.matrix,
                                m++
                        }
                        r.point[u] = t,
                            u++
                    } else if (e.isHemisphereLight) {
                        const t = n.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(y),
                            t.groundColor.copy(e.groundColor).multiplyScalar(y),
                            r.hemi[p] = t,
                            p++
                    }
                }
                d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Aa.LTC_FLOAT_1,
                    r.rectAreaLTC2 = Aa.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Aa.LTC_HALF_1,
                    r.rectAreaLTC2 = Aa.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = s,
                    r.ambient[1] = a,
                    r.ambient[2] = c;
                const v = r.hash;
                v.directionalLength === l && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = l,
                    r.spot.length = h,
                    r.rectArea.length = d,
                    r.point.length = u,
                    r.hemi.length = p,
                    r.directionalShadow.length = f,
                    r.directionalShadowMap.length = f,
                    r.pointShadow.length = m,
                    r.pointShadowMap.length = m,
                    r.spotShadow.length = g,
                    r.spotShadowMap.length = g,
                    r.directionalShadowMatrix.length = f,
                    r.pointShadowMatrix.length = m,
                    r.spotShadowMatrix.length = g,
                    v.directionalLength = l,
                    v.pointLength = u,
                    v.spotLength = h,
                    v.rectAreaLength = d,
                    v.hemiLength = p,
                    v.numDirectionalShadows = f,
                    v.numPointShadows = m,
                    v.numSpotShadows = g,
                    r.version = Pl++)
            }
            function l(t, e) {
                let n = 0
                    , i = 0
                    , c = 0
                    , l = 0
                    , u = 0;
                const h = e.matrixWorldInverse;
                for (let d = 0, p = t.length; d < p; d++) {
                    const e = t[d];
                    if (e.isDirectionalLight) {
                        const t = r.directional[n];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                            o.setFromMatrixPosition(e.target.matrixWorld),
                            t.direction.sub(o),
                            t.direction.transformDirection(h),
                            n++
                    } else if (e.isSpotLight) {
                        const t = r.spot[c];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                            t.position.applyMatrix4(h),
                            t.direction.setFromMatrixPosition(e.matrixWorld),
                            o.setFromMatrixPosition(e.target.matrixWorld),
                            t.direction.sub(o),
                            t.direction.transformDirection(h),
                            c++
                    } else if (e.isRectAreaLight) {
                        const t = r.rectArea[l];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                            t.position.applyMatrix4(h),
                            a.identity(),
                            s.copy(e.matrixWorld),
                            s.premultiply(h),
                            a.extractRotation(s),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            t.halfWidth.applyMatrix4(a),
                            t.halfHeight.applyMatrix4(a),
                            l++
                    } else if (e.isPointLight) {
                        const t = r.point[i];
                        t.position.setFromMatrixPosition(e.matrixWorld),
                            t.position.applyMatrix4(h),
                            i++
                    } else if (e.isHemisphereLight) {
                        const t = r.hemi[u];
                        t.direction.setFromMatrixPosition(e.matrixWorld),
                            t.direction.transformDirection(h),
                            t.direction.normalize(),
                            u++
                    }
                }
            }
            return {
                setup: c,
                setupView: l,
                state: r
            }
        }
        function Nl(t, e) {
            const n = new Il(t,e)
                , i = []
                , r = [];
            function o() {
                i.length = 0,
                    r.length = 0
            }
            function s(t) {
                i.push(t)
            }
            function a(t) {
                r.push(t)
            }
            function c() {
                n.setup(i)
            }
            function l(t) {
                n.setupView(i, t)
            }
            const u = {
                lightsArray: i,
                shadowsArray: r,
                lights: n
            };
            return {
                init: o,
                state: u,
                setupLights: c,
                setupLightsView: l,
                pushLight: s,
                pushShadow: a
            }
        }
        function Dl(t, e) {
            let n = new WeakMap;
            function i(i, r=0) {
                let o;
                return !1 === n.has(i) ? (o = new Nl(t,e),
                    n.set(i, [o])) : r >= n.get(i).length ? (o = new Nl(t,e),
                    n.get(i).push(o)) : o = n.get(i)[r],
                    o
            }
            function r() {
                n = new WeakMap
            }
            return {
                get: i,
                dispose: r
            }
        }
        class Fl extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = Je,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.depthPacking = t.depthPacking,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.map = t.map,
                    this.alphaMap = t.alphaMap,
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this
            }
        }
        Fl.prototype.isMeshDepthMaterial = !0;
        class kl extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshDistanceMaterial",
                    this.referencePosition = new bn,
                    this.nearDistance = 1,
                    this.farDistance = 1e3,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.fog = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.referencePosition.copy(t.referencePosition),
                    this.nearDistance = t.nearDistance,
                    this.farDistance = t.farDistance,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.map = t.map,
                    this.alphaMap = t.alphaMap,
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this
            }
        }
        kl.prototype.isMeshDistanceMaterial = !0;
        var Hl = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            , Bl = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
        function zl(t, e, n) {
            let i = new to;
            const r = new un
                , o = new un
                , s = new vn
                , a = []
                , c = []
                , u = {}
                , m = n.maxTextureSize
                , v = {
                0: p,
                1: d,
                2: f
            }
                , y = new Gr({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new un
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: Bl,
                fragmentShader: Hl
            })
                , _ = y.clone();
            _.defines.HORIZONTAL_PASS = 1;
            const x = new gr;
            x.setAttribute("position", new Ki(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const b = new Nr(x,y)
                , w = this;
            function M(n, i) {
                const r = e.update(b);
                y.uniforms.shadow_pass.value = n.map.texture,
                    y.uniforms.resolution.value = n.mapSize,
                    y.uniforms.radius.value = n.radius,
                    t.setRenderTarget(n.mapPass),
                    t.clear(),
                    t.renderBufferDirect(i, null, r, y, b, null),
                    _.uniforms.shadow_pass.value = n.mapPass.texture,
                    _.uniforms.resolution.value = n.mapSize,
                    _.uniforms.radius.value = n.radius,
                    t.setRenderTarget(n.map),
                    t.clear(),
                    t.renderBufferDirect(i, null, r, _, b, null)
            }
            function S(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = a[i];
                return void 0 === r && (r = new Fl({
                    depthPacking: Ke,
                    morphTargets: t,
                    skinning: e
                }),
                    a[i] = r),
                    r
            }
            function E(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = c[i];
                return void 0 === r && (r = new kl({
                    morphTargets: t,
                    skinning: e
                }),
                    c[i] = r),
                    r
            }
            function T(e, n, i, r, o, s, a) {
                let c = null
                    , l = S
                    , d = e.customDepthMaterial;
                if (!0 === r.isPointLight && (l = E,
                    d = e.customDistanceMaterial),
                void 0 === d) {
                    let t = !1;
                    !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                    let r = !1;
                    !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                    const o = !0 === e.isInstancedMesh;
                    c = l(t, r, o)
                } else
                    c = d;
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    const t = c.uuid
                        , e = i.uuid;
                    let n = u[t];
                    void 0 === n && (n = {},
                        u[t] = n);
                    let r = n[e];
                    void 0 === r && (r = c.clone(),
                        n[e] = r),
                        c = r
                }
                return c.visible = i.visible,
                    c.wireframe = i.wireframe,
                    c.side = a === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side],
                    c.clipShadows = i.clipShadows,
                    c.clippingPlanes = i.clippingPlanes,
                    c.clipIntersection = i.clipIntersection,
                    c.wireframeLinewidth = i.wireframeLinewidth,
                    c.linewidth = i.linewidth,
                !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
                    c.nearDistance = o,
                    c.farDistance = s),
                    c
            }
            function A(n, r, o, s, a) {
                if (!1 === n.visible)
                    return;
                const c = n.layers.test(r.layers);
                if (c && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === h) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n)
                        , r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let c = 0, l = e.length; c < l; c++) {
                            const l = e[c]
                                , u = r[l.materialIndex];
                            if (u && u.visible) {
                                const e = T(n, i, u, s, o.near, o.far, a);
                                t.renderBufferDirect(o, null, i, e, n, l)
                            }
                        }
                    } else if (r.visible) {
                        const e = T(n, i, r, s, o.near, o.far, a);
                        t.renderBufferDirect(o, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++)
                    A(l[t], r, o, s, a)
            }
            this.enabled = !1,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this.type = l,
                this.render = function(e, n, a) {
                    if (!1 === w.enabled)
                        return;
                    if (!1 === w.autoUpdate && !1 === w.needsUpdate)
                        return;
                    if (0 === e.length)
                        return;
                    const c = t.getRenderTarget()
                        , l = t.getActiveCubeFace()
                        , u = t.getActiveMipmapLevel()
                        , d = t.state;
                    d.setBlending(g),
                        d.buffers.color.setClear(1, 1, 1, 1),
                        d.buffers.depth.setTest(!0),
                        d.setScissorTest(!1);
                    for (let p = 0, f = e.length; p < f; p++) {
                        const c = e[p]
                            , l = c.shadow;
                        if (void 0 === l) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === l.autoUpdate && !1 === l.needsUpdate)
                            continue;
                        r.copy(l.mapSize);
                        const u = l.getFrameExtents();
                        if (r.multiply(u),
                            o.copy(l.mapSize),
                        (r.x > m || r.y > m) && (r.x > m && (o.x = Math.floor(m / u.x),
                            r.x = o.x * u.x,
                            l.mapSize.x = o.x),
                        r.y > m && (o.y = Math.floor(m / u.y),
                            r.y = o.y * u.y,
                            l.mapSize.y = o.y)),
                        null === l.map && !l.isPointLightShadow && this.type === h) {
                            const t = {
                                minFilter: ft,
                                magFilter: ft,
                                format: Pt
                            };
                            l.map = new yn(r.x,r.y,t),
                                l.map.texture.name = c.name + ".shadowMap",
                                l.mapPass = new yn(r.x,r.y,t),
                                l.camera.updateProjectionMatrix()
                        }
                        if (null === l.map) {
                            const t = {
                                minFilter: ht,
                                magFilter: ht,
                                format: Pt
                            };
                            l.map = new yn(r.x,r.y,t),
                                l.map.texture.name = c.name + ".shadowMap",
                                l.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(l.map),
                            t.clear();
                        const f = l.getViewportCount();
                        for (let t = 0; t < f; t++) {
                            const e = l.getViewport(t);
                            s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                                d.viewport(s),
                                l.updateMatrices(c, t),
                                i = l.getFrustum(),
                                A(n, a, l.camera, c, this.type)
                        }
                        l.isPointLightShadow || this.type !== h || M(l, a),
                            l.needsUpdate = !1
                    }
                    w.needsUpdate = !1,
                        t.setRenderTarget(c, l, u)
                }
        }
        function Ul(t, e, n) {
            const i = n.isWebGL2;
            function r() {
                let e = !1;
                const n = new vn;
                let i = null;
                const r = new vn(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n),
                            i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, o, s, a) {
                        !0 === a && (e *= s,
                            i *= s,
                            o *= s),
                            n.set(e, i, o, s),
                        !1 === r.equals(n) && (t.clearColor(e, i, o, s),
                            r.copy(n))
                    },
                    reset: function() {
                        e = !1,
                            i = null,
                            r.set(-1, 0, 0, 0)
                    }
                }
            }
            function o() {
                let e = !1
                    , n = null
                    , i = null
                    , r = null;
                return {
                    setTest: function(t) {
                        t ? _t(2929) : xt(2929)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i),
                            n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            if (e)
                                switch (e) {
                                    case H:
                                        t.depthFunc(512);
                                        break;
                                    case B:
                                        t.depthFunc(519);
                                        break;
                                    case z:
                                        t.depthFunc(513);
                                        break;
                                    case U:
                                        t.depthFunc(515);
                                        break;
                                    case j:
                                        t.depthFunc(514);
                                        break;
                                    case G:
                                        t.depthFunc(518);
                                        break;
                                    case V:
                                        t.depthFunc(516);
                                        break;
                                    case W:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                }
                            else
                                t.depthFunc(515);
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                            r = e)
                    },
                    reset: function() {
                        e = !1,
                            n = null,
                            i = null,
                            r = null
                    }
                }
            }
            function l() {
                let e = !1
                    , n = null
                    , i = null
                    , r = null
                    , o = null
                    , s = null
                    , a = null
                    , c = null
                    , l = null;
                return {
                    setTest: function(t) {
                        e || (t ? _t(2960) : xt(2960))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i),
                            n = i)
                    },
                    setFunc: function(e, n, s) {
                        i === e && r === n && o === s || (t.stencilFunc(e, n, s),
                            i = e,
                            r = n,
                            o = s)
                    },
                    setOp: function(e, n, i) {
                        s === e && a === n && c === i || (t.stencilOp(e, n, i),
                            s = e,
                            a = n,
                            c = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        l !== e && (t.clearStencil(e),
                            l = e)
                    },
                    reset: function() {
                        e = !1,
                            n = null,
                            i = null,
                            r = null,
                            o = null,
                            s = null,
                            a = null,
                            c = null,
                            l = null
                    }
                }
            }
            const u = new r
                , h = new o
                , d = new l;
            let m = {}
                , q = null
                , X = {}
                , Y = null
                , Z = !1
                , J = null
                , K = null
                , Q = null
                , $ = null
                , tt = null
                , et = null
                , nt = null
                , it = !1
                , rt = null
                , ot = null
                , st = null
                , at = null
                , ct = null;
            const lt = t.getParameter(35661);
            let ut = !1
                , ht = 0;
            const dt = t.getParameter(7938);
            -1 !== dt.indexOf("WebGL") ? (ht = parseFloat(/^WebGL (\d)/.exec(dt)[1]),
                ut = ht >= 1) : -1 !== dt.indexOf("OpenGL ES") && (ht = parseFloat(/^OpenGL ES (\d)/.exec(dt)[1]),
                ut = ht >= 2);
            let pt = null
                , ft = {};
            const mt = new vn(0,0,t.canvas.width,t.canvas.height)
                , gt = new vn(0,0,t.canvas.width,t.canvas.height);
            function vt(e, n, i) {
                const r = new Uint8Array(4)
                    , o = t.createTexture();
                t.bindTexture(e, o),
                    t.texParameteri(e, 10241, 9728),
                    t.texParameteri(e, 10240, 9728);
                for (let s = 0; s < i; s++)
                    t.texImage2D(n + s, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return o
            }
            const yt = {};
            function _t(e) {
                !0 !== m[e] && (t.enable(e),
                    m[e] = !0)
            }
            function xt(e) {
                !1 !== m[e] && (t.disable(e),
                    m[e] = !1)
            }
            function bt(e) {
                e !== q && (t.bindFramebuffer(36160, e),
                    q = e)
            }
            function wt(e, n) {
                null === n && null !== q && (n = q),
                X[e] !== n && (t.bindFramebuffer(e, n),
                    X[e] = n)
            }
            function Mt(e) {
                return Y !== e && (t.useProgram(e),
                    Y = e,
                    !0)
            }
            yt[3553] = vt(3553, 3553, 1),
                yt[34067] = vt(34067, 34069, 6),
                u.setClear(0, 0, 0, 1),
                h.setClear(1),
                d.setClear(0),
                _t(2929),
                h.setFunc(U),
                Lt(!1),
                Rt(a),
                _t(2884),
                Tt(g);
            const St = {
                [w]: 32774,
                [M]: 32778,
                [S]: 32779
            };
            if (i)
                St[E] = 32775,
                    St[T] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (St[E] = t.MIN_EXT,
                    St[T] = t.MAX_EXT)
            }
            const Et = {
                [A]: 0,
                [L]: 1,
                [R]: 768,
                [P]: 770,
                [k]: 776,
                [D]: 774,
                [I]: 772,
                [C]: 769,
                [O]: 771,
                [F]: 775,
                [N]: 773
            };
            function Tt(e, n, i, r, o, s, a, c) {
                if (e !== g) {
                    if (!1 === Z && (_t(3042),
                        Z = !0),
                    e === b)
                        o = o || n,
                            s = s || i,
                            a = a || r,
                        n === K && o === tt || (t.blendEquationSeparate(St[n], St[o]),
                            K = n,
                            tt = o),
                        i === Q && r === $ && s === et && a === nt || (t.blendFuncSeparate(Et[i], Et[r], Et[s], Et[a]),
                            Q = i,
                            $ = r,
                            et = s,
                            nt = a),
                            J = e,
                            it = null;
                    else if (e !== J || c !== it) {
                        if (K === w && tt === w || (t.blendEquation(32774),
                            K = w,
                            tt = w),
                            c)
                            switch (e) {
                                case v:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case y:
                                    t.blendFunc(1, 1);
                                    break;
                                case _:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case x:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e);
                                    break
                            }
                        else
                            switch (e) {
                                case v:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case y:
                                    t.blendFunc(770, 1);
                                    break;
                                case _:
                                    t.blendFunc(0, 769);
                                    break;
                                case x:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e);
                                    break
                            }
                        Q = null,
                            $ = null,
                            et = null,
                            nt = null,
                            J = e,
                            it = c
                    }
                } else
                    !0 === Z && (xt(3042),
                        Z = !1)
            }
            function At(t, e) {
                t.side === f ? xt(2884) : _t(2884);
                let n = t.side === p;
                e && (n = !n),
                    Lt(n),
                    t.blending === v && !1 === t.transparent ? Tt(g) : Tt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                    h.setFunc(t.depthFunc),
                    h.setTest(t.depthTest),
                    h.setMask(t.depthWrite),
                    u.setMask(t.colorWrite);
                const i = t.stencilWrite;
                d.setTest(i),
                i && (d.setMask(t.stencilWriteMask),
                    d.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    d.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    Pt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? _t(32926) : xt(32926)
            }
            function Lt(e) {
                rt !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
                    rt = e)
            }
            function Rt(e) {
                e !== s ? (_t(2884),
                e !== ot && (e === a ? t.cullFace(1029) : e === c ? t.cullFace(1028) : t.cullFace(1032))) : xt(2884),
                    ot = e
            }
            function Ct(e) {
                e !== st && (ut && t.lineWidth(e),
                    st = e)
            }
            function Pt(e, n, i) {
                e ? (_t(32823),
                at === n && ct === i || (t.polygonOffset(n, i),
                    at = n,
                    ct = i)) : xt(32823)
            }
            function Ot(t) {
                t ? _t(3089) : xt(3089)
            }
            function It(e) {
                void 0 === e && (e = 33984 + lt - 1),
                pt !== e && (t.activeTexture(e),
                    pt = e)
            }
            function Nt(e, n) {
                null === pt && It();
                let i = ft[pt];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                    ft[pt] = i),
                i.type === e && i.texture === n || (t.bindTexture(e, n || yt[e]),
                    i.type = e,
                    i.texture = n)
            }
            function Dt() {
                const e = ft[pt];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
            }
            function Ft() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function kt() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Ht() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }
            function Bt(e) {
                !1 === mt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    mt.copy(e))
            }
            function zt(e) {
                !1 === gt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    gt.copy(e))
            }
            function Ut() {
                t.disable(3042),
                    t.disable(2884),
                    t.disable(2929),
                    t.disable(32823),
                    t.disable(3089),
                    t.disable(2960),
                    t.disable(32926),
                    t.blendEquation(32774),
                    t.blendFunc(1, 0),
                    t.blendFuncSeparate(1, 0, 1, 0),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(513),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(519, 0, 4294967295),
                    t.stencilOp(7680, 7680, 7680),
                    t.clearStencil(0),
                    t.cullFace(1029),
                    t.frontFace(2305),
                    t.polygonOffset(0, 0),
                    t.activeTexture(33984),
                    t.bindFramebuffer(36160, null),
                !0 === i && (t.bindFramebuffer(36009, null),
                    t.bindFramebuffer(36008, null)),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    m = {},
                    pt = null,
                    ft = {},
                    q = null,
                    X = {},
                    Y = null,
                    Z = !1,
                    J = null,
                    K = null,
                    Q = null,
                    $ = null,
                    tt = null,
                    et = null,
                    nt = null,
                    it = !1,
                    rt = null,
                    ot = null,
                    st = null,
                    at = null,
                    ct = null,
                    mt.set(0, 0, t.canvas.width, t.canvas.height),
                    gt.set(0, 0, t.canvas.width, t.canvas.height),
                    u.reset(),
                    h.reset(),
                    d.reset()
            }
            return {
                buffers: {
                    color: u,
                    depth: h,
                    stencil: d
                },
                enable: _t,
                disable: xt,
                bindFramebuffer: wt,
                bindXRFramebuffer: bt,
                useProgram: Mt,
                setBlending: Tt,
                setMaterial: At,
                setFlipSided: Lt,
                setCullFace: Rt,
                setLineWidth: Ct,
                setPolygonOffset: Pt,
                setScissorTest: Ot,
                activeTexture: It,
                bindTexture: Nt,
                unbindTexture: Dt,
                compressedTexImage2D: Ft,
                texImage2D: kt,
                texImage3D: Ht,
                scissor: Bt,
                viewport: zt,
                reset: Ut
            }
        }
        function jl(t, e, n, i, r, o, s) {
            const a = r.isWebGL2
                , c = r.maxTextures
                , l = r.maxCubemapSize
                , u = r.maxTextureSize
                , h = r.maxSamples
                , d = new WeakMap;
            let p, f = !1;
            try {
                f = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch ($) {}
            function m(t, e) {
                return f ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }
            function g(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
                r < 1 || !0 === e) {
                    if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? ln.floorPowerOfTwo : Math.floor
                            , o = i(r * t.width)
                            , s = i(r * t.height);
                        void 0 === p && (p = m(o, s));
                        const a = n ? m(o, s) : p;
                        a.width = o,
                            a.height = s;
                        const c = a.getContext("2d");
                        return c.drawImage(t, 0, 0, o, s),
                            console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."),
                            a
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                        t
                }
                return t
            }
            function v(t) {
                return ln.isPowerOfTwo(t.width) && ln.isPowerOfTwo(t.height)
            }
            function y(t) {
                return !a && (t.wrapS !== lt || t.wrapT !== lt || t.minFilter !== ht && t.minFilter !== ft)
            }
            function _(t, e) {
                return t.generateMipmaps && e && t.minFilter !== ht && t.minFilter !== ft
            }
            function x(e, n, r, o) {
                t.generateMipmap(e);
                const s = i.get(n);
                s.__maxMipLevel = Math.log2(Math.max(r, o))
            }
            function b(n, i, r) {
                if (!1 === a)
                    return i;
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let o = i;
                return 6403 === i && (5126 === r && (o = 33326),
                5131 === r && (o = 33325),
                5121 === r && (o = 33321)),
                6407 === i && (5126 === r && (o = 34837),
                5131 === r && (o = 34843),
                5121 === r && (o = 32849)),
                6408 === i && (5126 === r && (o = 34836),
                5131 === r && (o = 34842),
                5121 === r && (o = 32856)),
                33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"),
                    o
            }
            function w(t) {
                return t === ht || t === dt || t === pt ? 9728 : 9729
            }
            function M(t) {
                const e = t.target;
                e.removeEventListener("dispose", M),
                    E(e),
                e.isVideoTexture && d.delete(e),
                    s.memory.textures--
            }
            function S(t) {
                const e = t.target;
                e.removeEventListener("dispose", S),
                    T(e),
                    s.memory.textures--
            }
            function E(e) {
                const n = i.get(e);
                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture),
                    i.remove(e))
            }
            function T(e) {
                const n = e.texture
                    , r = i.get(e)
                    , o = i.get(n);
                if (e) {
                    if (void 0 !== o.__webglTexture && t.deleteTexture(o.__webglTexture),
                    e.depthTexture && e.depthTexture.dispose(),
                        e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++)
                            t.deleteFramebuffer(r.__webglFramebuffer[e]),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                    else
                        t.deleteFramebuffer(r.__webglFramebuffer),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    i.remove(n),
                        i.remove(e)
                }
            }
            let A = 0;
            function L() {
                A = 0
            }
            function R() {
                const t = A;
                return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c),
                    A += 1,
                    t
            }
            function C(t, e) {
                const r = i.get(t);
                if (t.isVideoTexture && Y(t),
                t.version > 0 && r.__version !== t.version) {
                    const n = t.image;
                    if (void 0 === n)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== n.complete)
                            return void H(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + e),
                    n.bindTexture(3553, r.__webglTexture)
            }
            function P(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? H(r, t, e) : (n.activeTexture(33984 + e),
                    n.bindTexture(35866, r.__webglTexture))
            }
            function O(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? H(r, t, e) : (n.activeTexture(33984 + e),
                    n.bindTexture(32879, r.__webglTexture))
            }
            function I(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? B(r, t, e) : (n.activeTexture(33984 + e),
                    n.bindTexture(34067, r.__webglTexture))
            }
            const N = {
                [ct]: 10497,
                [lt]: 33071,
                [ut]: 33648
            }
                , D = {
                [ht]: 9728,
                [dt]: 9984,
                [pt]: 9986,
                [ft]: 9729,
                [mt]: 9985,
                [gt]: 9987
            };
            function F(n, o, s) {
                if (s ? (t.texParameteri(n, 10242, N[o.wrapS]),
                    t.texParameteri(n, 10243, N[o.wrapT]),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, N[o.wrapR]),
                    t.texParameteri(n, 10240, D[o.magFilter]),
                    t.texParameteri(n, 10241, D[o.minFilter])) : (t.texParameteri(n, 10242, 33071),
                    t.texParameteri(n, 10243, 33071),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
                o.wrapS === lt && o.wrapT === lt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                    t.texParameteri(n, 10240, w(o.magFilter)),
                    t.texParameteri(n, 10241, w(o.minFilter)),
                o.minFilter !== ht && o.minFilter !== ft && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const s = e.get("EXT_texture_filter_anisotropic");
                    if (o.type === Mt && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === a && o.type === St && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
                        i.get(o).__currentAnisotropy = o.anisotropy)
                }
            }
            function k(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0,
                    n.addEventListener("dispose", M),
                    e.__webglTexture = t.createTexture(),
                    s.memory.textures++)
            }
            function H(e, i, r) {
                let s = 3553;
                i.isDataTexture2DArray && (s = 35866),
                i.isDataTexture3D && (s = 32879),
                    k(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(s, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                const c = y(i) && !1 === v(i.image)
                    , l = g(i.image, c, !1, u)
                    , h = v(l) || a
                    , d = o.convert(i.format);
                let p, f = o.convert(i.type), m = b(i.internalFormat, d, f);
                F(s, i, h);
                const w = i.mipmaps;
                if (i.isDepthTexture)
                    m = 6402,
                        a ? m = i.type === Mt ? 36012 : i.type === wt ? 33190 : i.type === Lt ? 35056 : 33189 : i.type === Mt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    i.format === Nt && 6402 === m && i.type !== xt && i.type !== wt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        i.type = xt,
                        f = o.convert(i.type)),
                    i.format === Dt && 6402 === m && (m = 34041,
                    i.type !== Lt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        i.type = Lt,
                        f = o.convert(i.type))),
                        n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                else if (i.isDataTexture)
                    if (w.length > 0 && h) {
                        for (let t = 0, e = w.length; t < e; t++)
                            p = w[t],
                                n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        i.generateMipmaps = !1,
                            e.__maxMipLevel = w.length - 1
                    } else
                        n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data),
                            e.__maxMipLevel = 0;
                else if (i.isCompressedTexture) {
                    for (let t = 0, e = w.length; t < e; t++)
                        p = w[t],
                            i.format !== Pt && i.format !== Ct ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    e.__maxMipLevel = w.length - 1
                } else if (i.isDataTexture2DArray)
                    n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
                        e.__maxMipLevel = 0;
                else if (i.isDataTexture3D)
                    n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
                        e.__maxMipLevel = 0;
                else if (w.length > 0 && h) {
                    for (let t = 0, e = w.length; t < e; t++)
                        p = w[t],
                            n.texImage2D(3553, t, m, d, f, p);
                    i.generateMipmaps = !1,
                        e.__maxMipLevel = w.length - 1
                } else
                    n.texImage2D(3553, 0, m, d, f, l),
                        e.__maxMipLevel = 0;
                _(i, h) && x(s, i, l.width, l.height),
                    e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }
            function B(e, i, r) {
                if (6 !== i.image.length)
                    return;
                k(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                    , c = i.image[0] && i.image[0].isDataTexture
                    , u = [];
                for (let t = 0; t < 6; t++)
                    u[t] = s || c ? c ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, l);
                const h = u[0]
                    , d = v(h) || a
                    , p = o.convert(i.format)
                    , f = o.convert(i.type)
                    , m = b(i.internalFormat, p, f);
                let y;
                if (F(34067, i, d),
                    s) {
                    for (let t = 0; t < 6; t++) {
                        y = u[t].mipmaps;
                        for (let e = 0; e < y.length; e++) {
                            const r = y[e];
                            i.format !== Pt && i.format !== Ct ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                        }
                    }
                    e.__maxMipLevel = y.length - 1
                } else {
                    y = i.mipmaps;
                    for (let t = 0; t < 6; t++)
                        if (c) {
                            n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                            for (let e = 0; e < y.length; e++) {
                                const i = y[e]
                                    , r = i.image[t].image;
                                n.texImage2D(34069 + t, e + 1, m, r.width, r.height, 0, p, f, r.data)
                            }
                        } else {
                            n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                            for (let e = 0; e < y.length; e++) {
                                const i = y[e];
                                n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                            }
                        }
                    e.__maxMipLevel = y.length
                }
                _(i, d) && x(34067, i, h.width, h.height),
                    e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }
            function z(e, r, s, a) {
                const c = r.texture
                    , l = o.convert(c.format)
                    , u = o.convert(c.type)
                    , h = b(c.internalFormat, l, u);
                32879 === a || 35866 === a ? n.texImage3D(a, 0, h, r.width, r.height, r.depth, 0, l, u, null) : n.texImage2D(a, 0, h, r.width, r.height, 0, l, u, null),
                    n.bindFramebuffer(36160, e),
                    t.framebufferTexture2D(36160, s, a, i.get(c).__webglTexture, 0),
                    n.bindFramebuffer(36160, null)
            }
            function U(e, n, i) {
                if (t.bindRenderbuffer(36161, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Mt ? r = 36012 : e.type === wt && (r = 33190));
                        const i = X(n);
                        t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        const e = X(n);
                        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, 34041, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = n.texture
                        , r = o.convert(e.format)
                        , s = o.convert(e.type)
                        , a = b(e.internalFormat, r, s);
                    if (i) {
                        const e = X(n);
                        t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, a, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }
            function j(e, r) {
                const o = r && r.isWebGLCubeRenderTarget;
                if (o)
                    throw new Error("Depth Texture with cube render targets is not supported");
                if (n.bindFramebuffer(36160, e),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                    r.depthTexture.image.height = r.height,
                    r.depthTexture.needsUpdate = !0),
                    C(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture;
                if (r.depthTexture.format === Nt)
                    t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                else {
                    if (r.depthTexture.format !== Dt)
                        throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                }
            }
            function G(e) {
                const r = i.get(e)
                    , o = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (o)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    j(r.__webglFramebuffer, e)
                } else if (o) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                            r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                            U(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                        r.__webglDepthbuffer = t.createRenderbuffer(),
                        U(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }
            function V(e) {
                const r = e.texture
                    , c = i.get(e)
                    , l = i.get(r);
                e.addEventListener("dispose", S),
                    l.__webglTexture = t.createTexture(),
                    l.__version = r.version,
                    s.memory.textures++;
                const u = !0 === e.isWebGLCubeRenderTarget
                    , h = !0 === e.isWebGLMultisampleRenderTarget
                    , d = r.isDataTexture3D || r.isDataTexture2DArray
                    , p = v(e) || a;
                if (!a || r.format !== Ct || r.type !== Mt && r.type !== St || (r.format = Pt,
                    console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
                    u) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        c.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (c.__webglFramebuffer = t.createFramebuffer(),
                    h)
                    if (a) {
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(),
                            c.__webglColorRenderbuffer = t.createRenderbuffer(),
                            t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                        const i = o.convert(r.format)
                            , s = o.convert(r.type)
                            , a = b(r.internalFormat, i, s)
                            , l = X(e);
                        t.renderbufferStorageMultisample(36161, l, a, e.width, e.height),
                            n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                            t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                            t.bindRenderbuffer(36161, null),
                        e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(),
                            U(c.__webglDepthRenderbuffer, e, !0)),
                            n.bindFramebuffer(36160, null)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (u) {
                    n.bindTexture(34067, l.__webglTexture),
                        F(34067, r, p);
                    for (let t = 0; t < 6; t++)
                        z(c.__webglFramebuffer[t], e, 36064, 34069 + t);
                    _(r, p) && x(34067, r, e.width, e.height),
                        n.bindTexture(34067, null)
                } else {
                    let t = 3553;
                    if (d)
                        if (a) {
                            const e = r.isDataTexture3D;
                            t = e ? 32879 : 35866
                        } else
                            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                    n.bindTexture(t, l.__webglTexture),
                        F(t, r, p),
                        z(c.__webglFramebuffer, e, 36064, t),
                    _(r, p) && x(3553, r, e.width, e.height),
                        n.bindTexture(3553, null)
                }
                e.depthBuffer && G(e)
            }
            function W(t) {
                const e = t.texture
                    , r = v(t) || a;
                if (_(e, r)) {
                    const r = t.isWebGLCubeRenderTarget ? 34067 : 3553
                        , o = i.get(e).__webglTexture;
                    n.bindTexture(r, o),
                        x(r, e, t.width, t.height),
                        n.bindTexture(r, null)
                }
            }
            function q(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (a) {
                        const r = i.get(e);
                        n.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                            n.bindFramebuffer(36009, r.__webglFramebuffer);
                        const o = e.width
                            , s = e.height;
                        let a = 16384;
                        e.depthBuffer && (a |= 256),
                        e.stencilBuffer && (a |= 1024),
                            t.blitFramebuffer(0, 0, o, s, 0, 0, o, s, a, 9728),
                            n.bindFramebuffer(36160, r.__webglMultisampledFramebuffer)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }
            function X(t) {
                return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
            }
            function Y(t) {
                const e = s.render.frame;
                d.get(t) !== e && (d.set(t, e),
                    t.update())
            }
            let Z = !1
                , J = !1;
            function K(t, e) {
                t && t.isWebGLRenderTarget && (!1 === Z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                    Z = !0),
                    t = t.texture),
                    C(t, e)
            }
            function Q(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === J && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                    J = !0),
                    t = t.texture),
                    I(t, e)
            }
            this.allocateTextureUnit = R,
                this.resetTextureUnits = L,
                this.setTexture2D = C,
                this.setTexture2DArray = P,
                this.setTexture3D = O,
                this.setTextureCube = I,
                this.setupRenderTarget = V,
                this.updateRenderTargetMipmap = W,
                this.updateMultisampleRenderTarget = q,
                this.safeSetTexture2D = K,
                this.safeSetTextureCube = Q
        }
        function Gl(t, e, n) {
            const i = n.isWebGL2;
            function r(t) {
                let n;
                if (t === vt)
                    return 5121;
                if (t === Et)
                    return 32819;
                if (t === Tt)
                    return 32820;
                if (t === At)
                    return 33635;
                if (t === yt)
                    return 5120;
                if (t === _t)
                    return 5122;
                if (t === xt)
                    return 5123;
                if (t === bt)
                    return 5124;
                if (t === wt)
                    return 5125;
                if (t === Mt)
                    return 5126;
                if (t === St)
                    return i ? 5131 : (n = e.get("OES_texture_half_float"),
                        null !== n ? n.HALF_FLOAT_OES : null);
                if (t === Rt)
                    return 6406;
                if (t === Ct)
                    return 6407;
                if (t === Pt)
                    return 6408;
                if (t === Ot)
                    return 6409;
                if (t === It)
                    return 6410;
                if (t === Nt)
                    return 6402;
                if (t === Dt)
                    return 34041;
                if (t === Ft)
                    return 6403;
                if (t === kt)
                    return 36244;
                if (t === Ht)
                    return 33319;
                if (t === Bt)
                    return 33320;
                if (t === zt)
                    return 36248;
                if (t === Ut)
                    return 36249;
                if (t === jt || t === Gt || t === Vt || t === Wt) {
                    if (n = e.get("WEBGL_compressed_texture_s3tc"),
                    null === n)
                        return null;
                    if (t === jt)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (t === Gt)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (t === Vt)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (t === Wt)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (t === qt || t === Xt || t === Yt || t === Zt) {
                    if (n = e.get("WEBGL_compressed_texture_pvrtc"),
                    null === n)
                        return null;
                    if (t === qt)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (t === Xt)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (t === Yt)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (t === Zt)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (t === Jt)
                    return n = e.get("WEBGL_compressed_texture_etc1"),
                        null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((t === Kt || t === Qt) && (n = e.get("WEBGL_compressed_texture_etc"),
                null !== n)) {
                    if (t === Kt)
                        return n.COMPRESSED_RGB8_ETC2;
                    if (t === Qt)
                        return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return t === $t || t === te || t === ee || t === ne || t === ie || t === re || t === oe || t === se || t === ae || t === ce || t === le || t === ue || t === he || t === de || t === fe || t === me || t === ge || t === ve || t === ye || t === _e || t === xe || t === be || t === we || t === Me || t === Se || t === Ee || t === Te || t === Ae ? (n = e.get("WEBGL_compressed_texture_astc"),
                    null !== n ? t : null) : t === pe ? (n = e.get("EXT_texture_compression_bptc"),
                    null !== n ? t : null) : t === Lt ? i ? 34042 : (n = e.get("WEBGL_depth_texture"),
                    null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
            return {
                convert: r
            }
        }
        class Vl extends Wr {
            constructor(t=[]) {
                super(),
                    this.cameras = t
            }
        }
        Vl.prototype.isArrayCamera = !0;
        class Wl extends Mi {
            constructor() {
                super(),
                    this.type = "Group"
            }
        }
        function ql() {
            this._targetRay = null,
                this._grip = null,
                this._hand = null
        }
        function Xl(t, e) {
            const n = this
                , i = t.state;
            let r = null
                , o = 1
                , s = null
                , a = "local-floor"
                , c = null;
            const l = []
                , u = new Map
                , h = new Wr;
            h.layers.enable(1),
                h.viewport = new vn;
            const d = new Wr;
            d.layers.enable(2),
                d.viewport = new vn;
            const p = [h, d]
                , f = new Vl;
            f.layers.enable(1),
                f.layers.enable(2);
            let m = null
                , g = null;
            function v(t) {
                const e = u.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                })
            }
            function y() {
                u.forEach((function(t, e) {
                        t.disconnect(e)
                    }
                )),
                    u.clear(),
                    m = null,
                    g = null,
                    i.bindXRFramebuffer(null),
                    t.setRenderTarget(t.getRenderTarget()),
                    T.stop(),
                    n.isPresenting = !1,
                    n.dispatchEvent({
                        type: "sessionend"
                    })
            }
            function _(t) {
                const e = r.inputSources;
                for (let n = 0; n < l.length; n++)
                    u.set(e[n], l[n]);
                for (let n = 0; n < t.removed.length; n++) {
                    const e = t.removed[n]
                        , i = u.get(e);
                    i && (i.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }),
                        u.delete(e))
                }
                for (let n = 0; n < t.added.length; n++) {
                    const e = t.added[n]
                        , i = u.get(e);
                    i && i.dispatchEvent({
                        type: "connected",
                        data: e
                    })
                }
            }
            this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new ql,
                        l[t] = e),
                        e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new ql,
                        l[t] = e),
                        e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new ql,
                        l[t] = e),
                        e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    o = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    a = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return s
                }
                ,
                this.getSession = function() {
                    return r
                }
                ,
                this.setSession = async function(t) {
                    if (r = t,
                    null !== r) {
                        r.addEventListener("select", v),
                            r.addEventListener("selectstart", v),
                            r.addEventListener("selectend", v),
                            r.addEventListener("squeeze", v),
                            r.addEventListener("squeezestart", v),
                            r.addEventListener("squeezeend", v),
                            r.addEventListener("end", y),
                            r.addEventListener("inputsourceschange", _);
                        const t = e.getContextAttributes();
                        !0 !== t.xrCompatible && await e.makeXRCompatible();
                        const i = {
                            antialias: t.antialias,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: o
                        }
                            , c = new XRWebGLLayer(r,e,i);
                        r.updateRenderState({
                            baseLayer: c
                        }),
                            s = await r.requestReferenceSpace(a),
                            T.setContext(r),
                            T.start(),
                            n.isPresenting = !0,
                            n.dispatchEvent({
                                type: "sessionstart"
                            })
                    }
                }
            ;
            const x = new bn
                , b = new bn;
            function w(t, e, n) {
                x.setFromMatrixPosition(e.matrixWorld),
                    b.setFromMatrixPosition(n.matrixWorld);
                const i = x.distanceTo(b)
                    , r = e.projectionMatrix.elements
                    , o = n.projectionMatrix.elements
                    , s = r[14] / (r[10] - 1)
                    , a = r[14] / (r[10] + 1)
                    , c = (r[9] + 1) / r[5]
                    , l = (r[9] - 1) / r[5]
                    , u = (r[8] - 1) / r[0]
                    , h = (o[8] + 1) / o[0]
                    , d = s * u
                    , p = s * h
                    , f = i / (-u + h)
                    , m = f * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const g = s + f
                    , v = a + f
                    , y = d - m
                    , _ = p + (i - m)
                    , w = c * a / v * g
                    , M = l * a / v * g;
                t.projectionMatrix.makePerspective(y, _, w, M, g, v)
            }
            function M(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.getCamera = function(t) {
                f.near = d.near = h.near = t.near,
                    f.far = d.far = h.far = t.far,
                m === f.near && g === f.far || (r.updateRenderState({
                    depthNear: f.near,
                    depthFar: f.far
                }),
                    m = f.near,
                    g = f.far);
                const e = t.parent
                    , n = f.cameras;
                M(f, e);
                for (let r = 0; r < n.length; r++)
                    M(n[r], e);
                t.matrixWorld.copy(f.matrixWorld),
                    t.matrix.copy(f.matrix),
                    t.matrix.decompose(t.position, t.quaternion, t.scale);
                const i = t.children;
                for (let r = 0, o = i.length; r < o; r++)
                    i[r].updateMatrixWorld(!0);
                return 2 === n.length ? w(f, h, d) : f.projectionMatrix.copy(h.projectionMatrix),
                    f
            }
            ;
            let S = null;
            function E(t, e) {
                if (c = e.getViewerPose(s),
                null !== c) {
                    const t = c.views
                        , e = r.renderState.baseLayer;
                    i.bindXRFramebuffer(e.framebuffer);
                    let n = !1;
                    t.length !== f.cameras.length && (f.cameras.length = 0,
                        n = !0);
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i]
                            , o = e.getViewport(r)
                            , s = p[i];
                        s.matrix.fromArray(r.transform.matrix),
                            s.projectionMatrix.fromArray(r.projectionMatrix),
                            s.viewport.set(o.x, o.y, o.width, o.height),
                        0 === i && f.matrix.copy(s.matrix),
                        !0 === n && f.cameras.push(s)
                    }
                }
                const n = r.inputSources;
                for (let i = 0; i < l.length; i++) {
                    const t = l[i]
                        , r = n[i];
                    t.update(r, e, s)
                }
                S && S(t, e)
            }
            const T = new eo;
            T.setAnimationLoop(E),
                this.setAnimationLoop = function(t) {
                    S = t
                }
                ,
                this.dispose = function() {}
        }
        function Yl(t) {
            function e(t, e) {
                t.fogColor.value.copy(e.color),
                    e.isFog ? (t.fogNear.value = e.near,
                        t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }
            function n(t, e, n, p) {
                e.isMeshBasicMaterial ? i(t, e) : e.isMeshLambertMaterial ? (i(t, e),
                    c(t, e)) : e.isMeshToonMaterial ? (i(t, e),
                    u(t, e)) : e.isMeshPhongMaterial ? (i(t, e),
                    l(t, e)) : e.isMeshStandardMaterial ? (i(t, e),
                    e.isMeshPhysicalMaterial ? d(t, e) : h(t, e)) : e.isMeshMatcapMaterial ? (i(t, e),
                    f(t, e)) : e.isMeshDepthMaterial ? (i(t, e),
                    m(t, e)) : e.isMeshDistanceMaterial ? (i(t, e),
                    g(t, e)) : e.isMeshNormalMaterial ? (i(t, e),
                    v(t, e)) : e.isLineBasicMaterial ? (r(t, e),
                e.isLineDashedMaterial && o(t, e)) : e.isPointsMaterial ? s(t, e, n, p) : e.isSpriteMaterial ? a(t, e) : e.isShadowMaterial ? (t.color.value.copy(e.color),
                    t.opacity.value = e.opacity) : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
            }
            function i(e, n) {
                e.opacity.value = n.opacity,
                n.color && e.diffuse.value.copy(n.color),
                n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                n.map && (e.map.value = n.map),
                n.alphaMap && (e.alphaMap.value = n.alphaMap),
                n.specularMap && (e.specularMap.value = n.specularMap);
                const i = t.get(n).envMap;
                if (i) {
                    e.envMap.value = i,
                        e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1,
                        e.reflectivity.value = n.reflectivity,
                        e.refractionRatio.value = n.refractionRatio;
                    const r = t.get(i).__maxMipLevel;
                    void 0 !== r && (e.maxMipLevel.value = r)
                }
                let r, o;
                n.lightMap && (e.lightMap.value = n.lightMap,
                    e.lightMapIntensity.value = n.lightMapIntensity),
                n.aoMap && (e.aoMap.value = n.aoMap,
                    e.aoMapIntensity.value = n.aoMapIntensity),
                    n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
                void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                    e.uvTransform.value.copy(r.matrix)),
                    n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap),
                void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture),
                !0 === o.matrixAutoUpdate && o.updateMatrix(),
                    e.uv2Transform.value.copy(o.matrix))
            }
            function r(t, e) {
                t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity
            }
            function o(t, e) {
                t.dashSize.value = e.dashSize,
                    t.totalSize.value = e.dashSize + e.gapSize,
                    t.scale.value = e.scale
            }
            function s(t, e, n, i) {
                let r;
                t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.size.value = e.size * n,
                    t.scale.value = .5 * i,
                e.map && (t.map.value = e.map),
                e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? r = e.map : e.alphaMap && (r = e.alphaMap),
                void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    t.uvTransform.value.copy(r.matrix))
            }
            function a(t, e) {
                let n;
                t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.rotation.value = e.rotation,
                e.map && (t.map.value = e.map),
                e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap),
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix))
            }
            function c(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }
            function l(t, e) {
                t.specular.value.copy(e.specular),
                    t.shininess.value = Math.max(e.shininess, 1e-4),
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                e.side === p && (t.bumpScale.value *= -1)),
                e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                e.side === p && t.normalScale.value.negate()),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
            }
            function u(t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap),
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                e.side === p && (t.bumpScale.value *= -1)),
                e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                e.side === p && t.normalScale.value.negate()),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
            }
            function h(e, n) {
                e.roughness.value = n.roughness,
                    e.metalness.value = n.metalness,
                n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
                n.bumpMap && (e.bumpMap.value = n.bumpMap,
                    e.bumpScale.value = n.bumpScale,
                n.side === p && (e.bumpScale.value *= -1)),
                n.normalMap && (e.normalMap.value = n.normalMap,
                    e.normalScale.value.copy(n.normalScale),
                n.side === p && e.normalScale.value.negate()),
                n.displacementMap && (e.displacementMap.value = n.displacementMap,
                    e.displacementScale.value = n.displacementScale,
                    e.displacementBias.value = n.displacementBias);
                const i = t.get(n).envMap;
                i && (e.envMapIntensity.value = n.envMapIntensity)
            }
            function d(t, e) {
                h(t, e),
                    t.reflectivity.value = e.reflectivity,
                    t.clearcoat.value = e.clearcoat,
                    t.clearcoatRoughness.value = e.clearcoatRoughness,
                e.sheen && t.sheen.value.copy(e.sheen),
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                e.side === p && t.clearcoatNormalScale.value.negate()),
                    t.transmission.value = e.transmission,
                e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
            }
            function f(t, e) {
                e.matcap && (t.matcap.value = e.matcap),
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                e.side === p && (t.bumpScale.value *= -1)),
                e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                e.side === p && t.normalScale.value.negate()),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
            }
            function m(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
            }
            function g(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias),
                    t.referencePosition.value.copy(e.referencePosition),
                    t.nearDistance.value = e.nearDistance,
                    t.farDistance.value = e.farDistance
            }
            function v(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                e.side === p && (t.bumpScale.value *= -1)),
                e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                e.side === p && t.normalScale.value.negate()),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
            }
            return {
                refreshFogUniforms: e,
                refreshMaterialUniforms: n
            }
        }
        function Zl() {
            const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return t.style.display = "block",
                t
        }
        function Jl(t) {
            t = t || {};
            const e = void 0 !== t.canvas ? t.canvas : Zl()
                , n = void 0 !== t.context ? t.context : null
                , i = void 0 !== t.alpha && t.alpha
                , r = void 0 === t.depth || t.depth
                , o = void 0 === t.stencil || t.stencil
                , s = void 0 !== t.antialias && t.antialias
                , a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
                , c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
                , l = void 0 !== t.powerPreference ? t.powerPreference : "default"
                , u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let h = null
                , d = null;
            const p = []
                , f = [];
            this.domElement = e,
                this.debug = {
                    checkShaderErrors: !0
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this.gammaFactor = 2,
                this.outputEncoding = je,
                this.physicallyCorrectLights = !1,
                this.toneMapping = Z,
                this.toneMappingExposure = 1;
            const m = this;
            let g = !1
                , v = 0
                , y = 0
                , _ = null
                , x = -1
                , b = null;
            const w = new vn
                , M = new vn;
            let S = null
                , E = e.width
                , T = e.height
                , A = 1
                , L = null
                , R = null;
            const C = new vn(0,0,E,T)
                , P = new vn(0,0,E,T);
            let O = !1;
            const I = new to;
            let N = !1
                , D = !1;
            const F = new Qn
                , k = new bn
                , H = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function B() {
                return null === _ ? A : 1
            }
            let z, U, j, G, V, W, q, X, Y, J, K, Q, $, tt, et, nt, it, rt, ot, st, at, ct, lt = n;
            function ut(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i]
                        , o = e.getContext(r, n);
                    if (null !== o)
                        return o
                }
                return null
            }
            try {
                const t = {
                    alpha: i,
                    depth: r,
                    stencil: o,
                    antialias: s,
                    premultipliedAlpha: a,
                    preserveDrawingBuffer: c,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: u
                };
                if (e.addEventListener("webglcontextlost", pt, !1),
                    e.addEventListener("webglcontextrestored", ft, !1),
                null === lt) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(),
                        lt = ut(e, t),
                    null === lt)
                        throw ut(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                )
            } catch (Ft) {
                throw console.error("THREE.WebGLRenderer: " + Ft.message),
                    Ft
            }
            function ht() {
                z = new Da(lt),
                    U = new Oa(lt,z,t),
                    z.init(U),
                    at = new Gl(lt,z,U),
                    j = new Ul(lt,z,U),
                    G = new Ha(lt),
                    V = new Sl,
                    W = new jl(lt,z,j,V,U,at,G),
                    q = new Na(m),
                    X = new no(lt,U),
                    ct = new Ca(lt,z,X,U),
                    Y = new Fa(lt,X,G,ct),
                    J = new ja(lt,Y,X,G),
                    rt = new Ua(lt),
                    et = new Ia(V),
                    K = new Ml(m,q,z,U,ct,et),
                    Q = new Yl(V),
                    $ = new Ll(V),
                    tt = new Dl(z,U),
                    it = new Ra(m,q,j,J,a),
                    nt = new zl(m,J,U),
                    ot = new Pa(lt,z,G,U),
                    st = new ka(lt,z,G,U),
                    G.programs = K.programs,
                    m.capabilities = U,
                    m.extensions = z,
                    m.properties = V,
                    m.renderLists = $,
                    m.shadowMap = nt,
                    m.state = j,
                    m.info = G
            }
            ht();
            const dt = new Xl(m,lt);
            function pt(t) {
                t.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    g = !0
            }
            function ft() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                    g = !1;
                const t = G.autoReset
                    , e = nt.enabled
                    , n = nt.autoUpdate
                    , i = nt.needsUpdate
                    , r = nt.type;
                ht(),
                    G.autoReset = t,
                    nt.enabled = e,
                    nt.autoUpdate = n,
                    nt.needsUpdate = i,
                    nt.type = r
            }
            function mt(t) {
                const e = t.target;
                e.removeEventListener("dispose", mt),
                    gt(e)
            }
            function gt(t) {
                yt(t),
                    V.remove(t)
            }
            function yt(t) {
                const e = V.get(t).programs;
                void 0 !== e && e.forEach((function(t) {
                        K.releaseProgram(t)
                    }
                ))
            }
            function _t(t, e) {
                t.render((function(t) {
                        m.renderBufferImmediate(t, e)
                    }
                ))
            }
            this.xr = dt,
                this.getContext = function() {
                    return lt
                }
                ,
                this.getContextAttributes = function() {
                    return lt.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const t = z.get("WEBGL_lose_context");
                    t && t.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const t = z.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return A
                }
                ,
                this.setPixelRatio = function(t) {
                    void 0 !== t && (A = t,
                        this.setSize(E, T, !1))
                }
                ,
                this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
                        t = new un),
                        t.set(E, T)
                }
                ,
                this.setSize = function(t, n, i) {
                    dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t,
                        T = n,
                        e.width = Math.floor(t * A),
                        e.height = Math.floor(n * A),
                    !1 !== i && (e.style.width = t + "px",
                        e.style.height = n + "px"),
                        this.setViewport(0, 0, t, n))
                }
                ,
                this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
                        t = new un),
                        t.set(E * A, T * A).floor()
                }
                ,
                this.setDrawingBufferSize = function(t, n, i) {
                    E = t,
                        T = n,
                        A = i,
                        e.width = Math.floor(t * i),
                        e.height = Math.floor(n * i),
                        this.setViewport(0, 0, t, n)
                }
                ,
                this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
                        t = new vn),
                        t.copy(w)
                }
                ,
                this.getViewport = function(t) {
                    return t.copy(C)
                }
                ,
                this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
                        j.viewport(w.copy(C).multiplyScalar(A).floor())
                }
                ,
                this.getScissor = function(t) {
                    return t.copy(P)
                }
                ,
                this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
                        j.scissor(M.copy(P).multiplyScalar(A).floor())
                }
                ,
                this.getScissorTest = function() {
                    return O
                }
                ,
                this.setScissorTest = function(t) {
                    j.setScissorTest(O = t)
                }
                ,
                this.setOpaqueSort = function(t) {
                    L = t
                }
                ,
                this.setTransparentSort = function(t) {
                    R = t
                }
                ,
                this.getClearColor = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
                        t = new Xi),
                        t.copy(it.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    it.setClearColor.apply(it, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return it.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    it.setClearAlpha.apply(it, arguments)
                }
                ,
                this.clear = function(t, e, n) {
                    let i = 0;
                    (void 0 === t || t) && (i |= 16384),
                    (void 0 === e || e) && (i |= 256),
                    (void 0 === n || n) && (i |= 1024),
                        lt.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    e.removeEventListener("webglcontextlost", pt, !1),
                        e.removeEventListener("webglcontextrestored", ft, !1),
                        $.dispose(),
                        tt.dispose(),
                        V.dispose(),
                        q.dispose(),
                        J.dispose(),
                        ct.dispose(),
                        dt.dispose(),
                        dt.removeEventListener("sessionstart", wt),
                        dt.removeEventListener("sessionend", Et),
                        Tt.stop()
                }
                ,
                this.renderBufferImmediate = function(t, e) {
                    ct.initAttributes();
                    const n = V.get(t);
                    t.hasPositions && !n.position && (n.position = lt.createBuffer()),
                    t.hasNormals && !n.normal && (n.normal = lt.createBuffer()),
                    t.hasUvs && !n.uv && (n.uv = lt.createBuffer()),
                    t.hasColors && !n.color && (n.color = lt.createBuffer());
                    const i = e.getAttributes();
                    t.hasPositions && (lt.bindBuffer(34962, n.position),
                        lt.bufferData(34962, t.positionArray, 35048),
                        ct.enableAttribute(i.position),
                        lt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                    t.hasNormals && (lt.bindBuffer(34962, n.normal),
                        lt.bufferData(34962, t.normalArray, 35048),
                        ct.enableAttribute(i.normal),
                        lt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                    t.hasUvs && (lt.bindBuffer(34962, n.uv),
                        lt.bufferData(34962, t.uvArray, 35048),
                        ct.enableAttribute(i.uv),
                        lt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                    t.hasColors && (lt.bindBuffer(34962, n.color),
                        lt.bufferData(34962, t.colorArray, 35048),
                        ct.enableAttribute(i.color),
                        lt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                        ct.disableUnusedAttributes(),
                        lt.drawArrays(4, 0, t.count),
                        t.count = 0
                }
                ,
                this.renderBufferDirect = function(t, e, n, i, r, o) {
                    null === e && (e = H);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0
                        , a = It(t, e, i, r);
                    j.setMaterial(i, s);
                    let c = n.index;
                    const l = n.attributes.position;
                    if (null === c) {
                        if (void 0 === l || 0 === l.count)
                            return
                    } else if (0 === c.count)
                        return;
                    let u, h = 1;
                    !0 === i.wireframe && (c = Y.getWireframeAttribute(n),
                        h = 2),
                    (i.morphTargets || i.morphNormals) && rt.update(r, n, i, a),
                        ct.setup(r, i, a, n, c);
                    let d = ot;
                    null !== c && (u = X.get(c),
                        d = st,
                        d.setIndex(u));
                    const p = null !== c ? c.count : l.count
                        , f = n.drawRange.start * h
                        , m = n.drawRange.count * h
                        , g = null !== o ? o.start * h : 0
                        , v = null !== o ? o.count * h : 1 / 0
                        , y = Math.max(f, g)
                        , _ = Math.min(p, f + m, g + v) - 1
                        , x = Math.max(0, _ - y + 1);
                    if (0 !== x) {
                        if (r.isMesh)
                            !0 === i.wireframe ? (j.setLineWidth(i.wireframeLinewidth * B()),
                                d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let t = i.linewidth;
                            void 0 === t && (t = 1),
                                j.setLineWidth(t * B()),
                                r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else
                            r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh)
                            d.renderInstances(y, x, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const t = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(y, x, t)
                        } else
                            d.render(y, x)
                    }
                }
                ,
                this.compile = function(t, e) {
                    d = tt.get(t),
                        d.init(),
                        t.traverseVisible((function(t) {
                                t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                                t.castShadow && d.pushShadow(t))
                            }
                        )),
                        d.setupLights(),
                        t.traverse((function(e) {
                                const n = e.material;
                                if (n)
                                    if (Array.isArray(n))
                                        for (let i = 0; i < n.length; i++) {
                                            const r = n[i];
                                            Ct(r, t, e)
                                        }
                                    else
                                        Ct(n, t, e)
                            }
                        ))
                }
            ;
            let xt = null;
            function bt(t) {
                xt && xt(t)
            }
            function wt() {
                Tt.stop()
            }
            function Et() {
                Tt.start()
            }
            const Tt = new eo;
            function At(t, e, n, i) {
                if (!1 === t.visible)
                    return;
                const r = t.layers.test(e.layers);
                if (r)
                    if (t.isGroup)
                        n = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        d.pushLight(t),
                        t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || I.intersectsSprite(t)) {
                            i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                            const e = J.update(t)
                                , r = t.material;
                            r.visible && h.push(t, e, r, n, k.z, null)
                        }
                    } else if (t.isImmediateRenderObject)
                        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F),
                            h.push(t, null, t.material, n, k.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== G.render.frame && (t.skeleton.update(),
                        t.skeleton.frame = G.render.frame),
                    !t.frustumCulled || I.intersectsObject(t))) {
                        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
                        const e = J.update(t)
                            , r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let o = 0, s = i.length; o < s; o++) {
                                const s = i[o]
                                    , a = r[s.materialIndex];
                                a && a.visible && h.push(t, e, a, n, k.z, s)
                            }
                        } else
                            r.visible && h.push(t, e, r, n, k.z, null)
                    }
                const o = t.children;
                for (let s = 0, a = o.length; s < a; s++)
                    At(o[s], e, n, i)
            }
            function Lt(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, o = t.length; r < o; r++) {
                    const o = t[r]
                        , s = o.object
                        , a = o.geometry
                        , c = null === i ? o.material : i
                        , l = o.group;
                    if (n.isArrayCamera) {
                        const t = n.cameras;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            s.layers.test(i.layers) && (j.viewport(w.copy(i.viewport)),
                                d.setupLightsView(i),
                                Rt(s, e, i, a, c, l))
                        }
                    } else
                        Rt(s, e, n, a, c, l)
                }
            }
            function Rt(t, e, n, i, r, o) {
                if (t.onBeforeRender(m, e, n, i, r, o),
                    t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                    t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                    t.isImmediateRenderObject) {
                    const i = It(n, e, r, t);
                    j.setMaterial(r),
                        ct.reset(),
                        _t(t, i)
                } else
                    m.renderBufferDirect(n, e, i, r, t, o);
                t.onAfterRender(m, e, n, i, r, o)
            }
            function Ct(t, e, n) {
                !0 !== e.isScene && (e = H);
                const i = V.get(t)
                    , r = d.state.lights
                    , o = d.state.shadowsArray
                    , s = r.state.version
                    , a = K.getParameters(t, r.state, o, e, n)
                    , c = K.getProgramCacheKey(a);
                let l = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null,
                    i.fog = e.fog,
                    i.envMap = q.get(t.envMap || i.environment),
                void 0 === l && (t.addEventListener("dispose", mt),
                    l = new Map,
                    i.programs = l);
                let u = l.get(c);
                if (void 0 !== u) {
                    if (i.currentProgram === u && i.lightsStateVersion === s)
                        return Ot(t, a),
                            u
                } else
                    a.uniforms = K.getUniforms(t),
                        t.onBeforeCompile(a, m),
                        u = K.acquireProgram(a, c),
                        l.set(c, u),
                        i.uniforms = a.uniforms;
                const h = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = et.uniform),
                    Ot(t, a),
                    i.needsLights = Dt(t),
                    i.lightsStateVersion = s,
                i.needsLights && (h.ambientLightColor.value = r.state.ambient,
                    h.lightProbe.value = r.state.probe,
                    h.directionalLights.value = r.state.directional,
                    h.directionalLightShadows.value = r.state.directionalShadow,
                    h.spotLights.value = r.state.spot,
                    h.spotLightShadows.value = r.state.spotShadow,
                    h.rectAreaLights.value = r.state.rectArea,
                    h.ltc_1.value = r.state.rectAreaLTC1,
                    h.ltc_2.value = r.state.rectAreaLTC2,
                    h.pointLights.value = r.state.point,
                    h.pointLightShadows.value = r.state.pointShadow,
                    h.hemisphereLights.value = r.state.hemi,
                    h.directionalShadowMap.value = r.state.directionalShadowMap,
                    h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    h.spotShadowMap.value = r.state.spotShadowMap,
                    h.spotShadowMatrix.value = r.state.spotShadowMatrix,
                    h.pointShadowMap.value = r.state.pointShadowMap,
                    h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = u.getUniforms()
                    , f = Yc.seqWithValue(p.seq, h);
                return i.currentProgram = u,
                    i.uniformsList = f,
                    u
            }
            function Ot(t, e) {
                const n = V.get(t);
                n.outputEncoding = e.outputEncoding,
                    n.instancing = e.instancing,
                    n.numClippingPlanes = e.numClippingPlanes,
                    n.numIntersection = e.numClipIntersection,
                    n.vertexAlphas = e.vertexAlphas
            }
            function It(t, e, n, i) {
                !0 !== e.isScene && (e = H),
                    W.resetTextureUnits();
                const r = e.fog
                    , o = n.isMeshStandardMaterial ? e.environment : null
                    , s = null === _ ? m.outputEncoding : _.texture.encoding
                    , a = q.get(n.envMap || o)
                    , c = !0 === n.vertexColors && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize
                    , l = V.get(n)
                    , u = d.state.lights;
                if (!0 === N && (!0 === D || t !== b)) {
                    const e = t === b && n.id === x;
                    et.setState(n, t, e)
                }
                let h = !1;
                n.version === l.__version ? l.needsLights && l.lightsStateVersion !== u.state.version || l.outputEncoding !== s || i.isInstancedMesh && !1 === l.instancing ? h = !0 : i.isInstancedMesh || !0 !== l.instancing ? l.envMap !== a || n.fog && l.fog !== r ? h = !0 : void 0 === l.numClippingPlanes || l.numClippingPlanes === et.numPlanes && l.numIntersection === et.numIntersection ? l.vertexAlphas !== c && (h = !0) : h = !0 : h = !0 : (h = !0,
                    l.__version = n.version);
                let p = l.currentProgram;
                !0 === h && (p = Ct(n, e, i));
                let f = !1
                    , g = !1
                    , v = !1;
                const y = p.getUniforms()
                    , w = l.uniforms;
                if (j.useProgram(p.program) && (f = !0,
                    g = !0,
                    v = !0),
                n.id !== x && (x = n.id,
                    g = !0),
                f || b !== t) {
                    if (y.setValue(lt, "projectionMatrix", t.projectionMatrix),
                    U.logarithmicDepthBuffer && y.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                    b !== t && (b = t,
                        g = !0,
                        v = !0),
                    n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        const e = y.map.cameraPosition;
                        void 0 !== e && e.setValue(lt, k.setFromMatrixPosition(t.matrixWorld))
                    }
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera),
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && y.setValue(lt, "viewMatrix", t.matrixWorldInverse)
                }
                if (n.skinning) {
                    y.setOptional(lt, i, "bindMatrix"),
                        y.setOptional(lt, i, "bindMatrixInverse");
                    const t = i.skeleton;
                    if (t) {
                        const e = t.bones;
                        if (U.floatVertexTextures) {
                            if (null === t.boneTexture) {
                                let n = Math.sqrt(4 * e.length);
                                n = ln.ceilPowerOfTwo(n),
                                    n = Math.max(n, 4);
                                const i = new Float32Array(n * n * 4);
                                i.set(t.boneMatrices);
                                const r = new Kr(i,n,n,Pt,Mt);
                                t.boneMatrices = i,
                                    t.boneTexture = r,
                                    t.boneTextureSize = n
                            }
                            y.setValue(lt, "boneTexture", t.boneTexture, W),
                                y.setValue(lt, "boneTextureSize", t.boneTextureSize)
                        } else
                            y.setOptional(lt, t, "boneMatrices")
                    }
                }
                return (g || l.receiveShadow !== i.receiveShadow) && (l.receiveShadow = i.receiveShadow,
                    y.setValue(lt, "receiveShadow", i.receiveShadow)),
                g && (y.setValue(lt, "toneMappingExposure", m.toneMappingExposure),
                l.needsLights && Nt(w, v),
                r && n.fog && Q.refreshFogUniforms(w, r),
                    Q.refreshMaterialUniforms(w, n, A, T),
                    Yc.upload(lt, l.uniformsList, w, W)),
                n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Yc.upload(lt, l.uniformsList, w, W),
                    n.uniformsNeedUpdate = !1),
                n.isSpriteMaterial && y.setValue(lt, "center", i.center),
                    y.setValue(lt, "modelViewMatrix", i.modelViewMatrix),
                    y.setValue(lt, "normalMatrix", i.normalMatrix),
                    y.setValue(lt, "modelMatrix", i.matrixWorld),
                    p
            }
            function Nt(t, e) {
                t.ambientLightColor.needsUpdate = e,
                    t.lightProbe.needsUpdate = e,
                    t.directionalLights.needsUpdate = e,
                    t.directionalLightShadows.needsUpdate = e,
                    t.pointLights.needsUpdate = e,
                    t.pointLightShadows.needsUpdate = e,
                    t.spotLights.needsUpdate = e,
                    t.spotLightShadows.needsUpdate = e,
                    t.rectAreaLights.needsUpdate = e,
                    t.hemisphereLights.needsUpdate = e
            }
            function Dt(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }
            Tt.setAnimationLoop(bt),
            "undefined" !== typeof window && Tt.setContext(window),
                this.setAnimationLoop = function(t) {
                    xt = t,
                        dt.setAnimationLoop(t),
                        null === t ? Tt.stop() : Tt.start()
                }
                ,
                dt.addEventListener("sessionstart", wt),
                dt.addEventListener("sessionend", Et),
                this.render = function(t, e) {
                    let n, i;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
                        n = arguments[2]),
                    void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
                        i = arguments[3]),
                    void 0 !== e && !0 !== e.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === g)
                        return;
                    !0 === t.autoUpdate && t.updateMatrixWorld(),
                    null === e.parent && e.updateMatrixWorld(),
                    !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)),
                    !0 === t.isScene && t.onBeforeRender(m, t, e, n || _),
                        d = tt.get(t, f.length),
                        d.init(),
                        f.push(d),
                        F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                        I.setFromProjectionMatrix(F),
                        D = this.localClippingEnabled,
                        N = et.init(this.clippingPlanes, D, e),
                        h = $.get(t, p.length),
                        h.init(),
                        p.push(h),
                        At(t, e, 0, m.sortObjects),
                        h.finish(),
                    !0 === m.sortObjects && h.sort(L, R),
                    !0 === N && et.beginShadows();
                    const r = d.state.shadowsArray;
                    nt.render(r, t, e),
                        d.setupLights(),
                        d.setupLightsView(e),
                    !0 === N && et.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    void 0 !== n && this.setRenderTarget(n),
                        it.render(h, t, e, i);
                    const o = h.opaque
                        , s = h.transparent;
                    o.length > 0 && Lt(o, t, e),
                    s.length > 0 && Lt(s, t, e),
                    null !== _ && (W.updateRenderTargetMipmap(_),
                        W.updateMultisampleRenderTarget(_)),
                    !0 === t.isScene && t.onAfterRender(m, t, e),
                        j.buffers.depth.setTest(!0),
                        j.buffers.depth.setMask(!0),
                        j.buffers.color.setMask(!0),
                        j.setPolygonOffset(!1),
                        ct.resetDefaultState(),
                        x = -1,
                        b = null,
                        f.pop(),
                        d = f.length > 0 ? f[f.length - 1] : null,
                        p.pop(),
                        h = p.length > 0 ? p[p.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return v
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return y
                }
                ,
                this.getRenderTarget = function() {
                    return _
                }
                ,
                this.setRenderTarget = function(t, e=0, n=0) {
                    _ = t,
                        v = e,
                        y = n,
                    t && void 0 === V.get(t).__webglFramebuffer && W.setupRenderTarget(t);
                    let i = null
                        , r = !1
                        , o = !1;
                    if (t) {
                        const n = t.texture;
                        (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
                        const s = V.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (i = s[e],
                            r = !0) : i = t.isWebGLMultisampleRenderTarget ? V.get(t).__webglMultisampledFramebuffer : s,
                            w.copy(t.viewport),
                            M.copy(t.scissor),
                            S = t.scissorTest
                    } else
                        w.copy(C).multiplyScalar(A).floor(),
                            M.copy(P).multiplyScalar(A).floor(),
                            S = O;
                    if (j.bindFramebuffer(36160, i),
                        j.viewport(w),
                        j.scissor(M),
                        j.setScissorTest(S),
                        r) {
                        const i = V.get(t.texture);
                        lt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                    } else if (o) {
                        const i = V.get(t.texture)
                            , r = e || 0;
                        lt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                    }
                }
                ,
                this.readRenderTargetPixels = function(t, e, n, i, r, o, s) {
                    if (!t || !t.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = V.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]),
                        a) {
                        j.bindFramebuffer(36160, a);
                        try {
                            const s = t.texture
                                , a = s.format
                                , c = s.type;
                            if (a !== Pt && at.convert(a) !== lt.getParameter(35739))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const l = c === St && (z.has("EXT_color_buffer_half_float") || U.isWebGL2 && z.has("EXT_color_buffer_float"));
                            if (c !== vt && at.convert(c) !== lt.getParameter(35738) && (c !== Mt || !(U.isWebGL2 || z.has("OES_texture_float") || z.has("WEBGL_color_buffer_float"))) && !l)
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && lt.readPixels(e, n, i, r, at.convert(a), at.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            const t = null !== _ ? V.get(_).__webglFramebuffer : null;
                            j.bindFramebuffer(36160, t)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(t, e, n=0) {
                    const i = Math.pow(2, -n)
                        , r = Math.floor(e.image.width * i)
                        , o = Math.floor(e.image.height * i)
                        , s = at.convert(e.format);
                    W.setTexture2D(e, 0),
                        lt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
                        j.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(t, e, n, i=0) {
                    const r = e.image.width
                        , o = e.image.height
                        , s = at.convert(n.format)
                        , a = at.convert(n.type);
                    W.setTexture2D(n, 0),
                        lt.pixelStorei(37440, n.flipY),
                        lt.pixelStorei(37441, n.premultiplyAlpha),
                        lt.pixelStorei(3317, n.unpackAlignment),
                        e.isDataTexture ? lt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : lt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
                    0 === i && n.generateMipmaps && lt.generateMipmap(3553),
                        j.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(t, e, n, i, r=0) {
                    if (m.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const {width: o, height: s, data: a} = n.image
                        , c = at.convert(i.format)
                        , l = at.convert(i.type);
                    let u;
                    if (i.isDataTexture3D)
                        W.setTexture3D(i, 0),
                            u = 32879;
                    else {
                        if (!i.isDataTexture2DArray)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        W.setTexture2DArray(i, 0),
                            u = 35866
                    }
                    lt.pixelStorei(37440, i.flipY),
                        lt.pixelStorei(37441, i.premultiplyAlpha),
                        lt.pixelStorei(3317, i.unpackAlignment);
                    const h = lt.getParameter(3314)
                        , d = lt.getParameter(32878)
                        , p = lt.getParameter(3316)
                        , f = lt.getParameter(3315)
                        , g = lt.getParameter(32877);
                    lt.pixelStorei(3314, o),
                        lt.pixelStorei(32878, s),
                        lt.pixelStorei(3316, t.min.x),
                        lt.pixelStorei(3315, t.min.y),
                        lt.pixelStorei(32877, t.min.z),
                        lt.texSubImage3D(u, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, c, l, a),
                        lt.pixelStorei(3314, h),
                        lt.pixelStorei(32878, d),
                        lt.pixelStorei(3316, p),
                        lt.pixelStorei(3315, f),
                        lt.pixelStorei(32877, g),
                    0 === r && i.generateMipmaps && lt.generateMipmap(u),
                        j.unbindTexture()
                }
                ,
                this.initTexture = function(t) {
                    W.setTexture2D(t, 0),
                        j.unbindTexture()
                }
                ,
                this.resetState = function() {
                    v = 0,
                        y = 0,
                        _ = null,
                        j.reset(),
                        ct.reset()
                }
                ,
            "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        Wl.prototype.isGroup = !0,
            Object.assign(ql.prototype, {
                constructor: ql,
                getHandSpace: function() {
                    return null === this._hand && (this._hand = new Wl,
                        this._hand.matrixAutoUpdate = !1,
                        this._hand.visible = !1,
                        this._hand.joints = {},
                        this._hand.inputState = {
                            pinching: !1
                        }),
                        this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new Wl,
                        this._targetRay.matrixAutoUpdate = !1,
                        this._targetRay.visible = !1),
                        this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new Wl,
                        this._grip.matrixAutoUpdate = !1,
                        this._grip.visible = !1),
                        this._grip
                },
                dispatchEvent: function(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                    null !== this._grip && this._grip.dispatchEvent(t),
                    null !== this._hand && this._hand.dispatchEvent(t),
                        this
                },
                disconnect: function(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }),
                    null !== this._targetRay && (this._targetRay.visible = !1),
                    null !== this._grip && (this._grip.visible = !1),
                    null !== this._hand && (this._hand.visible = !1),
                        this
                },
                update: function(t, e, n) {
                    let i = null
                        , r = null
                        , o = null;
                    const s = this._targetRay
                        , a = this._grip
                        , c = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState)
                        if (null !== s && (i = e.getPose(t.targetRaySpace, n),
                        null !== i && (s.matrix.fromArray(i.transform.matrix),
                            s.matrix.decompose(s.position, s.rotation, s.scale))),
                        c && t.hand) {
                            o = !0;
                            for (const o of t.hand.values()) {
                                const t = e.getJointPose(o, n);
                                if (void 0 === c.joints[o.jointName]) {
                                    const t = new Wl;
                                    t.matrixAutoUpdate = !1,
                                        t.visible = !1,
                                        c.joints[o.jointName] = t,
                                        c.add(t)
                                }
                                const i = c.joints[o.jointName];
                                null !== t && (i.matrix.fromArray(t.transform.matrix),
                                    i.matrix.decompose(i.position, i.rotation, i.scale),
                                    i.jointRadius = t.radius),
                                    i.visible = null !== t
                            }
                            const i = c.joints["index-finger-tip"]
                                , r = c.joints["thumb-tip"]
                                , s = i.position.distanceTo(r.position)
                                , a = .02
                                , l = .005;
                            c.inputState.pinching && s > a + l ? (c.inputState.pinching = !1,
                                this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !c.inputState.pinching && s <= a - l && (c.inputState.pinching = !0,
                                this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                        } else
                            null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                            null !== r && (a.matrix.fromArray(r.transform.matrix),
                                a.matrix.decompose(a.position, a.rotation, a.scale)));
                    return null !== s && (s.visible = null !== i),
                    null !== a && (a.visible = null !== r),
                    null !== c && (c.visible = null !== o),
                        this
                }
            }),
            Object.assign(Xl.prototype, sn.prototype);
        class Kl extends Jl {
        }
        Kl.prototype.isWebGL1Renderer = !0;
        class Ql {
            constructor(t, e=25e-5) {
                this.name = "",
                    this.color = new Xi(t),
                    this.density = e
            }
            clone() {
                return new Ql(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        Ql.prototype.isFogExp2 = !0;
        class $l {
            constructor(t, e=1, n=1e3) {
                this.name = "",
                    this.color = new Xi(t),
                    this.near = e,
                    this.far = n
            }
            clone() {
                return new $l(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        $l.prototype.isFog = !0;
        class tu extends Mi {
            constructor() {
                super(),
                    this.type = "Scene",
                    this.background = null,
                    this.environment = null,
                    this.fog = null,
                    this.overrideMaterial = null,
                    this.autoUpdate = !0,
                "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                    this.autoUpdate = t.autoUpdate,
                    this.matrixAutoUpdate = t.matrixAutoUpdate,
                    this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)),
                null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
                null !== this.fog && (e.object.fog = this.fog.toJSON()),
                    e
            }
        }
        function eu(t, e) {
            this.array = t,
                this.stride = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.usage = nn,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = ln.generateUUID()
        }
        tu.prototype.isScene = !0,
            Object.defineProperty(eu.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }),
            Object.assign(eu.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t,
                        this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array),
                        this.count = t.count,
                        this.stride = t.stride,
                        this.usage = t.usage,
                        this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride,
                        n *= e.stride;
                    for (let i = 0, r = this.stride; i < r; i++)
                        this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e=0) {
                    return this.array.set(t, e),
                        this
                },
                clone: function(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln.generateUUID()),
                    void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                        , n = new eu(e,this.stride);
                    return n.setUsage(this.usage),
                        n
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t,
                        this
                },
                toJSON: function(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ln.generateUUID()),
                    void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                        {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                }
            });
        const nu = new bn;
        function iu(t, e, n, i) {
            this.name = "",
                this.data = t,
                this.itemSize = e,
                this.offset = n,
                this.normalized = !0 === i
        }
        Object.defineProperties(iu.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            },
            needsUpdate: {
                set: function(t) {
                    this.data.needsUpdate = t
                }
            }
        }),
            Object.assign(iu.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.data.count; e < n; e++)
                        nu.x = this.getX(e),
                            nu.y = this.getY(e),
                            nu.z = this.getZ(e),
                            nu.applyMatrix4(t),
                            this.setXYZ(e, nu.x, nu.y, nu.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        nu.x = this.getX(e),
                            nu.y = this.getY(e),
                            nu.z = this.getZ(e),
                            nu.applyNormalMatrix(t),
                            this.setXYZ(e, nu.x, nu.y, nu.z);
                    return this
                },
                transformDirection: function(t) {
                    for (let e = 0, n = this.count; e < n; e++)
                        nu.x = this.getX(e),
                            nu.y = this.getY(e),
                            nu.z = this.getZ(e),
                            nu.transformDirection(t),
                            this.setXYZ(e, nu.x, nu.y, nu.z);
                    return this
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e,
                        this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e,
                        this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e,
                        this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e,
                        this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = n,
                        this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = n,
                        this.data.array[t + 2] = i,
                        this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = n,
                        this.data.array[t + 2] = i,
                        this.data.array[t + 3] = r,
                        this
                },
                clone: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++)
                                t.push(this.data.array[n + e])
                        }
                        return new Ki(new this.array.constructor(t),this.itemSize,this.normalized)
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                    void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                        new iu(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                },
                toJSON: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++)
                                t.push(this.data.array[n + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                    void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                        {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }
                }
            });
        class ru extends zi {
            constructor(t) {
                super(),
                    this.type = "SpriteMaterial",
                    this.color = new Xi(16777215),
                    this.map = null,
                    this.alphaMap = null,
                    this.rotation = 0,
                    this.sizeAttenuation = !0,
                    this.transparent = !0,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.alphaMap = t.alphaMap,
                    this.rotation = t.rotation,
                    this.sizeAttenuation = t.sizeAttenuation,
                    this
            }
        }
        let ou;
        ru.prototype.isSpriteMaterial = !0;
        const su = new bn
            , au = new bn
            , cu = new bn
            , lu = new un
            , uu = new un
            , hu = new Qn
            , du = new bn
            , pu = new bn
            , fu = new bn
            , mu = new un
            , gu = new un
            , vu = new un;
        class yu extends Mi {
            constructor(t) {
                if (super(),
                    this.type = "Sprite",
                void 0 === ou) {
                    ou = new gr;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                        , e = new eu(t,5);
                    ou.setIndex([0, 1, 2, 0, 2, 3]),
                        ou.setAttribute("position", new iu(e,3,0,!1)),
                        ou.setAttribute("uv", new iu(e,2,3,!1))
                }
                this.geometry = ou,
                    this.material = void 0 !== t ? t : new ru,
                    this.center = new un(.5,.5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                    au.setFromMatrixScale(this.matrixWorld),
                    hu.copy(t.camera.matrixWorld),
                    this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                    cu.setFromMatrixPosition(this.modelViewMatrix),
                t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && au.multiplyScalar(-cu.z);
                const n = this.material.rotation;
                let i, r;
                0 !== n && (r = Math.cos(n),
                    i = Math.sin(n));
                const o = this.center;
                _u(du.set(-.5, -.5, 0), cu, o, au, i, r),
                    _u(pu.set(.5, -.5, 0), cu, o, au, i, r),
                    _u(fu.set(.5, .5, 0), cu, o, au, i, r),
                    mu.set(0, 0),
                    gu.set(1, 0),
                    vu.set(1, 1);
                let s = t.ray.intersectTriangle(du, pu, fu, !1, su);
                if (null === s && (_u(pu.set(-.5, .5, 0), cu, o, au, i, r),
                    gu.set(0, 1),
                    s = t.ray.intersectTriangle(du, fu, pu, !1, su),
                null === s))
                    return;
                const a = t.ray.origin.distanceTo(su);
                a < t.near || a > t.far || e.push({
                    distance: a,
                    point: su.clone(),
                    uv: Hi.getUV(su, du, pu, fu, mu, gu, vu, new un),
                    face: null,
                    object: this
                })
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.center && this.center.copy(t.center),
                    this.material = t.material,
                    this
            }
        }
        function _u(t, e, n, i, r, o) {
            lu.subVectors(t, n).addScalar(.5).multiply(i),
                void 0 !== r ? (uu.x = o * lu.x - r * lu.y,
                    uu.y = r * lu.x + o * lu.y) : uu.copy(lu),
                t.copy(e),
                t.x += uu.x,
                t.y += uu.y,
                t.applyMatrix4(hu)
        }
        yu.prototype.isSprite = !0;
        const xu = new bn
            , bu = new vn
            , wu = new vn
            , Mu = new bn
            , Su = new Qn;
        function Eu(t, e) {
            Nr.call(this, t, e),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new Qn,
                this.bindMatrixInverse = new Qn
        }
        function Tu() {
            Mi.call(this),
                this.type = "Bone"
        }
        Eu.prototype = Object.assign(Object.create(Nr.prototype), {
            constructor: Eu,
            isSkinnedMesh: !0,
            copy: function(t) {
                return Nr.prototype.copy.call(this, t),
                    this.bindMode = t.bindMode,
                    this.bindMatrix.copy(t.bindMatrix),
                    this.bindMatrixInverse.copy(t.bindMatrixInverse),
                    this.skeleton = t.skeleton,
                    this
            },
            bind: function(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                    this.skeleton.calculateInverses(),
                    e = this.matrixWorld),
                    this.bindMatrix.copy(e),
                    this.bindMatrixInverse.copy(e).invert()
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                const t = new vn
                    , e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.x = e.getX(n),
                        t.y = e.getY(n),
                        t.z = e.getZ(n),
                        t.w = e.getW(n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                        e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function(t) {
                Nr.prototype.updateMatrixWorld.call(this, t),
                    "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            boneTransform: function(t, e) {
                const n = this.skeleton
                    , i = this.geometry;
                bu.fromBufferAttribute(i.attributes.skinIndex, t),
                    wu.fromBufferAttribute(i.attributes.skinWeight, t),
                    xu.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix),
                    e.set(0, 0, 0);
                for (let r = 0; r < 4; r++) {
                    const t = wu.getComponent(r);
                    if (0 !== t) {
                        const i = bu.getComponent(r);
                        Su.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                            e.addScaledVector(Mu.copy(xu).applyMatrix4(Su), t)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }),
            Tu.prototype = Object.assign(Object.create(Mi.prototype), {
                constructor: Tu,
                isBone: !0
            });
        const Au = new Qn
            , Lu = new Qn;
        class Ru {
            constructor(t=[], e=[]) {
                this.uuid = ln.generateUUID(),
                    this.bones = t.slice(0),
                    this.boneInverses = e,
                    this.boneMatrices = null,
                    this.boneTexture = null,
                    this.boneTextureSize = 0,
                    this.frame = -1,
                    this.init()
            }
            init() {
                const t = this.bones
                    , e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length),
                0 === e.length)
                    this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                        this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new Qn)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Qn;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                        this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                        e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                        e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones
                    , e = this.boneInverses
                    , n = this.boneMatrices
                    , i = this.boneTexture;
                for (let r = 0, o = t.length; r < o; r++) {
                    const i = t[r] ? t[r].matrixWorld : Lu;
                    Au.multiplyMatrices(i, e[r]),
                        Au.toArray(n, 16 * r)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Ru(this.bones,this.boneInverses)
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                    this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    const i = t.bones[n];
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                        r = new Tu),
                        this.bones.push(r),
                        this.boneInverses.push((new Qn).fromArray(t.boneInverses[n]))
                }
                return this.init(),
                    this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones
                    , n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const o = n[i];
                    t.boneInverses.push(o.toArray())
                }
                return t
            }
        }
        const Cu = new Qn
            , Pu = new Qn
            , Ou = []
            , Iu = new Nr;
        function Nu(t, e, n) {
            Nr.call(this, t, e),
                this.instanceMatrix = new Ki(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.frustumCulled = !1
        }
        Nu.prototype = Object.assign(Object.create(Nr.prototype), {
            constructor: Nu,
            isInstancedMesh: !0,
            copy: function(t) {
                return Nr.prototype.copy.call(this, t),
                    this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                    this.count = t.count,
                    this
            },
            getColorAt: function(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            },
            getMatrixAt: function(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            },
            raycast: function(t, e) {
                const n = this.matrixWorld
                    , i = this.count;
                if (Iu.geometry = this.geometry,
                    Iu.material = this.material,
                void 0 !== Iu.material)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Cu),
                            Pu.multiplyMatrices(n, Cu),
                            Iu.matrixWorld = Pu,
                            Iu.raycast(t, Ou);
                        for (let t = 0, n = Ou.length; t < n; t++) {
                            const n = Ou[t];
                            n.instanceId = r,
                                n.object = this,
                                e.push(n)
                        }
                        Ou.length = 0
                    }
            },
            setColorAt: function(t, e) {
                null === this.instanceColor && (this.instanceColor = new Ki(new Float32Array(3 * this.count),3)),
                    e.toArray(this.instanceColor.array, 3 * t)
            },
            setMatrixAt: function(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            },
            updateMorphTargets: function() {},
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        class Du extends zi {
            constructor(t) {
                super(),
                    this.type = "LineBasicMaterial",
                    this.color = new Xi(16777215),
                    this.linewidth = 1,
                    this.linecap = "round",
                    this.linejoin = "round",
                    this.morphTargets = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.linewidth = t.linewidth,
                    this.linecap = t.linecap,
                    this.linejoin = t.linejoin,
                    this.morphTargets = t.morphTargets,
                    this
            }
        }
        Du.prototype.isLineBasicMaterial = !0;
        const Fu = new bn
            , ku = new bn
            , Hu = new Qn
            , Bu = new Kn
            , zu = new Gn;
        function Uu(t=new gr, e=new Du) {
            Mi.call(this),
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
        }
        Uu.prototype = Object.assign(Object.create(Mi.prototype), {
            constructor: Uu,
            isLine: !0,
            copy: function(t) {
                return Mi.prototype.copy.call(this, t),
                    this.material = t.material,
                    this.geometry = t.geometry,
                    this
            },
            computeLineDistances: function() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                            , n = [0];
                        for (let t = 1, i = e.count; t < i; t++)
                            Fu.fromBufferAttribute(e, t - 1),
                                ku.fromBufferAttribute(e, t),
                                n[t] = n[t - 1],
                                n[t] += Fu.distanceTo(ku);
                        t.setAttribute("lineDistance", new sr(n,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            },
            raycast: function(t, e) {
                const n = this.geometry
                    , i = this.matrixWorld
                    , r = t.params.Line.threshold
                    , o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                    zu.copy(n.boundingSphere),
                    zu.applyMatrix4(i),
                    zu.radius += r,
                !1 === t.ray.intersectsSphere(zu))
                    return;
                Hu.copy(i).invert(),
                    Bu.copy(t.ray).applyMatrix4(Hu);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                    , a = s * s
                    , c = new bn
                    , l = new bn
                    , u = new bn
                    , h = new bn
                    , d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const i = n.index
                        , r = n.attributes
                        , s = r.position;
                    if (null !== i) {
                        const n = Math.max(0, o.start)
                            , r = Math.min(i.count, o.start + o.count);
                        for (let o = n, p = r - 1; o < p; o += d) {
                            const n = i.getX(o)
                                , r = i.getX(o + 1);
                            c.fromBufferAttribute(s, n),
                                l.fromBufferAttribute(s, r);
                            const d = Bu.distanceSqToSegment(c, l, h, u);
                            if (d > a)
                                continue;
                            h.applyMatrix4(this.matrixWorld);
                            const p = t.ray.origin.distanceTo(h);
                            p < t.near || p > t.far || e.push({
                                distance: p,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: o,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        const n = Math.max(0, o.start)
                            , i = Math.min(s.count, o.start + o.count);
                        for (let r = n, o = i - 1; r < o; r += d) {
                            c.fromBufferAttribute(s, r),
                                l.fromBufferAttribute(s, r + 1);
                            const n = Bu.distanceSqToSegment(c, l, h, u);
                            if (n > a)
                                continue;
                            h.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(h);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: r,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else
                    n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                        , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        });
        const ju = new bn
            , Gu = new bn;
        function Vu(t, e) {
            Uu.call(this, t, e),
                this.type = "LineSegments"
        }
        Vu.prototype = Object.assign(Object.create(Uu.prototype), {
            constructor: Vu,
            isLineSegments: !0,
            computeLineDistances: function() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                            , n = [];
                        for (let t = 0, i = e.count; t < i; t += 2)
                            ju.fromBufferAttribute(e, t),
                                Gu.fromBufferAttribute(e, t + 1),
                                n[t] = 0 === t ? 0 : n[t - 1],
                                n[t + 1] = n[t] + ju.distanceTo(Gu);
                        t.setAttribute("lineDistance", new sr(n,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        });
        class Wu extends Uu {
            constructor(t, e) {
                super(t, e),
                    this.type = "LineLoop"
            }
        }
        Wu.prototype.isLineLoop = !0;
        class qu extends zi {
            constructor(t) {
                super(),
                    this.type = "PointsMaterial",
                    this.color = new Xi(16777215),
                    this.map = null,
                    this.alphaMap = null,
                    this.size = 1,
                    this.sizeAttenuation = !0,
                    this.morphTargets = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.alphaMap = t.alphaMap,
                    this.size = t.size,
                    this.sizeAttenuation = t.sizeAttenuation,
                    this.morphTargets = t.morphTargets,
                    this
            }
        }
        qu.prototype.isPointsMaterial = !0;
        const Xu = new Qn
            , Yu = new Kn
            , Zu = new Gn
            , Ju = new bn;
        function Ku(t=new gr, e=new qu) {
            Mi.call(this),
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
        }
        function Qu(t, e, n, i, r, o, s) {
            const a = Yu.distanceSqToPoint(t);
            if (a < n) {
                const n = new bn;
                Yu.closestPointToPoint(t, n),
                    n.applyMatrix4(i);
                const c = r.ray.origin.distanceTo(n);
                if (c < r.near || c > r.far)
                    return;
                o.push({
                    distance: c,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: s
                })
            }
        }
        Ku.prototype = Object.assign(Object.create(Mi.prototype), {
            constructor: Ku,
            isPoints: !0,
            copy: function(t) {
                return Mi.prototype.copy.call(this, t),
                    this.material = t.material,
                    this.geometry = t.geometry,
                    this
            },
            raycast: function(t, e) {
                const n = this.geometry
                    , i = this.matrixWorld
                    , r = t.params.Points.threshold
                    , o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Zu.copy(n.boundingSphere),
                    Zu.applyMatrix4(i),
                    Zu.radius += r,
                !1 === t.ray.intersectsSphere(Zu))
                    return;
                Xu.copy(i).invert(),
                    Yu.copy(t.ray).applyMatrix4(Xu);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                    , a = s * s;
                if (n.isBufferGeometry) {
                    const r = n.index
                        , s = n.attributes
                        , c = s.position;
                    if (null !== r) {
                        const n = Math.max(0, o.start)
                            , s = Math.min(r.count, o.start + o.count);
                        for (let o = n, l = s; o < l; o++) {
                            const n = r.getX(o);
                            Ju.fromBufferAttribute(c, n),
                                Qu(Ju, n, a, i, t, e, this)
                        }
                    } else {
                        const n = Math.max(0, o.start)
                            , r = Math.min(c.count, o.start + o.count);
                        for (let o = n, s = r; o < s; o++)
                            Ju.fromBufferAttribute(c, o),
                                Qu(Ju, o, a, i, t, e, this)
                    }
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            updateMorphTargets: function() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                        , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                                this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                    this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        });
        class $u extends mn {
            constructor(t, e, n, i, r, o, s, a, c) {
                super(t, e, n, i, r, o, s, a, c),
                    this.format = void 0 !== s ? s : Ct,
                    this.minFilter = void 0 !== o ? o : ft,
                    this.magFilter = void 0 !== r ? r : ft,
                    this.generateMipmaps = !1;
                const l = this;
                function u() {
                    l.needsUpdate = !0,
                        t.requestVideoFrameCallback(u)
                }
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback(u)
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image
                    , e = "requestVideoFrameCallback"in t;
                !1 === e && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        $u.prototype.isVideoTexture = !0;
        class th extends mn {
            constructor(t, e, n, i, r, o, s, a, c, l, u, h) {
                super(null, o, s, a, c, l, i, r, u, h),
                    this.image = {
                        width: e,
                        height: n
                    },
                    this.mipmaps = t,
                    this.flipY = !1,
                    this.generateMipmaps = !1
            }
        }
        th.prototype.isCompressedTexture = !0;
        class eh extends mn {
            constructor(t, e, n, i, r, o, s, a, c) {
                super(t, e, n, i, r, o, s, a, c),
                    this.needsUpdate = !0
            }
        }
        eh.prototype.isCanvasTexture = !0;
        class nh extends mn {
            constructor(t, e, n, i, r, o, s, a, c, l) {
                if (l = void 0 !== l ? l : Nt,
                l !== Nt && l !== Dt)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && l === Nt && (n = xt),
                void 0 === n && l === Dt && (n = Lt),
                    super(null, i, r, o, s, a, l, n, c),
                    this.image = {
                        width: t,
                        height: e
                    },
                    this.magFilter = void 0 !== s ? s : ht,
                    this.minFilter = void 0 !== a ? a : ht,
                    this.flipY = !1,
                    this.generateMipmaps = !1
            }
        }
        nh.prototype.isDepthTexture = !0;
        class ih extends gr {
            constructor(t, e, n=1, i=0) {
                super(),
                    this.type = "PolyhedronGeometry",
                    this.parameters = {
                        vertices: t,
                        indices: e,
                        radius: n,
                        detail: i
                    };
                const r = []
                    , o = [];
                function s(t) {
                    const n = new bn
                        , i = new bn
                        , r = new bn;
                    for (let o = 0; o < e.length; o += 3)
                        d(e[o + 0], n),
                            d(e[o + 1], i),
                            d(e[o + 2], r),
                            a(n, i, r, t)
                }
                function a(t, e, n, i) {
                    const r = i + 1
                        , o = [];
                    for (let s = 0; s <= r; s++) {
                        o[s] = [];
                        const i = t.clone().lerp(n, s / r)
                            , a = e.clone().lerp(n, s / r)
                            , c = r - s;
                        for (let t = 0; t <= c; t++)
                            o[s][t] = 0 === t && s === r ? i : i.clone().lerp(a, t / c)
                    }
                    for (let s = 0; s < r; s++)
                        for (let t = 0; t < 2 * (r - s) - 1; t++) {
                            const e = Math.floor(t / 2);
                            t % 2 === 0 ? (h(o[s][e + 1]),
                                h(o[s + 1][e]),
                                h(o[s][e])) : (h(o[s][e + 1]),
                                h(o[s + 1][e + 1]),
                                h(o[s + 1][e]))
                        }
                }
                function c(t) {
                    const e = new bn;
                    for (let n = 0; n < r.length; n += 3)
                        e.x = r[n + 0],
                            e.y = r[n + 1],
                            e.z = r[n + 2],
                            e.normalize().multiplyScalar(t),
                            r[n + 0] = e.x,
                            r[n + 1] = e.y,
                            r[n + 2] = e.z
                }
                function l() {
                    const t = new bn;
                    for (let e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0],
                            t.y = r[e + 1],
                            t.z = r[e + 2];
                        const n = m(t) / 2 / Math.PI + .5
                            , i = g(t) / Math.PI + .5;
                        o.push(n, 1 - i)
                    }
                    p(),
                        u()
                }
                function u() {
                    for (let t = 0; t < o.length; t += 6) {
                        const e = o[t + 0]
                            , n = o[t + 2]
                            , i = o[t + 4]
                            , r = Math.max(e, n, i)
                            , s = Math.min(e, n, i);
                        r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1),
                        n < .2 && (o[t + 2] += 1),
                        i < .2 && (o[t + 4] += 1))
                    }
                }
                function h(t) {
                    r.push(t.x, t.y, t.z)
                }
                function d(e, n) {
                    const i = 3 * e;
                    n.x = t[i + 0],
                        n.y = t[i + 1],
                        n.z = t[i + 2]
                }
                function p() {
                    const t = new bn
                        , e = new bn
                        , n = new bn
                        , i = new bn
                        , s = new un
                        , a = new un
                        , c = new un;
                    for (let l = 0, u = 0; l < r.length; l += 9,
                        u += 6) {
                        t.set(r[l + 0], r[l + 1], r[l + 2]),
                            e.set(r[l + 3], r[l + 4], r[l + 5]),
                            n.set(r[l + 6], r[l + 7], r[l + 8]),
                            s.set(o[u + 0], o[u + 1]),
                            a.set(o[u + 2], o[u + 3]),
                            c.set(o[u + 4], o[u + 5]),
                            i.copy(t).add(e).add(n).divideScalar(3);
                        const h = m(i);
                        f(s, u + 0, t, h),
                            f(a, u + 2, e, h),
                            f(c, u + 4, n, h)
                    }
                }
                function f(t, e, n, i) {
                    i < 0 && 1 === t.x && (o[e] = t.x - 1),
                    0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5)
                }
                function m(t) {
                    return Math.atan2(t.z, -t.x)
                }
                function g(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }
                s(i),
                    c(n),
                    l(),
                    this.setAttribute("position", new sr(r,3)),
                    this.setAttribute("normal", new sr(r.slice(),3)),
                    this.setAttribute("uv", new sr(o,2)),
                    0 === i ? this.computeVertexNormals() : this.normalizeNormals()
            }
        }
        new bn,
            new bn,
            new bn,
            new Hi;
        const rh = {
            triangulate: function(t, e, n) {
                n = n || 2;
                const i = e && e.length
                    , r = i ? e[0] * n : t.length;
                let o = oh(t, 0, r, n, !0);
                const s = [];
                if (!o || o.next === o.prev)
                    return s;
                let a, c, l, u, h, d, p;
                if (i && (o = dh(t, e, o, n)),
                t.length > 80 * n) {
                    a = l = t[0],
                        c = u = t[1];
                    for (let e = n; e < r; e += n)
                        h = t[e],
                            d = t[e + 1],
                        h < a && (a = h),
                        d < c && (c = d),
                        h > l && (l = h),
                        d > u && (u = d);
                    p = Math.max(l - a, u - c),
                        p = 0 !== p ? 1 / p : 0
                }
                return ah(o, s, n, a, c, p),
                    s
            }
        };
        function oh(t, e, n, i, r) {
            let o, s;
            if (r === Dh(t, e, n, i) > 0)
                for (o = e; o < n; o += i)
                    s = Oh(o, t[o], t[o + 1], s);
            else
                for (o = n - i; o >= e; o -= i)
                    s = Oh(o, t[o], t[o + 1], s);
            return s && Sh(s, s.next) && (Ih(s),
                s = s.next),
                s
        }
        function sh(t, e) {
            if (!t)
                return t;
            e || (e = t);
            let n, i = t;
            do {
                if (n = !1,
                i.steiner || !Sh(i, i.next) && 0 !== Mh(i.prev, i, i.next))
                    i = i.next;
                else {
                    if (Ih(i),
                        i = e = i.prev,
                    i === i.next)
                        break;
                    n = !0
                }
            } while (n || i !== e);
            return e
        }
        function ah(t, e, n, i, r, o, s) {
            if (!t)
                return;
            !s && o && vh(t, i, r, o);
            let a, c, l = t;
            while (t.prev !== t.next)
                if (a = t.prev,
                    c = t.next,
                    o ? lh(t, i, r, o) : ch(t))
                    e.push(a.i / n),
                        e.push(t.i / n),
                        e.push(c.i / n),
                        Ih(t),
                        t = c.next,
                        l = c.next;
                else if (t = c,
                t === l) {
                    s ? 1 === s ? (t = uh(sh(t), e, n),
                        ah(t, e, n, i, r, o, 2)) : 2 === s && hh(t, e, n, i, r, o) : ah(sh(t), e, n, i, r, o, 1);
                    break
                }
        }
        function ch(t) {
            const e = t.prev
                , n = t
                , i = t.next;
            if (Mh(e, n, i) >= 0)
                return !1;
            let r = t.next.next;
            while (r !== t.prev) {
                if (bh(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Mh(r.prev, r, r.next) >= 0)
                    return !1;
                r = r.next
            }
            return !0
        }
        function lh(t, e, n, i) {
            const r = t.prev
                , o = t
                , s = t.next;
            if (Mh(r, o, s) >= 0)
                return !1;
            const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x
                , c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y
                , l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x
                , u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y
                , h = _h(a, c, e, n, i)
                , d = _h(l, u, e, n, i);
            let p = t.prevZ
                , f = t.nextZ;
            while (p && p.z >= h && f && f.z <= d) {
                if (p !== t.prev && p !== t.next && bh(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && Mh(p.prev, p, p.next) >= 0)
                    return !1;
                if (p = p.prevZ,
                f !== t.prev && f !== t.next && bh(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Mh(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            while (p && p.z >= h) {
                if (p !== t.prev && p !== t.next && bh(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && Mh(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.prevZ
            }
            while (f && f.z <= d) {
                if (f !== t.prev && f !== t.next && bh(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Mh(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            return !0
        }
        function uh(t, e, n) {
            let i = t;
            do {
                const r = i.prev
                    , o = i.next.next;
                !Sh(r, o) && Eh(r, i, i.next, o) && Rh(r, o) && Rh(o, r) && (e.push(r.i / n),
                    e.push(i.i / n),
                    e.push(o.i / n),
                    Ih(i),
                    Ih(i.next),
                    i = t = o),
                    i = i.next
            } while (i !== t);
            return sh(i)
        }
        function hh(t, e, n, i, r, o) {
            let s = t;
            do {
                let t = s.next.next;
                while (t !== s.prev) {
                    if (s.i !== t.i && wh(s, t)) {
                        let a = Ph(s, t);
                        return s = sh(s, s.next),
                            a = sh(a, a.next),
                            ah(s, e, n, i, r, o),
                            void ah(a, e, n, i, r, o)
                    }
                    t = t.next
                }
                s = s.next
            } while (s !== t)
        }
        function dh(t, e, n, i) {
            const r = [];
            let o, s, a, c, l;
            for (o = 0,
                     s = e.length; o < s; o++)
                a = e[o] * i,
                    c = o < s - 1 ? e[o + 1] * i : t.length,
                    l = oh(t, a, c, i, !1),
                l === l.next && (l.steiner = !0),
                    r.push(xh(l));
            for (r.sort(ph),
                     o = 0; o < r.length; o++)
                fh(r[o], n),
                    n = sh(n, n.next);
            return n
        }
        function ph(t, e) {
            return t.x - e.x
        }
        function fh(t, e) {
            if (e = mh(t, e),
                e) {
                const n = Ph(e, t);
                sh(e, e.next),
                    sh(n, n.next)
            }
        }
        function mh(t, e) {
            let n = e;
            const i = t.x
                , r = t.y;
            let o, s = -1 / 0;
            do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (t <= i && t > s) {
                        if (s = t,
                        t === i) {
                            if (r === n.y)
                                return n;
                            if (r === n.next.y)
                                return n.next
                        }
                        o = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== e);
            if (!o)
                return null;
            if (i === s)
                return o;
            const a = o
                , c = o.x
                , l = o.y;
            let u, h = 1 / 0;
            n = o;
            do {
                i >= n.x && n.x >= c && i !== n.x && bh(r < l ? i : s, r, c, l, r < l ? s : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x),
                Rh(n, t) && (u < h || u === h && (n.x > o.x || n.x === o.x && gh(o, n))) && (o = n,
                    h = u)),
                    n = n.next
            } while (n !== a);
            return o
        }
        function gh(t, e) {
            return Mh(t.prev, t, e.prev) < 0 && Mh(e.next, t, t.next) < 0
        }
        function vh(t, e, n, i) {
            let r = t;
            do {
                null === r.z && (r.z = _h(r.x, r.y, e, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null,
                r.prevZ = null,
                yh(r)
        }
        function yh(t) {
            let e, n, i, r, o, s, a, c, l = 1;
            do {
                n = t,
                    t = null,
                    o = null,
                    s = 0;
                while (n) {
                    for (s++,
                             i = n,
                             a = 0,
                             e = 0; e < l; e++)
                        if (a++,
                            i = i.nextZ,
                            !i)
                            break;
                    c = l;
                    while (a > 0 || c > 0 && i)
                        0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n,
                            n = n.nextZ,
                            a--) : (r = i,
                            i = i.nextZ,
                            c--),
                            o ? o.nextZ = r : t = r,
                            r.prevZ = o,
                            o = r;
                    n = i
                }
                o.nextZ = null,
                    l *= 2
            } while (s > 1);
            return t
        }
        function _h(t, e, n, i, r) {
            return t = 32767 * (t - n) * r,
                e = 32767 * (e - i) * r,
                t = 16711935 & (t | t << 8),
                t = 252645135 & (t | t << 4),
                t = 858993459 & (t | t << 2),
                t = 1431655765 & (t | t << 1),
                e = 16711935 & (e | e << 8),
                e = 252645135 & (e | e << 4),
                e = 858993459 & (e | e << 2),
                e = 1431655765 & (e | e << 1),
            t | e << 1
        }
        function xh(t) {
            let e = t
                , n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
                    e = e.next
            } while (e !== t);
            return n
        }
        function bh(t, e, n, i, r, o, s, a) {
            return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0
        }
        function wh(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !Lh(t, e) && (Rh(t, e) && Rh(e, t) && Ch(t, e) && (Mh(t.prev, t, e.prev) || Mh(t, e.prev, e)) || Sh(t, e) && Mh(t.prev, t, t.next) > 0 && Mh(e.prev, e, e.next) > 0)
        }
        function Mh(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function Sh(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function Eh(t, e, n, i) {
            const r = Ah(Mh(t, e, n))
                , o = Ah(Mh(t, e, i))
                , s = Ah(Mh(n, i, t))
                , a = Ah(Mh(n, i, e));
            return r !== o && s !== a || (!(0 !== r || !Th(t, n, e)) || (!(0 !== o || !Th(t, i, e)) || (!(0 !== s || !Th(n, t, i)) || !(0 !== a || !Th(n, e, i)))))
        }
        function Th(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }
        function Ah(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Lh(t, e) {
            let n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Eh(n, n.next, t, e))
                    return !0;
                n = n.next
            } while (n !== t);
            return !1
        }
        function Rh(t, e) {
            return Mh(t.prev, t, t.next) < 0 ? Mh(t, e, t.next) >= 0 && Mh(t, t.prev, e) >= 0 : Mh(t, e, t.prev) < 0 || Mh(t, t.next, e) < 0
        }
        function Ch(t, e) {
            let n = t
                , i = !1;
            const r = (t.x + e.x) / 2
                , o = (t.y + e.y) / 2;
            do {
                n.y > o !== n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                    n = n.next
            } while (n !== t);
            return i
        }
        function Ph(t, e) {
            const n = new Nh(t.i,t.x,t.y)
                , i = new Nh(e.i,e.x,e.y)
                , r = t.next
                , o = e.prev;
            return t.next = e,
                e.prev = t,
                n.next = r,
                r.prev = n,
                i.next = n,
                n.prev = i,
                o.next = i,
                i.prev = o,
                i
        }
        function Oh(t, e, n, i) {
            const r = new Nh(t,e,n);
            return i ? (r.next = i.next,
                r.prev = i,
                i.next.prev = r,
                i.next = r) : (r.prev = r,
                r.next = r),
                r
        }
        function Ih(t) {
            t.next.prev = t.prev,
                t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Nh(t, e, n) {
            this.i = t,
                this.x = e,
                this.y = n,
                this.prev = null,
                this.next = null,
                this.z = null,
                this.prevZ = null,
                this.nextZ = null,
                this.steiner = !1
        }
        function Dh(t, e, n, i) {
            let r = 0;
            for (let o = e, s = n - i; o < n; o += i)
                r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
                    s = o;
            return r
        }
        const Fh = {
            area: function(t) {
                const e = t.length;
                let n = 0;
                for (let i = e - 1, r = 0; r < e; i = r++)
                    n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            },
            isClockWise: function(t) {
                return Fh.area(t) < 0
            },
            triangulateShape: function(t, e) {
                const n = []
                    , i = []
                    , r = [];
                kh(t),
                    Hh(n, t);
                let o = t.length;
                e.forEach(kh);
                for (let a = 0; a < e.length; a++)
                    i.push(o),
                        o += e[a].length,
                        Hh(n, e[a]);
                const s = rh.triangulate(n, i);
                for (let a = 0; a < s.length; a += 3)
                    r.push(s.slice(a, a + 3));
                return r
            }
        };
        function kh(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function Hh(t, e) {
            for (let n = 0; n < e.length; n++)
                t.push(e[n].x),
                    t.push(e[n].y)
        }
        class Bh extends gr {
            constructor(t, e) {
                super(),
                    this.type = "ExtrudeGeometry",
                    this.parameters = {
                        shapes: t,
                        options: e
                    },
                    t = Array.isArray(t) ? t : [t];
                const n = this
                    , i = []
                    , r = [];
                for (let s = 0, a = t.length; s < a; s++) {
                    const e = t[s];
                    o(e)
                }
                function o(t) {
                    const o = []
                        , s = void 0 !== e.curveSegments ? e.curveSegments : 12
                        , a = void 0 !== e.steps ? e.steps : 1;
                    let c = void 0 !== e.depth ? e.depth : 100
                        , l = void 0 === e.bevelEnabled || e.bevelEnabled
                        , u = void 0 !== e.bevelThickness ? e.bevelThickness : 6
                        , h = void 0 !== e.bevelSize ? e.bevelSize : u - 2
                        , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                        , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath
                        , m = void 0 !== e.UVGenerator ? e.UVGenerator : zh;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                        c = e.amount);
                    let g, v, y, _, x, b = !1;
                    f && (g = f.getSpacedPoints(a),
                        b = !0,
                        l = !1,
                        v = f.computeFrenetFrames(a, !1),
                        y = new bn,
                        _ = new bn,
                        x = new bn),
                    l || (p = 0,
                        u = 0,
                        h = 0,
                        d = 0);
                    const w = t.extractPoints(s);
                    let M = w.shape;
                    const S = w.holes
                        , E = !Fh.isClockWise(M);
                    if (E) {
                        M = M.reverse();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            Fh.isClockWise(e) && (S[t] = e.reverse())
                        }
                    }
                    const T = Fh.triangulateShape(M, S)
                        , A = M;
                    for (let e = 0, n = S.length; e < n; e++) {
                        const t = S[e];
                        M = M.concat(t)
                    }
                    function L(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                            e.clone().multiplyScalar(n).add(t)
                    }
                    const R = M.length
                        , C = T.length;
                    function P(t, e, n) {
                        let i, r, o;
                        const s = t.x - e.x
                            , a = t.y - e.y
                            , c = n.x - t.x
                            , l = n.y - t.y
                            , u = s * s + a * a
                            , h = s * l - a * c;
                        if (Math.abs(h) > Number.EPSILON) {
                            const h = Math.sqrt(u)
                                , d = Math.sqrt(c * c + l * l)
                                , p = e.x - a / h
                                , f = e.y + s / h
                                , m = n.x - l / d
                                , g = n.y + c / d
                                , v = ((m - p) * l - (g - f) * c) / (s * l - a * c);
                            i = p + s * v - t.x,
                                r = f + a * v - t.y;
                            const y = i * i + r * r;
                            if (y <= 2)
                                return new un(i,r);
                            o = Math.sqrt(y / 2)
                        } else {
                            let t = !1;
                            s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0),
                                t ? (i = -a,
                                    r = s,
                                    o = Math.sqrt(u)) : (i = s,
                                    r = a,
                                    o = Math.sqrt(u / 2))
                        }
                        return new un(i / o,r / o)
                    }
                    const O = [];
                    for (let e = 0, n = A.length, i = n - 1, r = e + 1; e < n; e++,
                        i++,
                        r++)
                        i === n && (i = 0),
                        r === n && (r = 0),
                            O[e] = P(A[e], A[i], A[r]);
                    const I = [];
                    let N, D = O.concat();
                    for (let e = 0, n = S.length; e < n; e++) {
                        const t = S[e];
                        N = [];
                        for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++,
                            i++,
                            r++)
                            i === n && (i = 0),
                            r === n && (r = 0),
                                N[e] = P(t[e], t[i], t[r]);
                        I.push(N),
                            D = D.concat(N)
                    }
                    for (let e = 0; e < p; e++) {
                        const t = e / p
                            , n = u * Math.cos(t * Math.PI / 2)
                            , i = h * Math.sin(t * Math.PI / 2) + d;
                        for (let e = 0, r = A.length; e < r; e++) {
                            const t = L(A[e], O[e], i);
                            z(t.x, t.y, -n)
                        }
                        for (let e = 0, r = S.length; e < r; e++) {
                            const t = S[e];
                            N = I[e];
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = L(t[e], N[e], i);
                                z(r.x, r.y, -n)
                            }
                        }
                    }
                    const F = h + d;
                    for (let e = 0; e < R; e++) {
                        const t = l ? L(M[e], D[e], F) : M[e];
                        b ? (_.copy(v.normals[0]).multiplyScalar(t.x),
                            y.copy(v.binormals[0]).multiplyScalar(t.y),
                            x.copy(g[0]).add(_).add(y),
                            z(x.x, x.y, x.z)) : z(t.x, t.y, 0)
                    }
                    for (let e = 1; e <= a; e++)
                        for (let t = 0; t < R; t++) {
                            const n = l ? L(M[t], D[t], F) : M[t];
                            b ? (_.copy(v.normals[e]).multiplyScalar(n.x),
                                y.copy(v.binormals[e]).multiplyScalar(n.y),
                                x.copy(g[e]).add(_).add(y),
                                z(x.x, x.y, x.z)) : z(n.x, n.y, c / a * e)
                        }
                    for (let e = p - 1; e >= 0; e--) {
                        const t = e / p
                            , n = u * Math.cos(t * Math.PI / 2)
                            , i = h * Math.sin(t * Math.PI / 2) + d;
                        for (let e = 0, r = A.length; e < r; e++) {
                            const t = L(A[e], O[e], i);
                            z(t.x, t.y, c + n)
                        }
                        for (let e = 0, r = S.length; e < r; e++) {
                            const t = S[e];
                            N = I[e];
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = L(t[e], N[e], i);
                                b ? z(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : z(r.x, r.y, c + n)
                            }
                        }
                    }
                    function k() {
                        const t = i.length / 3;
                        if (l) {
                            let t = 0
                                , e = R * t;
                            for (let n = 0; n < C; n++) {
                                const t = T[n];
                                U(t[2] + e, t[1] + e, t[0] + e)
                            }
                            t = a + 2 * p,
                                e = R * t;
                            for (let n = 0; n < C; n++) {
                                const t = T[n];
                                U(t[0] + e, t[1] + e, t[2] + e)
                            }
                        } else {
                            for (let t = 0; t < C; t++) {
                                const e = T[t];
                                U(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < C; t++) {
                                const e = T[t];
                                U(e[0] + R * a, e[1] + R * a, e[2] + R * a)
                            }
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }
                    function H() {
                        const t = i.length / 3;
                        let e = 0;
                        B(A, e),
                            e += A.length;
                        for (let n = 0, i = S.length; n < i; n++) {
                            const t = S[n];
                            B(t, e),
                                e += t.length
                        }
                        n.addGroup(t, i.length / 3 - t, 1)
                    }
                    function B(t, e) {
                        let n = t.length;
                        while (--n >= 0) {
                            const i = n;
                            let r = n - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, n = a + 2 * p; t < n; t++) {
                                const n = R * t
                                    , o = R * (t + 1)
                                    , s = e + i + n
                                    , a = e + r + n
                                    , c = e + r + o
                                    , l = e + i + o;
                                j(s, a, c, l)
                            }
                        }
                    }
                    function z(t, e, n) {
                        o.push(t),
                            o.push(e),
                            o.push(n)
                    }
                    function U(t, e, r) {
                        G(t),
                            G(e),
                            G(r);
                        const o = i.length / 3
                            , s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                        V(s[0]),
                            V(s[1]),
                            V(s[2])
                    }
                    function j(t, e, r, o) {
                        G(t),
                            G(e),
                            G(o),
                            G(e),
                            G(r),
                            G(o);
                        const s = i.length / 3
                            , a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                        V(a[0]),
                            V(a[1]),
                            V(a[3]),
                            V(a[1]),
                            V(a[2]),
                            V(a[3])
                    }
                    function G(t) {
                        i.push(o[3 * t + 0]),
                            i.push(o[3 * t + 1]),
                            i.push(o[3 * t + 2])
                    }
                    function V(t) {
                        r.push(t.x),
                            r.push(t.y)
                    }
                    k(),
                        H()
                }
                this.setAttribute("position", new sr(i,3)),
                    this.setAttribute("uv", new sr(r,2)),
                    this.computeVertexNormals()
            }
            toJSON() {
                const t = gr.prototype.toJSON.call(this)
                    , e = this.parameters.shapes
                    , n = this.parameters.options;
                return Uh(e, n, t)
            }
        }
        const zh = {
            generateTopUV: function(t, e, n, i, r) {
                const o = e[3 * n]
                    , s = e[3 * n + 1]
                    , a = e[3 * i]
                    , c = e[3 * i + 1]
                    , l = e[3 * r]
                    , u = e[3 * r + 1];
                return [new un(o,s), new un(a,c), new un(l,u)]
            },
            generateSideWallUV: function(t, e, n, i, r, o) {
                const s = e[3 * n]
                    , a = e[3 * n + 1]
                    , c = e[3 * n + 2]
                    , l = e[3 * i]
                    , u = e[3 * i + 1]
                    , h = e[3 * i + 2]
                    , d = e[3 * r]
                    , p = e[3 * r + 1]
                    , f = e[3 * r + 2]
                    , m = e[3 * o]
                    , g = e[3 * o + 1]
                    , v = e[3 * o + 2];
                return Math.abs(a - u) < .01 ? [new un(s,1 - c), new un(l,1 - h), new un(d,1 - f), new un(m,1 - v)] : [new un(a,1 - c), new un(u,1 - h), new un(p,1 - f), new un(g,1 - v)]
            }
        };
        function Uh(t, e, n) {
            if (n.shapes = [],
                Array.isArray(t))
                for (let i = 0, r = t.length; i < r; i++) {
                    const e = t[i];
                    n.shapes.push(e.uuid)
                }
            else
                n.shapes.push(t.uuid);
            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()),
                n
        }
        class jh extends ih {
            constructor(t=1, e=0) {
                const n = (1 + Math.sqrt(5)) / 2
                    , i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1]
                    , r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                super(i, r, t, e),
                    this.type = "IcosahedronGeometry",
                    this.parameters = {
                        radius: t,
                        detail: e
                    }
            }
        }
        function Gh(t, e, n) {
            gr.call(this),
                this.type = "ParametricGeometry",
                this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
            const i = []
                , r = []
                , o = []
                , s = []
                , a = 1e-5
                , c = new bn
                , l = new bn
                , u = new bn
                , h = new bn
                , d = new bn;
            t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            const p = e + 1;
            for (let f = 0; f <= n; f++) {
                const i = f / n;
                for (let n = 0; n <= e; n++) {
                    const p = n / e;
                    t(p, i, l),
                        r.push(l.x, l.y, l.z),
                        p - a >= 0 ? (t(p - a, i, u),
                            h.subVectors(l, u)) : (t(p + a, i, u),
                            h.subVectors(u, l)),
                        i - a >= 0 ? (t(p, i - a, u),
                            d.subVectors(l, u)) : (t(p, i + a, u),
                            d.subVectors(u, l)),
                        c.crossVectors(h, d).normalize(),
                        o.push(c.x, c.y, c.z),
                        s.push(p, i)
                }
            }
            for (let f = 0; f < n; f++)
                for (let t = 0; t < e; t++) {
                    const e = f * p + t
                        , n = f * p + t + 1
                        , r = (f + 1) * p + t + 1
                        , o = (f + 1) * p + t;
                    i.push(e, n, o),
                        i.push(n, r, o)
                }
            this.setIndex(i),
                this.setAttribute("position", new sr(r,3)),
                this.setAttribute("normal", new sr(o,3)),
                this.setAttribute("uv", new sr(s,2))
        }
        Gh.prototype = Object.create(gr.prototype),
            Gh.prototype.constructor = Gh;
        class Vh extends gr {
            constructor(t, e=12) {
                super(),
                    this.type = "ShapeGeometry",
                    this.parameters = {
                        shapes: t,
                        curveSegments: e
                    };
                const n = []
                    , i = []
                    , r = []
                    , o = [];
                let s = 0
                    , a = 0;
                if (!1 === Array.isArray(t))
                    c(t);
                else
                    for (let l = 0; l < t.length; l++)
                        c(t[l]),
                            this.addGroup(s, a, l),
                            s += a,
                            a = 0;
                function c(t) {
                    const s = i.length / 3
                        , c = t.extractPoints(e);
                    let l = c.shape;
                    const u = c.holes;
                    !1 === Fh.isClockWise(l) && (l = l.reverse());
                    for (let e = 0, n = u.length; e < n; e++) {
                        const t = u[e];
                        !0 === Fh.isClockWise(t) && (u[e] = t.reverse())
                    }
                    const h = Fh.triangulateShape(l, u);
                    for (let e = 0, n = u.length; e < n; e++) {
                        const t = u[e];
                        l = l.concat(t)
                    }
                    for (let e = 0, n = l.length; e < n; e++) {
                        const t = l[e];
                        i.push(t.x, t.y, 0),
                            r.push(0, 0, 1),
                            o.push(t.x, t.y)
                    }
                    for (let e = 0, i = h.length; e < i; e++) {
                        const t = h[e]
                            , i = t[0] + s
                            , r = t[1] + s
                            , o = t[2] + s;
                        n.push(i, r, o),
                            a += 3
                    }
                }
                this.setIndex(n),
                    this.setAttribute("position", new sr(i,3)),
                    this.setAttribute("normal", new sr(r,3)),
                    this.setAttribute("uv", new sr(o,2))
            }
            toJSON() {
                const t = gr.prototype.toJSON.call(this)
                    , e = this.parameters.shapes;
                return Wh(e, t)
            }
        }
        function Wh(t, e) {
            if (e.shapes = [],
                Array.isArray(t))
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.shapes.push(i.uuid)
                }
            else
                e.shapes.push(t.uuid);
            return e
        }
        class qh extends zi {
            constructor(t) {
                super(),
                    this.type = "ShadowMaterial",
                    this.color = new Xi(0),
                    this.transparent = !0,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this
            }
        }
        qh.prototype.isShadowMaterial = !0;
        class Xh extends Gr {
            constructor(t) {
                super(t),
                    this.type = "RawShaderMaterial"
            }
        }
        function Yh(t) {
            zi.call(this),
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Xi(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Xi(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = Qe,
                this.normalScale = new un(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.vertexTangents = !1,
                this.setValues(t)
        }
        function Zh(t) {
            Yh.call(this),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.clearcoat = 0,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new un(1,1),
                this.clearcoatNormalMap = null,
                this.reflectivity = .5,
                Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = ln.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }),
                this.sheen = null,
                this.transmission = 0,
                this.transmissionMap = null,
                this.setValues(t)
        }
        Xh.prototype.isRawShaderMaterial = !0,
            Yh.prototype = Object.create(zi.prototype),
            Yh.prototype.constructor = Yh,
            Yh.prototype.isMeshStandardMaterial = !0,
            Yh.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color.copy(t.color),
                    this.roughness = t.roughness,
                    this.metalness = t.metalness,
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalMapType = t.normalMapType,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.roughnessMap = t.roughnessMap,
                    this.metalnessMap = t.metalnessMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.envMapIntensity = t.envMapIntensity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.flatShading = t.flatShading,
                    this.vertexTangents = t.vertexTangents,
                    this
            }
            ,
            Zh.prototype = Object.create(Yh.prototype),
            Zh.prototype.constructor = Zh,
            Zh.prototype.isMeshPhysicalMaterial = !0,
            Zh.prototype.copy = function(t) {
                return Yh.prototype.copy.call(this, t),
                    this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    },
                    this.clearcoat = t.clearcoat,
                    this.clearcoatMap = t.clearcoatMap,
                    this.clearcoatRoughness = t.clearcoatRoughness,
                    this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                    this.clearcoatNormalMap = t.clearcoatNormalMap,
                    this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                    this.reflectivity = t.reflectivity,
                    t.sheen ? this.sheen = (this.sheen || new Xi).copy(t.sheen) : this.sheen = null,
                    this.transmission = t.transmission,
                    this.transmissionMap = t.transmissionMap,
                    this
            }
        ;
        class Jh extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshPhongMaterial",
                    this.color = new Xi(16777215),
                    this.specular = new Xi(1118481),
                    this.shininess = 30,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new Xi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = Qe,
                    this.normalScale = new un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = q,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.flatShading = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.specular.copy(t.specular),
                    this.shininess = t.shininess,
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalMapType = t.normalMapType,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.flatShading = t.flatShading,
                    this
            }
        }
        Jh.prototype.isMeshPhongMaterial = !0;
        class Kh extends zi {
            constructor(t) {
                super(),
                    this.defines = {
                        TOON: ""
                    },
                    this.type = "MeshToonMaterial",
                    this.color = new Xi(16777215),
                    this.map = null,
                    this.gradientMap = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new Xi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = Qe,
                    this.normalScale = new un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.alphaMap = null,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.gradientMap = t.gradientMap,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalMapType = t.normalMapType,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.alphaMap = t.alphaMap,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this
            }
        }
        Kh.prototype.isMeshToonMaterial = !0;
        class Qh extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshNormalMaterial",
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = Qe,
                    this.normalScale = new un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.flatShading = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalMapType = t.normalMapType,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.flatShading = t.flatShading,
                    this
            }
        }
        Qh.prototype.isMeshNormalMaterial = !0;
        class $h extends zi {
            constructor(t) {
                super(),
                    this.type = "MeshLambertMaterial",
                    this.color = new Xi(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new Xi(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = q,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this
            }
        }
        $h.prototype.isMeshLambertMaterial = !0;
        class td extends zi {
            constructor(t) {
                super(),
                    this.defines = {
                        MATCAP: ""
                    },
                    this.type = "MeshMatcapMaterial",
                    this.color = new Xi(16777215),
                    this.matcap = null,
                    this.map = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = Qe,
                    this.normalScale = new un(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.alphaMap = null,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.flatShading = !1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.defines = {
                        MATCAP: ""
                    },
                    this.color.copy(t.color),
                    this.matcap = t.matcap,
                    this.map = t.map,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalMapType = t.normalMapType,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.alphaMap = t.alphaMap,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.flatShading = t.flatShading,
                    this
            }
        }
        td.prototype.isMeshMatcapMaterial = !0;
        class ed extends Du {
            constructor(t) {
                super(),
                    this.type = "LineDashedMaterial",
                    this.scale = 1,
                    this.dashSize = 3,
                    this.gapSize = 1,
                    this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                    this.scale = t.scale,
                    this.dashSize = t.dashSize,
                    this.gapSize = t.gapSize,
                    this
            }
        }
        ed.prototype.isLineDashedMaterial = !0;
        const nd = {
            arraySlice: function(t, e, n) {
                return nd.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" === typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                function e(e, n) {
                    return t[e] - t[n]
                }
                const n = t.length
                    , i = new Array(n);
                for (let r = 0; r !== n; ++r)
                    i[r] = r;
                return i.sort(e),
                    i
            },
            sortedArray: function(t, e, n) {
                const i = t.length
                    , r = new t.constructor(i);
                for (let o = 0, s = 0; s !== i; ++o) {
                    const i = n[o] * e;
                    for (let n = 0; n !== e; ++n)
                        r[s++] = t[i + n]
                }
                return r
            },
            flattenJSON: function(t, e, n, i) {
                let r = 1
                    , o = t[0];
                while (void 0 !== o && void 0 === o[i])
                    o = t[r++];
                if (void 0 === o)
                    return;
                let s = o[i];
                if (void 0 !== s)
                    if (Array.isArray(s))
                        do {
                            s = o[i],
                            void 0 !== s && (e.push(o.time),
                                n.push.apply(n, s)),
                                o = t[r++]
                        } while (void 0 !== o);
                    else if (void 0 !== s.toArray)
                        do {
                            s = o[i],
                            void 0 !== s && (e.push(o.time),
                                s.toArray(n, n.length)),
                                o = t[r++]
                        } while (void 0 !== o);
                    else
                        do {
                            s = o[i],
                            void 0 !== s && (e.push(o.time),
                                n.push(s)),
                                o = t[r++]
                        } while (void 0 !== o)
            },
            subclip: function(t, e, n, i, r=30) {
                const o = t.clone();
                o.name = e;
                const s = [];
                for (let c = 0; c < o.tracks.length; ++c) {
                    const t = o.tracks[c]
                        , e = t.getValueSize()
                        , a = []
                        , l = [];
                    for (let o = 0; o < t.times.length; ++o) {
                        const s = t.times[o] * r;
                        if (!(s < n || s >= i)) {
                            a.push(t.times[o]);
                            for (let n = 0; n < e; ++n)
                                l.push(t.values[o * e + n])
                        }
                    }
                    0 !== a.length && (t.times = nd.convertArray(a, t.times.constructor),
                        t.values = nd.convertArray(l, t.values.constructor),
                        s.push(t))
                }
                o.tracks = s;
                let a = 1 / 0;
                for (let c = 0; c < o.tracks.length; ++c)
                    a > o.tracks[c].times[0] && (a = o.tracks[c].times[0]);
                for (let c = 0; c < o.tracks.length; ++c)
                    o.tracks[c].shift(-1 * a);
                return o.resetDuration(),
                    o
            },
            makeClipAdditive: function(t, e=0, n=t, i=30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length
                    , o = e / i;
                for (let s = 0; s < r; ++s) {
                    const e = n.tracks[s]
                        , i = e.ValueTypeName;
                    if ("bool" === i || "string" === i)
                        continue;
                    const r = t.tracks.find((function(t) {
                            return t.name === e.name && t.ValueTypeName === i
                        }
                    ));
                    if (void 0 === r)
                        continue;
                    let a = 0;
                    const c = e.getValueSize();
                    e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3);
                    let l = 0;
                    const u = r.getValueSize();
                    r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);
                    const h = e.times.length - 1;
                    let d;
                    if (o <= e.times[0]) {
                        const t = a
                            , n = c - a;
                        d = nd.arraySlice(e.values, t, n)
                    } else if (o >= e.times[h]) {
                        const t = h * c + a
                            , n = t + c - a;
                        d = nd.arraySlice(e.values, t, n)
                    } else {
                        const t = e.createInterpolant()
                            , n = a
                            , i = c - a;
                        t.evaluate(o),
                            d = nd.arraySlice(t.resultBuffer, n, i)
                    }
                    if ("quaternion" === i) {
                        const t = (new xn).fromArray(d).normalize().conjugate();
                        t.toArray(d)
                    }
                    const p = r.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * u + l;
                        if ("quaternion" === i)
                            xn.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
                        else {
                            const t = u - 2 * l;
                            for (let n = 0; n < t; ++n)
                                r.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = He,
                    t
            }
        };
        function id(t, e, n, i) {
            this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n
        }
        function rd(t, e, n, i) {
            id.call(this, t, e, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0
        }
        function od(t, e, n, i) {
            id.call(this, t, e, n, i)
        }
        function sd(t, e, n, i) {
            id.call(this, t, e, n, i)
        }
        Object.assign(id.prototype, {
            evaluate: function(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                    , i = e[n]
                    , r = e[n - 1];
                t: {
                    e: {
                        let o;
                        n: {
                            i: if (!(t < i)) {
                                for (let o = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < r)
                                            break i;
                                        return n = e.length,
                                            this._cachedIndex = n,
                                            this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === o)
                                        break;
                                    if (r = i,
                                        i = e[++n],
                                    t < i)
                                        break e
                                }
                                o = e.length;
                                break n
                            }
                            if (t >= r)
                                break t;
                            {
                                const s = e[1];
                                t < s && (n = 2,
                                    r = s);
                                for (let o = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                            this.beforeStart_(0, t, i);
                                    if (n === o)
                                        break;
                                    if (i = r,
                                        r = e[--n - 1],
                                    t >= r)
                                        break e
                                }
                                o = n,
                                    n = 0
                            }
                        }
                        while (n < o) {
                            const i = n + o >>> 1;
                            t < e[i] ? o = i : n = i + 1
                        }
                        if (i = e[n],
                            r = e[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                        if (void 0 === i)
                            return n = e.length,
                                this._cachedIndex = n,
                                this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                const e = this.resultBuffer
                    , n = this.sampleValues
                    , i = this.valueSize
                    , r = t * i;
                for (let o = 0; o !== i; ++o)
                    e[o] = n[r + o];
                return e
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }),
            Object.assign(id.prototype, {
                beforeStart_: id.prototype.copySampleValue_,
                afterEnd_: id.prototype.copySampleValue_
            }),
            rd.prototype = Object.assign(Object.create(id.prototype), {
                constructor: rd,
                DefaultSettings_: {
                    endingStart: Ne,
                    endingEnd: Ne
                },
                intervalChanged_: function(t, e, n) {
                    const i = this.parameterPositions;
                    let r = t - 2
                        , o = t + 1
                        , s = i[r]
                        , a = i[o];
                    if (void 0 === s)
                        switch (this.getSettings_().endingStart) {
                            case De:
                                r = t,
                                    s = 2 * e - n;
                                break;
                            case Fe:
                                r = i.length - 2,
                                    s = e + i[r] - i[r + 1];
                                break;
                            default:
                                r = t,
                                    s = n
                        }
                    if (void 0 === a)
                        switch (this.getSettings_().endingEnd) {
                            case De:
                                o = t,
                                    a = 2 * n - e;
                                break;
                            case Fe:
                                o = 1,
                                    a = n + i[1] - i[0];
                                break;
                            default:
                                o = t - 1,
                                    a = e
                        }
                    const c = .5 * (n - e)
                        , l = this.valueSize;
                    this._weightPrev = c / (e - s),
                        this._weightNext = c / (a - n),
                        this._offsetPrev = r * l,
                        this._offsetNext = o * l
                },
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer
                        , o = this.sampleValues
                        , s = this.valueSize
                        , a = t * s
                        , c = a - s
                        , l = this._offsetPrev
                        , u = this._offsetNext
                        , h = this._weightPrev
                        , d = this._weightNext
                        , p = (n - e) / (i - e)
                        , f = p * p
                        , m = f * p
                        , g = -h * m + 2 * h * f - h * p
                        , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                        , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
                        , _ = d * m - d * f;
                    for (let x = 0; x !== s; ++x)
                        r[x] = g * o[l + x] + v * o[c + x] + y * o[a + x] + _ * o[u + x];
                    return r
                }
            }),
            od.prototype = Object.assign(Object.create(id.prototype), {
                constructor: od,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer
                        , o = this.sampleValues
                        , s = this.valueSize
                        , a = t * s
                        , c = a - s
                        , l = (n - e) / (i - e)
                        , u = 1 - l;
                    for (let h = 0; h !== s; ++h)
                        r[h] = o[c + h] * u + o[a + h] * l;
                    return r
                }
            }),
            sd.prototype = Object.assign(Object.create(id.prototype), {
                constructor: sd,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            });
        class ad {
            constructor(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                    this.times = nd.convertArray(e, this.TimeBufferType),
                    this.values = nd.convertArray(n, this.ValueBufferType),
                    this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: nd.convertArray(t.times, Array),
                        values: nd.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                    n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new sd(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new od(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new rd(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                    case Pe:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Oe:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case Ie:
                        e = this.InterpolantFactoryMethodSmooth;
                        break
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                        this
                }
                return this.createInterpolant = e,
                    this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Pe;
                    case this.InterpolantFactoryMethodLinear:
                        return Oe;
                    case this.InterpolantFactoryMethodSmooth:
                        return Ie
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                    , i = n.length;
                let r = 0
                    , o = i - 1;
                while (r !== i && n[r] < t)
                    ++r;
                while (-1 !== o && n[o] > e)
                    --o;
                if (++o,
                0 !== r || o !== i) {
                    r >= o && (o = Math.max(o, 1),
                        r = o - 1);
                    const t = this.getValueSize();
                    this.times = nd.arraySlice(n, r, o),
                        this.values = nd.arraySlice(this.values, r * t, o * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                    t = !1);
                const n = this.times
                    , i = this.values
                    , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                    t = !1);
                let o = null;
                for (let s = 0; s !== r; s++) {
                    const e = n[s];
                    if ("number" === typeof e && isNaN(e)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, e),
                            t = !1;
                        break
                    }
                    if (null !== o && o > e) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, s, e, o),
                            t = !1;
                        break
                    }
                    o = e
                }
                if (void 0 !== i && nd.isTypedArray(i))
                    for (let s = 0, a = i.length; s !== a; ++s) {
                        const e = i[s];
                        if (isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, e),
                                t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = nd.arraySlice(this.times)
                    , e = nd.arraySlice(this.values)
                    , n = this.getValueSize()
                    , i = this.getInterpolation() === Ie
                    , r = t.length - 1;
                let o = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const a = t[s]
                        , c = t[s + 1];
                    if (a !== c && (1 !== s || a !== t[0]))
                        if (i)
                            r = !0;
                        else {
                            const t = s * n
                                , i = t - n
                                , o = t + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = e[t + s];
                                if (n !== e[i + s] || n !== e[o + s]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (s !== o) {
                            t[o] = t[s];
                            const i = s * n
                                , r = o * n;
                            for (let t = 0; t !== n; ++t)
                                e[r + t] = e[i + t]
                        }
                        ++o
                    }
                }
                if (r > 0) {
                    t[o] = t[r];
                    for (let t = r * n, i = o * n, s = 0; s !== n; ++s)
                        e[i + s] = e[t + s];
                    ++o
                }
                return o !== t.length ? (this.times = nd.arraySlice(t, 0, o),
                    this.values = nd.arraySlice(e, 0, o * n)) : (this.times = t,
                    this.values = e),
                    this
            }
            clone() {
                const t = nd.arraySlice(this.times, 0)
                    , e = nd.arraySlice(this.values, 0)
                    , n = this.constructor
                    , i = new n(this.name,t,e);
                return i.createInterpolant = this.createInterpolant,
                    i
            }
        }
        ad.prototype.TimeBufferType = Float32Array,
            ad.prototype.ValueBufferType = Float32Array,
            ad.prototype.DefaultInterpolation = Oe;
        class cd extends ad {
        }
        cd.prototype.ValueTypeName = "bool",
            cd.prototype.ValueBufferType = Array,
            cd.prototype.DefaultInterpolation = Pe,
            cd.prototype.InterpolantFactoryMethodLinear = void 0,
            cd.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ld extends ad {
        }
        ld.prototype.ValueTypeName = "color";
        class ud extends ad {
        }
        function hd(t, e, n, i) {
            id.call(this, t, e, n, i)
        }
        ud.prototype.ValueTypeName = "number",
            hd.prototype = Object.assign(Object.create(id.prototype), {
                constructor: hd,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer
                        , o = this.sampleValues
                        , s = this.valueSize
                        , a = (n - e) / (i - e);
                    let c = t * s;
                    for (let l = c + s; c !== l; c += 4)
                        xn.slerpFlat(r, 0, o, c - s, o, c, a);
                    return r
                }
            });
        class dd extends ad {
            InterpolantFactoryMethodLinear(t) {
                return new hd(this.times,this.values,this.getValueSize(),t)
            }
        }
        dd.prototype.ValueTypeName = "quaternion",
            dd.prototype.DefaultInterpolation = Oe,
            dd.prototype.InterpolantFactoryMethodSmooth = void 0;
        class pd extends ad {
        }
        pd.prototype.ValueTypeName = "string",
            pd.prototype.ValueBufferType = Array,
            pd.prototype.DefaultInterpolation = Pe,
            pd.prototype.InterpolantFactoryMethodLinear = void 0,
            pd.prototype.InterpolantFactoryMethodSmooth = void 0;
        class fd extends ad {
        }
        fd.prototype.ValueTypeName = "vector";
        class md {
            constructor(t, e=-1, n, i=ke) {
                this.name = t,
                    this.tracks = n,
                    this.duration = e,
                    this.blendMode = i,
                    this.uuid = ln.generateUUID(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                    , n = t.tracks
                    , i = 1 / (t.fps || 1);
                for (let o = 0, s = n.length; o !== s; ++o)
                    e.push(vd(n[o]).scale(i));
                const r = new this(t.name,t.duration,e,t.blendMode);
                return r.uuid = t.uuid,
                    r
            }
            static toJSON(t) {
                const e = []
                    , n = t.tracks
                    , i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let r = 0, o = n.length; r !== o; ++r)
                    e.push(ad.toJSON(n[r]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length
                    , o = [];
                for (let s = 0; s < r; s++) {
                    let t = []
                        , a = [];
                    t.push((s + r - 1) % r, s, (s + 1) % r),
                        a.push(0, 1, 0);
                    const c = nd.getKeyframeOrder(t);
                    t = nd.sortedArray(t, 1, c),
                        a = nd.sortedArray(a, 1, c),
                    i || 0 !== t[0] || (t.push(r),
                        a.push(a[0])),
                        o.push(new ud(".morphTargetInfluences[" + e[s].name + "]",t,a).scale(1 / n))
                }
                return new this(t,-1,o)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let i = 0; i < n.length; i++)
                    if (n[i].name === e)
                        return n[i];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {}
                    , r = /^([\w-]*?)([\d]+)$/;
                for (let s = 0, a = t.length; s < a; s++) {
                    const e = t[s]
                        , n = e.name.match(r);
                    if (n && n.length > 1) {
                        const t = n[1];
                        let r = i[t];
                        r || (i[t] = r = []),
                            r.push(e)
                    }
                }
                const o = [];
                for (const s in i)
                    o.push(this.CreateFromMorphTargetSequence(s, i[s], e, n));
                return o
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                        null;
                const n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        const o = []
                            , s = [];
                        nd.flattenJSON(n, o, s, i),
                        0 !== o.length && r.push(new t(e,o,s))
                    }
                }
                    , i = []
                    , r = t.name || "default"
                    , o = t.fps || 30
                    , s = t.blendMode;
                let a = t.length || -1;
                const c = t.hierarchy || [];
                for (let u = 0; u < c.length; u++) {
                    const t = c[u].keys;
                    if (t && 0 !== t.length)
                        if (t[0].morphTargets) {
                            const e = {};
                            let n;
                            for (n = 0; n < t.length; n++)
                                if (t[n].morphTargets)
                                    for (let i = 0; i < t[n].morphTargets.length; i++)
                                        e[t[n].morphTargets[i]] = -1;
                            for (const r in e) {
                                const e = []
                                    , o = [];
                                for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                                    const i = t[n];
                                    e.push(i.time),
                                        o.push(i.morphTarget === r ? 1 : 0)
                                }
                                i.push(new ud(".morphTargetInfluence[" + r + "]",e,o))
                            }
                            a = e.length * (o || 1)
                        } else {
                            const r = ".bones[" + e[u].name + "]";
                            n(fd, r + ".position", t, "pos", i),
                                n(dd, r + ".quaternion", t, "rot", i),
                                n(fd, r + ".scale", t, "scl", i)
                        }
                }
                if (0 === i.length)
                    return null;
                const l = new this(r,a,i,s);
                return l
            }
            resetDuration() {
                const t = this.tracks;
                let e = 0;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    const t = this.tracks[n];
                    e = Math.max(e, t.times[t.times.length - 1])
                }
                return this.duration = e,
                    this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function gd(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return ud;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return fd;
                case "color":
                    return ld;
                case "quaternion":
                    return dd;
                case "bool":
                case "boolean":
                    return cd;
                case "string":
                    return pd
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }
        function vd(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = gd(t.type);
            if (void 0 === t.times) {
                const e = []
                    , n = [];
                nd.flattenJSON(t.keys, e, n, "value"),
                    t.times = e,
                    t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        const yd = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        function _d(t, e, n) {
            const i = this;
            let r = !1
                , o = 0
                , s = 0
                , a = void 0;
            const c = [];
            this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    s++,
                    !1 === r && void 0 !== i.onStart && i.onStart(t, o, s),
                        r = !0
                }
                ,
                this.itemEnd = function(t) {
                    o++,
                    void 0 !== i.onProgress && i.onProgress(t, o, s),
                    o === s && (r = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return a ? a(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return a = t,
                        this
                }
                ,
                this.addHandler = function(t, e) {
                    return c.push(t, e),
                        this
                }
                ,
                this.removeHandler = function(t) {
                    const e = c.indexOf(t);
                    return -1 !== e && c.splice(e, 2),
                        this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = c.length; e < n; e += 2) {
                        const n = c[e]
                            , i = c[e + 1];
                        if (n.global && (n.lastIndex = 0),
                            n.test(t))
                            return i
                    }
                    return null
                }
        }
        const xd = new _d;
        function bd(t) {
            this.manager = void 0 !== t ? t : xd,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
        }
        Object.assign(bd.prototype, {
            load: function() {},
            loadAsync: function(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                        n.load(t, i, e, r)
                    }
                ))
            },
            parse: function() {},
            setCrossOrigin: function(t) {
                return this.crossOrigin = t,
                    this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t,
                    this
            },
            setPath: function(t) {
                return this.path = t,
                    this
            },
            setResourcePath: function(t) {
                return this.resourcePath = t,
                    this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t,
                    this
            }
        });
        const wd = {};
        function Md(t) {
            bd.call(this, t)
        }
        Md.prototype = Object.assign(Object.create(bd.prototype), {
            constructor: Md,
            load: function(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                    t = this.manager.resolveURL(t);
                const r = this
                    , o = yd.get(t);
                if (void 0 !== o)
                    return r.manager.itemStart(t),
                        setTimeout((function() {
                                e && e(o),
                                    r.manager.itemEnd(t)
                            }
                        ), 0),
                        o;
                if (void 0 !== wd[t])
                    return void wd[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                const s = /^data:(.*?)(;base64)?,(.*)$/
                    , a = t.match(s);
                let c;
                if (a) {
                    const n = a[1]
                        , o = !!a[2];
                    let s = a[3];
                    s = decodeURIComponent(s),
                    o && (s = atob(s));
                    try {
                        let i;
                        const o = (this.responseType || "").toLowerCase();
                        switch (o) {
                            case "arraybuffer":
                            case "blob":
                                const t = new Uint8Array(s.length);
                                for (let n = 0; n < s.length; n++)
                                    t[n] = s.charCodeAt(n);
                                i = "blob" === o ? new Blob([t.buffer],{
                                    type: n
                                }) : t.buffer;
                                break;
                            case "document":
                                const e = new DOMParser;
                                i = e.parseFromString(s, n);
                                break;
                            case "json":
                                i = JSON.parse(s);
                                break;
                            default:
                                i = s;
                                break
                        }
                        setTimeout((function() {
                                e && e(i),
                                    r.manager.itemEnd(t)
                            }
                        ), 0)
                    } catch (l) {
                        setTimeout((function() {
                                i && i(l),
                                    r.manager.itemError(t),
                                    r.manager.itemEnd(t)
                            }
                        ), 0)
                    }
                } else {
                    wd[t] = [],
                        wd[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: i
                        }),
                        c = new XMLHttpRequest,
                        c.open("GET", t, !0),
                        c.addEventListener("load", (function(e) {
                                const n = this.response
                                    , i = wd[t];
                                if (delete wd[t],
                                200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                                        yd.add(t, n);
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        const e = i[t];
                                        e.onLoad && e.onLoad(n)
                                    }
                                    r.manager.itemEnd(t)
                                } else {
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e)
                                    }
                                    r.manager.itemError(t),
                                        r.manager.itemEnd(t)
                                }
                            }
                        ), !1),
                        c.addEventListener("progress", (function(e) {
                                const n = wd[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onProgress && i.onProgress(e)
                                }
                            }
                        ), !1),
                        c.addEventListener("error", (function(e) {
                                const n = wd[t];
                                delete wd[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t),
                                    r.manager.itemEnd(t)
                            }
                        ), !1),
                        c.addEventListener("abort", (function(e) {
                                const n = wd[t];
                                delete wd[t];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    i.onError && i.onError(e)
                                }
                                r.manager.itemError(t),
                                    r.manager.itemEnd(t)
                            }
                        ), !1),
                    void 0 !== this.responseType && (c.responseType = this.responseType),
                    void 0 !== this.withCredentials && (c.withCredentials = this.withCredentials),
                    c.overrideMimeType && c.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const t in this.requestHeader)
                        c.setRequestHeader(t, this.requestHeader[t]);
                    c.send(null)
                }
                return r.manager.itemStart(t),
                    c
            },
            setResponseType: function(t) {
                return this.responseType = t,
                    this
            },
            setMimeType: function(t) {
                return this.mimeType = t,
                    this
            }
        });
        function Sd(t) {
            bd.call(this, t)
        }
        Sd.prototype = Object.assign(Object.create(bd.prototype), {
            constructor: Sd,
            load: function(t, e, n, i) {
                const r = this
                    , o = []
                    , s = new th
                    , a = new Md(this.manager);
                a.setPath(this.path),
                    a.setResponseType("arraybuffer"),
                    a.setRequestHeader(this.requestHeader),
                    a.setWithCredentials(r.withCredentials);
                let c = 0;
                function l(l) {
                    a.load(t[l], (function(t) {
                            const n = r.parse(t, !0);
                            o[l] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            },
                                c += 1,
                            6 === c && (1 === n.mipmapCount && (s.minFilter = ft),
                                s.image = o,
                                s.format = n.format,
                                s.needsUpdate = !0,
                            e && e(s))
                        }
                    ), n, i)
                }
                if (Array.isArray(t))
                    for (let u = 0, h = t.length; u < h; ++u)
                        l(u);
                else
                    a.load(t, (function(t) {
                            const n = r.parse(t, !0);
                            if (n.isCubemap) {
                                const t = n.mipmaps.length / n.mipmapCount;
                                for (let e = 0; e < t; e++) {
                                    o[e] = {
                                        mipmaps: []
                                    };
                                    for (let t = 0; t < n.mipmapCount; t++)
                                        o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                                            o[e].format = n.format,
                                            o[e].width = n.width,
                                            o[e].height = n.height
                                }
                                s.image = o
                            } else
                                s.image.width = n.width,
                                    s.image.height = n.height,
                                    s.mipmaps = n.mipmaps;
                            1 === n.mipmapCount && (s.minFilter = ft),
                                s.format = n.format,
                                s.needsUpdate = !0,
                            e && e(s)
                        }
                    ), n, i);
                return s
            }
        });
        class Ed extends bd {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t),
                    t = this.manager.resolveURL(t);
                const r = this
                    , o = yd.get(t);
                if (void 0 !== o)
                    return r.manager.itemStart(t),
                        setTimeout((function() {
                                e && e(o),
                                    r.manager.itemEnd(t)
                            }
                        ), 0),
                        o;
                const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                function a() {
                    s.removeEventListener("load", a, !1),
                        s.removeEventListener("error", c, !1),
                        yd.add(t, this),
                    e && e(this),
                        r.manager.itemEnd(t)
                }
                function c(e) {
                    s.removeEventListener("load", a, !1),
                        s.removeEventListener("error", c, !1),
                    i && i(e),
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                }
                return s.addEventListener("load", a, !1),
                    s.addEventListener("error", c, !1),
                "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                    r.manager.itemStart(t),
                    s.src = t,
                    s
            }
        }
        class Td extends bd {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new Zr
                    , o = new Ed(this.manager);
                o.setCrossOrigin(this.crossOrigin),
                    o.setPath(this.path);
                let s = 0;
                function a(n) {
                    o.load(t[n], (function(t) {
                            r.images[n] = t,
                                s++,
                            6 === s && (r.needsUpdate = !0,
                            e && e(r))
                        }
                    ), void 0, i)
                }
                for (let c = 0; c < t.length; ++c)
                    a(c);
                return r
            }
        }
        function Ad(t) {
            bd.call(this, t)
        }
        function Ld(t) {
            bd.call(this, t)
        }
        function Rd() {
            this.type = "Curve",
                this.arcLengthDivisions = 200
        }
        Ad.prototype = Object.assign(Object.create(bd.prototype), {
            constructor: Ad,
            load: function(t, e, n, i) {
                const r = this
                    , o = new Kr
                    , s = new Md(this.manager);
                return s.setResponseType("arraybuffer"),
                    s.setRequestHeader(this.requestHeader),
                    s.setPath(this.path),
                    s.setWithCredentials(r.withCredentials),
                    s.load(t, (function(t) {
                            const n = r.parse(t);
                            n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                                o.image.height = n.height,
                                o.image.data = n.data),
                                o.wrapS = void 0 !== n.wrapS ? n.wrapS : lt,
                                o.wrapT = void 0 !== n.wrapT ? n.wrapT : lt,
                                o.magFilter = void 0 !== n.magFilter ? n.magFilter : ft,
                                o.minFilter = void 0 !== n.minFilter ? n.minFilter : ft,
                                o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                            void 0 !== n.encoding && (o.encoding = n.encoding),
                            void 0 !== n.flipY && (o.flipY = n.flipY),
                            void 0 !== n.format && (o.format = n.format),
                            void 0 !== n.type && (o.type = n.type),
                            void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps,
                                o.minFilter = gt),
                            1 === n.mipmapCount && (o.minFilter = ft),
                            void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps),
                                o.needsUpdate = !0,
                            e && e(o, n))
                        }
                    ), n, i),
                    o
            }
        }),
            Ld.prototype = Object.assign(Object.create(bd.prototype), {
                constructor: Ld,
                load: function(t, e, n, i) {
                    const r = new mn
                        , o = new Ed(this.manager);
                    return o.setCrossOrigin(this.crossOrigin),
                        o.setPath(this.path),
                        o.load(t, (function(n) {
                                r.image = n;
                                const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                                r.format = i ? Ct : Pt,
                                    r.needsUpdate = !0,
                                void 0 !== e && e(r)
                            }
                        ), n, i),
                        r
                }
            }),
            Object.assign(Rd.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."),
                        null
                },
                getPointAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t=5) {
                    const e = [];
                    for (let n = 0; n <= t; n++)
                        e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t=5) {
                    const e = [];
                    for (let n = 0; n <= t; n++)
                        e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions),
                    this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                        return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n, i = this.getPoint(0), r = 0;
                    e.push(0);
                    for (let o = 1; o <= t; o++)
                        n = this.getPoint(o / t),
                            r += n.distanceTo(i),
                            e.push(r),
                            i = n;
                    return this.cacheArcLengths = e,
                        e
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0,
                        this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let o;
                    o = e || t * n[r - 1];
                    let s, a = 0, c = r - 1;
                    while (a <= c)
                        if (i = Math.floor(a + (c - a) / 2),
                            s = n[i] - o,
                        s < 0)
                            a = i + 1;
                        else {
                            if (!(s > 0)) {
                                c = i;
                                break
                            }
                            c = i - 1
                        }
                    if (i = c,
                    n[i] === o)
                        return i / (r - 1);
                    const l = n[i]
                        , u = n[i + 1]
                        , h = u - l
                        , d = (o - l) / h
                        , p = (i + d) / (r - 1);
                    return p
                },
                getTangent: function(t, e) {
                    const n = 1e-4;
                    let i = t - n
                        , r = t + n;
                    i < 0 && (i = 0),
                    r > 1 && (r = 1);
                    const o = this.getPoint(i)
                        , s = this.getPoint(r)
                        , a = e || (o.isVector2 ? new un : new bn);
                    return a.copy(s).sub(o).normalize(),
                        a
                },
                getTangentAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e)
                },
                computeFrenetFrames: function(t, e) {
                    const n = new bn
                        , i = []
                        , r = []
                        , o = []
                        , s = new bn
                        , a = new Qn;
                    for (let d = 0; d <= t; d++) {
                        const e = d / t;
                        i[d] = this.getTangentAt(e, new bn),
                            i[d].normalize()
                    }
                    r[0] = new bn,
                        o[0] = new bn;
                    let c = Number.MAX_VALUE;
                    const l = Math.abs(i[0].x)
                        , u = Math.abs(i[0].y)
                        , h = Math.abs(i[0].z);
                    l <= c && (c = l,
                        n.set(1, 0, 0)),
                    u <= c && (c = u,
                        n.set(0, 1, 0)),
                    h <= c && n.set(0, 0, 1),
                        s.crossVectors(i[0], n).normalize(),
                        r[0].crossVectors(i[0], s),
                        o[0].crossVectors(i[0], r[0]);
                    for (let d = 1; d <= t; d++) {
                        if (r[d] = r[d - 1].clone(),
                            o[d] = o[d - 1].clone(),
                            s.crossVectors(i[d - 1], i[d]),
                        s.length() > Number.EPSILON) {
                            s.normalize();
                            const t = Math.acos(ln.clamp(i[d - 1].dot(i[d]), -1, 1));
                            r[d].applyMatrix4(a.makeRotationAxis(s, t))
                        }
                        o[d].crossVectors(i[d], r[d])
                    }
                    if (!0 === e) {
                        let e = Math.acos(ln.clamp(r[0].dot(r[t]), -1, 1));
                        e /= t,
                        i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let n = 1; n <= t; n++)
                            r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                                o[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: o
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions,
                        this
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions,
                        t.type = this.type,
                        t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions,
                        this
                }
            });
        class Cd extends Rd {
            constructor(t=0, e=0, n=1, i=1, r=0, o=2 * Math.PI, s=!1, a=0) {
                super(),
                    this.type = "EllipseCurve",
                    this.aX = t,
                    this.aY = e,
                    this.xRadius = n,
                    this.yRadius = i,
                    this.aStartAngle = r,
                    this.aEndAngle = o,
                    this.aClockwise = s,
                    this.aRotation = a
            }
            getPoint(t, e) {
                const n = e || new un
                    , i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(r) < Number.EPSILON;
                while (r < 0)
                    r += i;
                while (r > i)
                    r -= i;
                r < Number.EPSILON && (r = o ? 0 : i),
                !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
                const s = this.aStartAngle + t * r;
                let a = this.aX + this.xRadius * Math.cos(s)
                    , c = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation)
                        , e = Math.sin(this.aRotation)
                        , n = a - this.aX
                        , i = c - this.aY;
                    a = n * t - i * e + this.aX,
                        c = n * e + i * t + this.aY
                }
                return n.set(a, c)
            }
            copy(t) {
                return super.copy(t),
                    this.aX = t.aX,
                    this.aY = t.aY,
                    this.xRadius = t.xRadius,
                    this.yRadius = t.yRadius,
                    this.aStartAngle = t.aStartAngle,
                    this.aEndAngle = t.aEndAngle,
                    this.aClockwise = t.aClockwise,
                    this.aRotation = t.aRotation,
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX,
                    t.aY = this.aY,
                    t.xRadius = this.xRadius,
                    t.yRadius = this.yRadius,
                    t.aStartAngle = this.aStartAngle,
                    t.aEndAngle = this.aEndAngle,
                    t.aClockwise = this.aClockwise,
                    t.aRotation = this.aRotation,
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.aX = t.aX,
                    this.aY = t.aY,
                    this.xRadius = t.xRadius,
                    this.yRadius = t.yRadius,
                    this.aStartAngle = t.aStartAngle,
                    this.aEndAngle = t.aEndAngle,
                    this.aClockwise = t.aClockwise,
                    this.aRotation = t.aRotation,
                    this
            }
        }
        Cd.prototype.isEllipseCurve = !0;
        class Pd extends Cd {
            constructor(t, e, n, i, r, o) {
                super(t, e, n, n, i, r, o),
                    this.type = "ArcCurve"
            }
        }
        function Od() {
            let t = 0
                , e = 0
                , n = 0
                , i = 0;
            function r(r, o, s, a) {
                t = r,
                    e = s,
                    n = -3 * r + 3 * o - 2 * s - a,
                    i = 2 * r - 2 * o + s + a
            }
            return {
                initCatmullRom: function(t, e, n, i, o) {
                    r(e, n, o * (n - t), o * (i - e))
                },
                initNonuniformCatmullRom: function(t, e, n, i, o, s, a) {
                    let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s
                        , l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
                    c *= s,
                        l *= s,
                        r(e, n, c, l)
                },
                calc: function(r) {
                    const o = r * r
                        , s = o * r;
                    return t + e * r + n * o + i * s
                }
            }
        }
        Pd.prototype.isArcCurve = !0;
        const Id = new bn
            , Nd = new Od
            , Dd = new Od
            , Fd = new Od;
        class kd extends Rd {
            constructor(t=[], e=!1, n="centripetal", i=.5) {
                super(),
                    this.type = "CatmullRomCurve3",
                    this.points = t,
                    this.closed = e,
                    this.curveType = n,
                    this.tension = i
            }
            getPoint(t, e=new bn) {
                const n = e
                    , i = this.points
                    , r = i.length
                    , o = (r - (this.closed ? 0 : 1)) * t;
                let s, a, c = Math.floor(o), l = o - c;
                this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r : 0 === l && c === r - 1 && (c = r - 2,
                    l = 1),
                    this.closed || c > 0 ? s = i[(c - 1) % r] : (Id.subVectors(i[0], i[1]).add(i[0]),
                        s = Id);
                const u = i[c % r]
                    , h = i[(c + 1) % r];
                if (this.closed || c + 2 < r ? a = i[(c + 2) % r] : (Id.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                    a = Id),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(s.distanceToSquared(u), t)
                        , n = Math.pow(u.distanceToSquared(h), t)
                        , i = Math.pow(h.distanceToSquared(a), t);
                    n < 1e-4 && (n = 1),
                    e < 1e-4 && (e = n),
                    i < 1e-4 && (i = n),
                        Nd.initNonuniformCatmullRom(s.x, u.x, h.x, a.x, e, n, i),
                        Dd.initNonuniformCatmullRom(s.y, u.y, h.y, a.y, e, n, i),
                        Fd.initNonuniformCatmullRom(s.z, u.z, h.z, a.z, e, n, i)
                } else
                    "catmullrom" === this.curveType && (Nd.initCatmullRom(s.x, u.x, h.x, a.x, this.tension),
                        Dd.initCatmullRom(s.y, u.y, h.y, a.y, this.tension),
                        Fd.initCatmullRom(s.z, u.z, h.z, a.z, this.tension));
                return n.set(Nd.calc(l), Dd.calc(l), Fd.calc(l)),
                    n
            }
            copy(t) {
                super.copy(t),
                    this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed,
                    this.curveType = t.curveType,
                    this.tension = t.tension,
                    this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed,
                    t.curveType = this.curveType,
                    t.tension = this.tension,
                    t
            }
            fromJSON(t) {
                super.fromJSON(t),
                    this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new bn).fromArray(n))
                }
                return this.closed = t.closed,
                    this.curveType = t.curveType,
                    this.tension = t.tension,
                    this
            }
        }
        function Hd(t, e, n, i, r) {
            const o = .5 * (i - e)
                , s = .5 * (r - n)
                , a = t * t
                , c = t * a;
            return (2 * n - 2 * i + o + s) * c + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n
        }
        function Bd(t, e) {
            const n = 1 - t;
            return n * n * e
        }
        function zd(t, e) {
            return 2 * (1 - t) * t * e
        }
        function Ud(t, e) {
            return t * t * e
        }
        function jd(t, e, n, i) {
            return Bd(t, e) + zd(t, n) + Ud(t, i)
        }
        function Gd(t, e) {
            const n = 1 - t;
            return n * n * n * e
        }
        function Vd(t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e
        }
        function Wd(t, e) {
            return 3 * (1 - t) * t * t * e
        }
        function qd(t, e) {
            return t * t * t * e
        }
        function Xd(t, e, n, i, r) {
            return Gd(t, e) + Vd(t, n) + Wd(t, i) + qd(t, r)
        }
        kd.prototype.isCatmullRomCurve3 = !0;
        class Yd extends Rd {
            constructor(t=new un, e=new un, n=new un, i=new un) {
                super(),
                    this.type = "CubicBezierCurve",
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = n,
                    this.v3 = i
            }
            getPoint(t, e=new un) {
                const n = e
                    , i = this.v0
                    , r = this.v1
                    , o = this.v2
                    , s = this.v3;
                return n.set(Xd(t, i.x, r.x, o.x, s.x), Xd(t, i.y, r.y, o.y, s.y)),
                    n
            }
            copy(t) {
                return super.copy(t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this.v3.copy(t.v3),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                    t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t.v3 = this.v3.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this.v3.fromArray(t.v3),
                    this
            }
        }
        Yd.prototype.isCubicBezierCurve = !0;
        class Zd extends Rd {
            constructor(t=new bn, e=new bn, n=new bn, i=new bn) {
                super(),
                    this.type = "CubicBezierCurve3",
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = n,
                    this.v3 = i
            }
            getPoint(t, e=new bn) {
                const n = e
                    , i = this.v0
                    , r = this.v1
                    , o = this.v2
                    , s = this.v3;
                return n.set(Xd(t, i.x, r.x, o.x, s.x), Xd(t, i.y, r.y, o.y, s.y), Xd(t, i.z, r.z, o.z, s.z)),
                    n
            }
            copy(t) {
                return super.copy(t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this.v3.copy(t.v3),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                    t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t.v3 = this.v3.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this.v3.fromArray(t.v3),
                    this
            }
        }
        Zd.prototype.isCubicBezierCurve3 = !0;
        class Jd extends Rd {
            constructor(t=new un, e=new un) {
                super(),
                    this.type = "LineCurve",
                    this.v1 = t,
                    this.v2 = e
            }
            getPoint(t, e=new un) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(t).add(this.v1)),
                    n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const n = e || new un;
                return n.copy(this.v2).sub(this.v1).normalize(),
                    n
            }
            copy(t) {
                return super.copy(t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
            }
        }
        Jd.prototype.isLineCurve = !0;
        class Kd extends Rd {
            constructor(t=new bn, e=new bn) {
                super(),
                    this.type = "LineCurve3",
                    this.isLineCurve3 = !0,
                    this.v1 = t,
                    this.v2 = e
            }
            getPoint(t, e=new bn) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(t).add(this.v1)),
                    n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            copy(t) {
                return super.copy(t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
            }
        }
        class Qd extends Rd {
            constructor(t=new un, e=new un, n=new un) {
                super(),
                    this.type = "QuadraticBezierCurve",
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = n
            }
            getPoint(t, e=new un) {
                const n = e
                    , i = this.v0
                    , r = this.v1
                    , o = this.v2;
                return n.set(jd(t, i.x, r.x, o.x), jd(t, i.y, r.y, o.y)),
                    n
            }
            copy(t) {
                return super.copy(t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                    t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
            }
        }
        Qd.prototype.isQuadraticBezierCurve = !0;
        class $d extends Rd {
            constructor(t=new bn, e=new bn, n=new bn) {
                super(),
                    this.type = "QuadraticBezierCurve3",
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = n
            }
            getPoint(t, e=new bn) {
                const n = e
                    , i = this.v0
                    , r = this.v1
                    , o = this.v2;
                return n.set(jd(t, i.x, r.x, o.x), jd(t, i.y, r.y, o.y), jd(t, i.z, r.z, o.z)),
                    n
            }
            copy(t) {
                return super.copy(t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                    t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
            }
        }
        $d.prototype.isQuadraticBezierCurve3 = !0;
        class tp extends Rd {
            constructor(t=[]) {
                super(),
                    this.type = "SplineCurve",
                    this.points = t
            }
            getPoint(t, e=new un) {
                const n = e
                    , i = this.points
                    , r = (i.length - 1) * t
                    , o = Math.floor(r)
                    , s = r - o
                    , a = i[0 === o ? o : o - 1]
                    , c = i[o]
                    , l = i[o > i.length - 2 ? i.length - 1 : o + 1]
                    , u = i[o > i.length - 3 ? i.length - 1 : o + 2];
                return n.set(Hd(s, a.x, c.x, l.x, u.x), Hd(s, a.y, c.y, l.y, u.y)),
                    n
            }
            copy(t) {
                super.copy(t),
                    this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                    this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new un).fromArray(n))
                }
                return this
            }
        }
        tp.prototype.isSplineCurve = !0;
        var ep = Object.freeze({
            __proto__: null,
            ArcCurve: Pd,
            CatmullRomCurve3: kd,
            CubicBezierCurve: Yd,
            CubicBezierCurve3: Zd,
            EllipseCurve: Cd,
            LineCurve: Jd,
            LineCurve3: Kd,
            QuadraticBezierCurve: Qd,
            QuadraticBezierCurve3: $d,
            SplineCurve: tp
        });
        class np extends Rd {
            constructor() {
                super(),
                    this.type = "CurvePath",
                    this.curves = [],
                    this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0)
                    , e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Jd(e,t))
            }
            getPoint(t) {
                const e = t * this.getLength()
                    , n = this.getCurveLengths();
                let i = 0;
                while (i < n.length) {
                    if (n[i] >= e) {
                        const t = n[i] - e
                            , r = this.curves[i]
                            , o = r.getLength()
                            , s = 0 === o ? 0 : 1 - t / o;
                        return r.getPointAt(s)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                    this.cacheLengths = null,
                    this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, i = this.curves.length; n < i; n++)
                    e += this.curves[n].getLength(),
                        t.push(e);
                return this.cacheLengths = t,
                    t
            }
            getSpacedPoints(t=40) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]),
                    e
            }
            getPoints(t=12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const o = r[i]
                        , s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t
                        , a = o.getPoints(s);
                    for (let t = 0; t < a.length; t++) {
                        const i = a[t];
                        n && n.equals(i) || (e.push(i),
                            n = i)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                    e
            }
            copy(t) {
                super.copy(t),
                    this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose,
                    this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose,
                    t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                    this.autoClose = t.autoClose,
                    this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new ep[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class ip extends np {
            constructor(t) {
                super(),
                    this.type = "Path",
                    this.currentPoint = new un,
                t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++)
                    this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e),
                    this
            }
            lineTo(t, e) {
                const n = new Jd(this.currentPoint.clone(),new un(t,e));
                return this.curves.push(n),
                    this.currentPoint.set(t, e),
                    this
            }
            quadraticCurveTo(t, e, n, i) {
                const r = new Qd(this.currentPoint.clone(),new un(t,e),new un(n,i));
                return this.curves.push(r),
                    this.currentPoint.set(n, i),
                    this
            }
            bezierCurveTo(t, e, n, i, r, o) {
                const s = new Yd(this.currentPoint.clone(),new un(t,e),new un(n,i),new un(r,o));
                return this.curves.push(s),
                    this.currentPoint.set(r, o),
                    this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t)
                    , n = new tp(e);
                return this.curves.push(n),
                    this.currentPoint.copy(t[t.length - 1]),
                    this
            }
            arc(t, e, n, i, r, o) {
                const s = this.currentPoint.x
                    , a = this.currentPoint.y;
                return this.absarc(t + s, e + a, n, i, r, o),
                    this
            }
            absarc(t, e, n, i, r, o) {
                return this.absellipse(t, e, n, n, i, r, o),
                    this
            }
            ellipse(t, e, n, i, r, o, s, a) {
                const c = this.currentPoint.x
                    , l = this.currentPoint.y;
                return this.absellipse(t + c, e + l, n, i, r, o, s, a),
                    this
            }
            absellipse(t, e, n, i, r, o, s, a) {
                const c = new Cd(t,e,n,i,r,o,s,a);
                if (this.curves.length > 0) {
                    const t = c.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(c);
                const l = c.getPoint(1);
                return this.currentPoint.copy(l),
                    this
            }
            copy(t) {
                return super.copy(t),
                    this.currentPoint.copy(t.currentPoint),
                    this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(),
                    t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                    this.currentPoint.fromArray(t.currentPoint),
                    this
            }
        }
        class rp extends ip {
            constructor(t) {
                super(t),
                    this.uuid = ln.generateUUID(),
                    this.type = "Shape",
                    this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let n = 0, i = this.holes.length; n < i; n++)
                    e[n] = this.holes[n].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t),
                    this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid,
                    t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                    this.uuid = t.uuid,
                    this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new ip).fromJSON(n))
                }
                return this
            }
        }
        class op extends Mi {
            constructor(t, e=1) {
                super(),
                    this.type = "Light",
                    this.color = new Xi(t),
                    this.intensity = e
            }
            copy(t) {
                return super.copy(t),
                    this.color.copy(t.color),
                    this.intensity = t.intensity,
                    this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                    e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                    e
            }
        }
        op.prototype.isLight = !0;
        class sp extends op {
            constructor(t, e, n) {
                super(t, n),
                    this.type = "HemisphereLight",
                    this.position.copy(Mi.DefaultUp),
                    this.updateMatrix(),
                    this.groundColor = new Xi(e)
            }
            copy(t) {
                return op.prototype.copy.call(this, t),
                    this.groundColor.copy(t.groundColor),
                    this
            }
        }
        sp.prototype.isHemisphereLight = !0;
        const ap = new Qn
            , cp = new bn
            , lp = new bn;
        class up {
            constructor(t) {
                this.camera = t,
                    this.bias = 0,
                    this.normalBias = 0,
                    this.radius = 1,
                    this.mapSize = new un(512,512),
                    this.map = null,
                    this.mapPass = null,
                    this.matrix = new Qn,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this._frustum = new to,
                    this._frameExtents = new un(1,1),
                    this._viewportCount = 1,
                    this._viewports = [new vn(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                    , n = this.matrix;
                cp.setFromMatrixPosition(t.matrixWorld),
                    e.position.copy(cp),
                    lp.setFromMatrixPosition(t.target.matrixWorld),
                    e.lookAt(lp),
                    e.updateMatrixWorld(),
                    ap.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                    this._frustum.setFromProjectionMatrix(ap),
                    n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                    n.multiply(e.projectionMatrix),
                    n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                    this.bias = t.bias,
                    this.radius = t.radius,
                    this.mapSize.copy(t.mapSize),
                    this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                    t.camera = this.camera.toJSON(!1).object,
                    delete t.camera.matrix,
                    t
            }
        }
        class hp extends up {
            constructor() {
                super(new Wr(50,1,.5,500)),
                    this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                    , n = 2 * ln.RAD2DEG * t.angle * this.focus
                    , i = this.mapSize.width / this.mapSize.height
                    , r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
                    e.aspect = i,
                    e.far = r,
                    e.updateProjectionMatrix()),
                    super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t),
                    this.focus = t.focus,
                    this
            }
        }
        hp.prototype.isSpotLightShadow = !0;
        class dp extends op {
            constructor(t, e, n=0, i=Math.PI / 3, r=0, o=1) {
                super(t, e),
                    this.type = "SpotLight",
                    this.position.copy(Mi.DefaultUp),
                    this.updateMatrix(),
                    this.target = new Mi,
                    this.distance = n,
                    this.angle = i,
                    this.penumbra = r,
                    this.decay = o,
                    this.shadow = new hp
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            copy(t) {
                return super.copy(t),
                    this.distance = t.distance,
                    this.angle = t.angle,
                    this.penumbra = t.penumbra,
                    this.decay = t.decay,
                    this.target = t.target.clone(),
                    this.shadow = t.shadow.clone(),
                    this
            }
        }
        dp.prototype.isSpotLight = !0;
        const pp = new Qn
            , fp = new bn
            , mp = new bn;
        class gp extends up {
            constructor() {
                super(new Wr(90,1,.5,500)),
                    this._frameExtents = new un(4,2),
                    this._viewportCount = 6,
                    this._viewports = [new vn(2,1,1,1), new vn(0,1,1,1), new vn(3,1,1,1), new vn(1,1,1,1), new vn(3,0,1,1), new vn(1,0,1,1)],
                    this._cubeDirections = [new bn(1,0,0), new bn(-1,0,0), new bn(0,0,1), new bn(0,0,-1), new bn(0,1,0), new bn(0,-1,0)],
                    this._cubeUps = [new bn(0,1,0), new bn(0,1,0), new bn(0,1,0), new bn(0,1,0), new bn(0,0,1), new bn(0,0,-1)]
            }
            updateMatrices(t, e=0) {
                const n = this.camera
                    , i = this.matrix
                    , r = t.distance || n.far;
                r !== n.far && (n.far = r,
                    n.updateProjectionMatrix()),
                    fp.setFromMatrixPosition(t.matrixWorld),
                    n.position.copy(fp),
                    mp.copy(n.position),
                    mp.add(this._cubeDirections[e]),
                    n.up.copy(this._cubeUps[e]),
                    n.lookAt(mp),
                    n.updateMatrixWorld(),
                    i.makeTranslation(-fp.x, -fp.y, -fp.z),
                    pp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                    this._frustum.setFromProjectionMatrix(pp)
            }
        }
        gp.prototype.isPointLightShadow = !0;
        class vp extends op {
            constructor(t, e, n=0, i=1) {
                super(t, e),
                    this.type = "PointLight",
                    this.distance = n,
                    this.decay = i,
                    this.shadow = new gp
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            copy(t) {
                return super.copy(t),
                    this.distance = t.distance,
                    this.decay = t.decay,
                    this.shadow = t.shadow.clone(),
                    this
            }
        }
        vp.prototype.isPointLight = !0;
        class yp extends Vr {
            constructor(t=-1, e=1, n=1, i=-1, r=.1, o=2e3) {
                super(),
                    this.type = "OrthographicCamera",
                    this.zoom = 1,
                    this.view = null,
                    this.left = t,
                    this.right = e,
                    this.top = n,
                    this.bottom = i,
                    this.near = r,
                    this.far = o,
                    this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                    this.left = t.left,
                    this.right = t.right,
                    this.top = t.top,
                    this.bottom = t.bottom,
                    this.near = t.near,
                    this.far = t.far,
                    this.zoom = t.zoom,
                    this.view = null === t.view ? null : Object.assign({}, t.view),
                    this
            }
            setViewOffset(t, e, n, i, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                    this.view.enabled = !0,
                    this.view.fullWidth = t,
                    this.view.fullHeight = e,
                    this.view.offsetX = n,
                    this.view.offsetY = i,
                    this.view.width = r,
                    this.view.height = o,
                    this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                    , e = (this.top - this.bottom) / (2 * this.zoom)
                    , n = (this.right + this.left) / 2
                    , i = (this.top + this.bottom) / 2;
                let r = n - t
                    , o = n + t
                    , s = i + e
                    , a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                        , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                        o = r + t * this.view.width,
                        s -= e * this.view.offsetY,
                        a = s - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
                    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = Mi.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom,
                    e.object.left = this.left,
                    e.object.right = this.right,
                    e.object.top = this.top,
                    e.object.bottom = this.bottom,
                    e.object.near = this.near,
                    e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                    e
            }
        }
        yp.prototype.isOrthographicCamera = !0;
        class _p extends up {
            constructor() {
                super(new yp(-5,5,5,-5,.5,500))
            }
        }
        _p.prototype.isDirectionalLightShadow = !0;
        class xp extends op {
            constructor(t, e) {
                super(t, e),
                    this.type = "DirectionalLight",
                    this.position.copy(Mi.DefaultUp),
                    this.updateMatrix(),
                    this.target = new Mi,
                    this.shadow = new _p
            }
            copy(t) {
                return super.copy(t),
                    this.target = t.target.clone(),
                    this.shadow = t.shadow.clone(),
                    this
            }
        }
        xp.prototype.isDirectionalLight = !0;
        class bp extends op {
            constructor(t, e) {
                super(t, e),
                    this.type = "AmbientLight"
            }
        }
        bp.prototype.isAmbientLight = !0;
        class wp extends op {
            constructor(t, e, n=10, i=10) {
                super(t, e),
                    this.type = "RectAreaLight",
                    this.width = n,
                    this.height = i
            }
            copy(t) {
                return super.copy(t),
                    this.width = t.width,
                    this.height = t.height,
                    this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width,
                    e.object.height = this.height,
                    e
            }
        }
        wp.prototype.isRectAreaLight = !0;
        class Mp {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++)
                    this.coefficients.push(new bn)
            }
            set(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x
                    , i = t.y
                    , r = t.z
                    , o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.282095),
                    e.addScaledVector(o[1], .488603 * i),
                    e.addScaledVector(o[2], .488603 * r),
                    e.addScaledVector(o[3], .488603 * n),
                    e.addScaledVector(o[4], n * i * 1.092548),
                    e.addScaledVector(o[5], i * r * 1.092548),
                    e.addScaledVector(o[6], .315392 * (3 * r * r - 1)),
                    e.addScaledVector(o[7], n * r * 1.092548),
                    e.addScaledVector(o[8], .546274 * (n * n - i * i)),
                    e
            }
            getIrradianceAt(t, e) {
                const n = t.x
                    , i = t.y
                    , r = t.z
                    , o = this.coefficients;
                return e.copy(o[0]).multiplyScalar(.886227),
                    e.addScaledVector(o[1], 1.023328 * i),
                    e.addScaledVector(o[2], 1.023328 * r),
                    e.addScaledVector(o[3], 1.023328 * n),
                    e.addScaledVector(o[4], .858086 * n * i),
                    e.addScaledVector(o[5], .858086 * i * r),
                    e.addScaledVector(o[6], .743125 * r * r - .247708),
                    e.addScaledVector(o[7], .858086 * n * r),
                    e.addScaledVector(o[8], .429043 * (n * n - i * i)),
                    e
            }
            add(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray(t=[], e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x
                    , i = t.y
                    , r = t.z;
                e[0] = .282095,
                    e[1] = .488603 * i,
                    e[2] = .488603 * r,
                    e[3] = .488603 * n,
                    e[4] = 1.092548 * n * i,
                    e[5] = 1.092548 * i * r,
                    e[6] = .315392 * (3 * r * r - 1),
                    e[7] = 1.092548 * n * r,
                    e[8] = .546274 * (n * n - i * i)
            }
        }
        Mp.prototype.isSphericalHarmonics3 = !0;
        class Sp extends op {
            constructor(t=new Mp, e=1) {
                super(void 0, e),
                    this.sh = t
            }
            copy(t) {
                return super.copy(t),
                    this.sh.copy(t.sh),
                    this
            }
            fromJSON(t) {
                return this.intensity = t.intensity,
                    this.sh.fromArray(t.sh),
                    this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(),
                    e
            }
        }
        Sp.prototype.isLightProbe = !0;
        const Ep = {
            decodeText: function(t) {
                if ("undefined" !== typeof TextDecoder)
                    return (new TextDecoder).decode(t);
                let e = "";
                for (let i = 0, r = t.length; i < r; i++)
                    e += String.fromCharCode(t[i]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (n) {
                    return e
                }
            },
            extractUrlBase: function(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        };
        function Tp() {
            gr.call(this),
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
        }
        function Ap(t, e, n, i) {
            "number" === typeof n && (i = n,
                n = !1,
                console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
                Ki.call(this, t, e, n),
                this.meshPerAttribute = i || 1
        }
        Tp.prototype = Object.assign(Object.create(gr.prototype), {
            constructor: Tp,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return gr.prototype.copy.call(this, t),
                    this.instanceCount = t.instanceCount,
                    this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                const t = gr.prototype.toJSON.call(this);
                return t.instanceCount = this.instanceCount,
                    t.isInstancedBufferGeometry = !0,
                    t
            }
        }),
            Ap.prototype = Object.assign(Object.create(Ki.prototype), {
                constructor: Ap,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return Ki.prototype.copy.call(this, t),
                        this.meshPerAttribute = t.meshPerAttribute,
                        this
                },
                toJSON: function() {
                    const t = Ki.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute,
                        t.isInstancedBufferAttribute = !0,
                        t
                }
            });
        function Lp(t) {
            "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                bd.call(this, t),
                this.options = {
                    premultiplyAlpha: "none"
                }
        }
        Lp.prototype = Object.assign(Object.create(bd.prototype), {
            constructor: Lp,
            isImageBitmapLoader: !0,
            setOptions: function(t) {
                return this.options = t,
                    this
            },
            load: function(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                    t = this.manager.resolveURL(t);
                const r = this
                    , o = yd.get(t);
                if (void 0 !== o)
                    return r.manager.itemStart(t),
                        setTimeout((function() {
                                e && e(o),
                                    r.manager.itemEnd(t)
                            }
                        ), 0),
                        o;
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                    s.headers = this.requestHeader,
                    fetch(t, s).then((function(t) {
                            return t.blob()
                        }
                    )).then((function(t) {
                            return createImageBitmap(t, Object.assign(r.options, {
                                colorSpaceConversion: "none"
                            }))
                        }
                    )).then((function(n) {
                            yd.add(t, n),
                            e && e(n),
                                r.manager.itemEnd(t)
                        }
                    )).catch((function(e) {
                            i && i(e),
                                r.manager.itemError(t),
                                r.manager.itemEnd(t)
                        }
                    )),
                    r.manager.itemStart(t)
            }
        });
        class Rp {
            constructor() {
                this.type = "ShapePath",
                    this.color = new Xi,
                    this.subPaths = [],
                    this.currentPath = null
            }
            moveTo(t, e) {
                return this.currentPath = new ip,
                    this.subPaths.push(this.currentPath),
                    this.currentPath.moveTo(t, e),
                    this
            }
            lineTo(t, e) {
                return this.currentPath.lineTo(t, e),
                    this
            }
            quadraticCurveTo(t, e, n, i) {
                return this.currentPath.quadraticCurveTo(t, e, n, i),
                    this
            }
            bezierCurveTo(t, e, n, i, r, o) {
                return this.currentPath.bezierCurveTo(t, e, n, i, r, o),
                    this
            }
            splineThru(t) {
                return this.currentPath.splineThru(t),
                    this
            }
            toShapes(t, e) {
                function n(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n]
                            , r = new rp;
                        r.curves = i.curves,
                            e.push(r)
                    }
                    return e
                }
                function i(t, e) {
                    const n = e.length;
                    let i = !1;
                    for (let r = n - 1, o = 0; o < n; r = o++) {
                        let n = e[r]
                            , s = e[o]
                            , a = s.x - n.x
                            , c = s.y - n.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (c < 0 && (n = e[o],
                                a = -a,
                                s = e[r],
                                c = -c),
                            t.y < n.y || t.y > s.y)
                                continue;
                            if (t.y === n.y) {
                                if (t.x === n.x)
                                    return !0
                            } else {
                                const e = c * (t.x - n.x) - a * (t.y - n.y);
                                if (0 === e)
                                    return !0;
                                if (e < 0)
                                    continue;
                                i = !i
                            }
                        } else {
                            if (t.y !== n.y)
                                continue;
                            if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x)
                                return !0
                        }
                    }
                    return i
                }
                const r = Fh.isClockWise
                    , o = this.subPaths;
                if (0 === o.length)
                    return [];
                if (!0 === e)
                    return n(o);
                let s, a, c;
                const l = [];
                if (1 === o.length)
                    return a = o[0],
                        c = new rp,
                        c.curves = a.curves,
                        l.push(c),
                        l;
                let u = !r(o[0].getPoints());
                u = t ? !u : u;
                const h = []
                    , d = [];
                let p, f, m = [], g = 0;
                d[g] = void 0,
                    m[g] = [];
                for (let v = 0, y = o.length; v < y; v++)
                    a = o[v],
                        p = a.getPoints(),
                        s = r(p),
                        s = t ? !s : s,
                        s ? (!u && d[g] && g++,
                            d[g] = {
                                s: new rp,
                                p: p
                            },
                            d[g].s.curves = a.curves,
                        u && g++,
                            m[g] = []) : m[g].push({
                            h: a,
                            p: p[0]
                        });
                if (!d[0])
                    return n(o);
                if (d.length > 1) {
                    let t = !1;
                    const e = [];
                    for (let n = 0, i = d.length; n < i; n++)
                        h[n] = [];
                    for (let n = 0, r = d.length; n < r; n++) {
                        const r = m[n];
                        for (let o = 0; o < r.length; o++) {
                            const s = r[o];
                            let a = !0;
                            for (let r = 0; r < d.length; r++)
                                i(s.p, d[r].p) && (n !== r && e.push({
                                    froms: n,
                                    tos: r,
                                    hole: o
                                }),
                                    a ? (a = !1,
                                        h[r].push(s)) : t = !0);
                            a && h[n].push(s)
                        }
                    }
                    e.length > 0 && (t || (m = h))
                }
                for (let v = 0, y = d.length; v < y; v++) {
                    c = d[v].s,
                        l.push(c),
                        f = m[v];
                    for (let t = 0, e = f.length; t < e; t++)
                        c.holes.push(f[t].h)
                }
                return l
            }
        }
        class Cp {
            constructor(t) {
                this.type = "Font",
                    this.data = t
            }
            generateShapes(t, e=100) {
                const n = []
                    , i = Pp(t, e, this.data);
                for (let r = 0, o = i.length; r < o; r++)
                    Array.prototype.push.apply(n, i[r].toShapes());
                return n
            }
        }
        function Pp(t, e, n) {
            const i = Array.from(t)
                , r = e / n.resolution
                , o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
                , s = [];
            let a = 0
                , c = 0;
            for (let l = 0; l < i.length; l++) {
                const t = i[l];
                if ("\n" === t)
                    a = 0,
                        c -= o;
                else {
                    const e = Op(t, r, a, c, n);
                    a += e.offsetX,
                        s.push(e.path)
                }
            }
            return s
        }
        function Op(t, e, n, i, r) {
            const o = r.glyphs[t] || r.glyphs["?"];
            if (!o)
                return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
            const s = new Rp;
            let a, c, l, u, h, d, p, f;
            if (o.o) {
                const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
                for (let r = 0, o = t.length; r < o; ) {
                    const o = t[r++];
                    switch (o) {
                        case "m":
                            a = t[r++] * e + n,
                                c = t[r++] * e + i,
                                s.moveTo(a, c);
                            break;
                        case "l":
                            a = t[r++] * e + n,
                                c = t[r++] * e + i,
                                s.lineTo(a, c);
                            break;
                        case "q":
                            l = t[r++] * e + n,
                                u = t[r++] * e + i,
                                h = t[r++] * e + n,
                                d = t[r++] * e + i,
                                s.quadraticCurveTo(h, d, l, u);
                            break;
                        case "b":
                            l = t[r++] * e + n,
                                u = t[r++] * e + i,
                                h = t[r++] * e + n,
                                d = t[r++] * e + i,
                                p = t[r++] * e + n,
                                f = t[r++] * e + i,
                                s.bezierCurveTo(h, d, p, f, l, u);
                            break
                    }
                }
            }
            return {
                offsetX: o.ha * e,
                path: s
            }
        }
        Cp.prototype.isFont = !0;
        let Ip;
        const Np = {
            getContext: function() {
                return void 0 === Ip && (Ip = new (window.AudioContext || window.webkitAudioContext)),
                    Ip
            },
            setContext: function(t) {
                Ip = t
            }
        };
        class Dp extends bd {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = this
                    , o = new Md(this.manager);
                o.setResponseType("arraybuffer"),
                    o.setPath(this.path),
                    o.setRequestHeader(this.requestHeader),
                    o.setWithCredentials(this.withCredentials),
                    o.load(t, (function(n) {
                            try {
                                const t = n.slice(0)
                                    , i = Np.getContext();
                                i.decodeAudioData(t, (function(t) {
                                        e(t)
                                    }
                                ))
                            } catch (o) {
                                i ? i(o) : console.error(o),
                                    r.manager.itemError(t)
                            }
                        }
                    ), n, i)
            }
        }
        class Fp extends Sp {
            constructor(t, e, n=1) {
                super(void 0, n);
                const i = (new Xi).set(t)
                    , r = (new Xi).set(e)
                    , o = new bn(i.r,i.g,i.b)
                    , s = new bn(r.r,r.g,r.b)
                    , a = Math.sqrt(Math.PI)
                    , c = a * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
                    this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c)
            }
        }
        Fp.prototype.isHemisphereLightProbe = !0;
        class kp extends Sp {
            constructor(t, e=1) {
                super(void 0, e);
                const n = (new Xi).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        kp.prototype.isAmbientLightProbe = !0;
        new Qn,
            new Qn;
        class Hp extends Mi {
            constructor(t) {
                super(),
                    this.type = "Audio",
                    this.listener = t,
                    this.context = t.context,
                    this.gain = this.context.createGain(),
                    this.gain.connect(t.getInput()),
                    this.autoplay = !1,
                    this.buffer = null,
                    this.detune = 0,
                    this.loop = !1,
                    this.loopStart = 0,
                    this.loopEnd = 0,
                    this.offset = 0,
                    this.duration = void 0,
                    this.playbackRate = 1,
                    this.isPlaying = !1,
                    this.hasPlaybackControl = !0,
                    this.source = null,
                    this.sourceType = "empty",
                    this._startedAt = 0,
                    this._progress = 0,
                    this._connected = !1,
                    this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1,
                    this.sourceType = "audioNode",
                    this.source = t,
                    this.connect(),
                    this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1,
                    this.sourceType = "mediaNode",
                    this.source = this.context.createMediaElementSource(t),
                    this.connect(),
                    this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1,
                    this.sourceType = "mediaStreamNode",
                    this.source = this.context.createMediaStreamSource(t),
                    this.connect(),
                    this
            }
            setBuffer(t) {
                return this.buffer = t,
                    this.sourceType = "buffer",
                this.autoplay && this.play(),
                    this
            }
            play(t=0) {
                if (!0 === this.isPlaying)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                    e.loop = this.loop,
                    e.loopStart = this.loopStart,
                    e.loopEnd = this.loopEnd,
                    e.onended = this.onEnded.bind(this),
                    e.start(this._startedAt, this._progress + this.offset, this.duration),
                    this.isPlaying = !0,
                    this.source = e,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl)
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1),
                        this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl)
                    return this._progress = 0,
                        this.source.stop(),
                        this.source.onended = null,
                        this.isPlaying = !1,
                        this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                    this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this._connected = !1,
                    this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []),
                    !0 === this._connected ? (this.disconnect(),
                        this.filters = t.slice(),
                        this.connect()) : this.filters = t.slice(),
                    this
            }
            setDetune(t) {
                if (this.detune = t,
                void 0 !== this.source.detune)
                    return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                        this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.playbackRate = t,
                    !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                        this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                    !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.loop = t,
                    !0 === this.isPlaying && (this.source.loop = this.loop),
                        this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t,
                    this
            }
            setLoopEnd(t) {
                return this.loopEnd = t,
                    this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                    this
            }
        }
        class Bp {
            constructor(t, e=2048) {
                this.analyser = t.context.createAnalyser(),
                    this.analyser.fftSize = e,
                    this.data = new Uint8Array(this.analyser.frequencyBinCount),
                    t.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                    this.data
            }
            getAverageFrequency() {
                let t = 0;
                const e = this.getFrequencyData();
                for (let n = 0; n < e.length; n++)
                    t += e[n];
                return t / e.length
            }
        }
        class zp {
            constructor(t, e, n) {
                let i, r, o;
                switch (this.binding = t,
                    this.valueSize = n,
                    e) {
                    case "quaternion":
                        i = this._slerp,
                            r = this._slerpAdditive,
                            o = this._setAdditiveIdentityQuaternion,
                            this.buffer = new Float64Array(6 * n),
                            this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select,
                            r = this._select,
                            o = this._setAdditiveIdentityOther,
                            this.buffer = new Array(5 * n);
                        break;
                    default:
                        i = this._lerp,
                            r = this._lerpAdditive,
                            o = this._setAdditiveIdentityNumeric,
                            this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i,
                    this._mixBufferRegionAdditive = r,
                    this._setIdentity = o,
                    this._origIndex = 3,
                    this._addIndex = 4,
                    this.cumulativeWeight = 0,
                    this.cumulativeWeightAdditive = 0,
                    this.useCount = 0,
                    this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer
                    , i = this.valueSize
                    , r = t * i + i;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let t = 0; t !== i; ++t)
                        n[r + t] = n[t];
                    o = e
                } else {
                    o += e;
                    const t = e / o;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = o
            }
            accumulateAdditive(t) {
                const e = this.buffer
                    , n = this.valueSize
                    , i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                    this._mixBufferRegionAdditive(e, i, 0, t, n),
                    this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize
                    , n = this.buffer
                    , i = t * e + e
                    , r = this.cumulativeWeight
                    , o = this.cumulativeWeightAdditive
                    , s = this.binding;
                if (this.cumulativeWeight = 0,
                    this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let a = e, c = e + e; a !== c; ++a)
                    if (n[a] !== n[a + e]) {
                        s.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding
                    , e = this.buffer
                    , n = this.valueSize
                    , i = n * this._origIndex;
                t.getValue(e, i);
                for (let r = n, o = i; r !== o; ++r)
                    e[r] = e[i + r % n];
                this._setIdentity(),
                    this.cumulativeWeight = 0,
                    this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize
                    , e = t + this.valueSize;
                for (let n = t; n < e; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                    this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize
                    , e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[e + n] = this.buffer[t + n]
            }
            _select(t, e, n, i, r) {
                if (i >= .5)
                    for (let o = 0; o !== r; ++o)
                        t[e + o] = t[n + o]
            }
            _slerp(t, e, n, i) {
                xn.slerpFlat(t, e, t, e, t, n, i)
            }
            _slerpAdditive(t, e, n, i, r) {
                const o = this._workIndex * r;
                xn.multiplyQuaternionsFlat(t, o, t, e, t, n),
                    xn.slerpFlat(t, e, t, e, t, o, i)
            }
            _lerp(t, e, n, i, r) {
                const o = 1 - i;
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] * o + t[n + s] * i
                }
            }
            _lerpAdditive(t, e, n, i, r) {
                for (let o = 0; o !== r; ++o) {
                    const r = e + o;
                    t[r] = t[r] + t[n + o] * i
                }
            }
        }
        const Up = "\\[\\]\\.:\\/"
            , jp = new RegExp("[" + Up + "]","g")
            , Gp = "[^" + Up + "]"
            , Vp = "[^" + Up.replace("\\.", "") + "]"
            , Wp = /((?:WC+[\/:])*)/.source.replace("WC", Gp)
            , qp = /(WCOD+)?/.source.replace("WCOD", Vp)
            , Xp = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Gp)
            , Yp = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Gp)
            , Zp = new RegExp("^" + Wp + qp + Xp + Yp + "$")
            , Jp = ["material", "materials", "bones"];
        function Kp(t, e, n) {
            const i = n || Qp.parseTrackName(e);
            this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
        }
        function Qp(t, e, n) {
            this.path = e,
                this.parsedPath = n || Qp.parseTrackName(e),
                this.node = Qp.findNode(t, this.parsedPath.nodeName) || t,
                this.rootNode = t
        }
        Object.assign(Kp.prototype, {
            getValue: function(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                    , i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(t, e)
            },
            bind: function() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            },
            unbind: function() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }),
            Object.assign(Qp, {
                Composite: Kp,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Qp.Composite(t,e,n) : new Qp(t,e,n)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(jp, "")
                },
                parseTrackName: function(t) {
                    const e = Zp.exec(t);
                    if (!e)
                        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    }
                        , i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const t = n.nodeName.substring(i + 1);
                        -1 !== Jp.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                            n.objectName = t)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                },
                findNode: function(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                        return t;
                    if (t.skeleton) {
                        const n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n)
                            return n
                    }
                    if (t.children) {
                        const n = function(t) {
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (r.name === e || r.uuid === e)
                                    return r;
                                const o = n(r.children);
                                if (o)
                                    return o
                            }
                            return null
                        }
                            , i = n(t.children);
                        if (i)
                            return i
                    }
                    return null
                }
            }),
            Object.assign(Qp.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }
                    , function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            t[e++] = n[i]
                    }
                    , function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }
                    , function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }
                ],
                SetterByBindingTypeAndVersioning: [[function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }
                    , function(t, e) {
                        this.targetObject[this.propertyName] = t[e],
                            this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.targetObject[this.propertyName] = t[e],
                            this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                ], [function(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i)
                        n[i] = t[e++]
                }
                    , function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i)
                            n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                ], [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }
                    , function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e],
                            this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e],
                            this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                ], [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }
                    , function(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                            this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                ]],
                getValue: function(t, e) {
                    this.bind(),
                        this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(),
                        this.setValue(t, e)
                },
                bind: function() {
                    let t = this.node;
                    const e = this.parsedPath
                        , n = e.objectName
                        , i = e.propertyName;
                    let r = e.propertyIndex;
                    if (t || (t = Qp.findNode(this.rootNode, e.nodeName) || this.rootNode,
                        this.node = t),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !t)
                        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let i = e.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!t.material)
                                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials)
                                    return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton)
                                    return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === i) {
                                        i = e;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[n])
                                    return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === t[i])
                                return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[i]
                        }
                    }
                    const o = t[i];
                    if (void 0 === o) {
                        const n = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                    }
                    let s = this.Versioning.None;
                    this.targetObject = t,
                        void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                    let a = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                        }
                        a = this.BindingType.ArrayElement,
                            this.resolvedProperty = o,
                            this.propertyIndex = r
                    } else
                        void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray,
                            this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray,
                            this.resolvedProperty = o) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[a],
                        this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
                },
                unbind: function() {
                    this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                }
            }),
            Object.assign(Qp.prototype, {
                _getValue_unbound: Qp.prototype.getValue,
                _setValue_unbound: Qp.prototype.setValue
            });
        class $p {
            constructor() {
                this.uuid = ln.generateUUID(),
                    this._objects = Array.prototype.slice.call(arguments),
                    this.nCachedObjects_ = 0;
                const t = {};
                this._indicesByUUID = t;
                for (let n = 0, i = arguments.length; n !== i; ++n)
                    t[arguments[n].uuid] = n;
                this._paths = [],
                    this._parsedPaths = [],
                    this._bindings = [],
                    this._bindingsIndicesByPath = {};
                const e = this;
                this.stats = {
                    objects: {
                        get total() {
                            return e._objects.length
                        },
                        get inUse() {
                            return this.total - e.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return e._bindings.length
                    }
                }
            }
            add() {
                const t = this._objects
                    , e = this._indicesByUUID
                    , n = this._paths
                    , i = this._parsedPaths
                    , r = this._bindings
                    , o = r.length;
                let s = void 0
                    , a = t.length
                    , c = this.nCachedObjects_;
                for (let l = 0, u = arguments.length; l !== u; ++l) {
                    const u = arguments[l]
                        , h = u.uuid;
                    let d = e[h];
                    if (void 0 === d) {
                        d = a++,
                            e[h] = d,
                            t.push(u);
                        for (let t = 0, e = o; t !== e; ++t)
                            r[t].push(new Qp(u,n[t],i[t]))
                    } else if (d < c) {
                        s = t[d];
                        const a = --c
                            , l = t[a];
                        e[l.uuid] = d,
                            t[d] = l,
                            e[h] = a,
                            t[a] = u;
                        for (let t = 0, e = o; t !== e; ++t) {
                            const e = r[t]
                                , o = e[a];
                            let s = e[d];
                            e[d] = o,
                            void 0 === s && (s = new Qp(u,n[t],i[t])),
                                e[a] = s
                        }
                    } else
                        t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = c
            }
            remove() {
                const t = this._objects
                    , e = this._indicesByUUID
                    , n = this._bindings
                    , i = n.length;
                let r = this.nCachedObjects_;
                for (let o = 0, s = arguments.length; o !== s; ++o) {
                    const s = arguments[o]
                        , a = s.uuid
                        , c = e[a];
                    if (void 0 !== c && c >= r) {
                        const o = r++
                            , l = t[o];
                        e[l.uuid] = c,
                            t[c] = l,
                            e[a] = o,
                            t[o] = s;
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t]
                                , i = e[o]
                                , r = e[c];
                            e[c] = i,
                                e[o] = r
                        }
                    }
                }
                this.nCachedObjects_ = r
            }
            uncache() {
                const t = this._objects
                    , e = this._indicesByUUID
                    , n = this._bindings
                    , i = n.length;
                let r = this.nCachedObjects_
                    , o = t.length;
                for (let s = 0, a = arguments.length; s !== a; ++s) {
                    const a = arguments[s]
                        , c = a.uuid
                        , l = e[c];
                    if (void 0 !== l)
                        if (delete e[c],
                        l < r) {
                            const s = --r
                                , a = t[s]
                                , c = --o
                                , u = t[c];
                            e[a.uuid] = l,
                                t[l] = a,
                                e[u.uuid] = s,
                                t[s] = u,
                                t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t]
                                    , i = e[s]
                                    , r = e[c];
                                e[l] = i,
                                    e[s] = r,
                                    e.pop()
                            }
                        } else {
                            const r = --o
                                , s = t[r];
                            r > 0 && (e[s.uuid] = l),
                                t[l] = s,
                                t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t];
                                e[l] = e[r],
                                    e.pop()
                            }
                        }
                }
                this.nCachedObjects_ = r
            }
            subscribe_(t, e) {
                const n = this._bindingsIndicesByPath;
                let i = n[t];
                const r = this._bindings;
                if (void 0 !== i)
                    return r[i];
                const o = this._paths
                    , s = this._parsedPaths
                    , a = this._objects
                    , c = a.length
                    , l = this.nCachedObjects_
                    , u = new Array(c);
                i = r.length,
                    n[t] = i,
                    o.push(t),
                    s.push(e),
                    r.push(u);
                for (let h = l, d = a.length; h !== d; ++h) {
                    const n = a[h];
                    u[h] = new Qp(n,t,e)
                }
                return u
            }
            unsubscribe_(t) {
                const e = this._bindingsIndicesByPath
                    , n = e[t];
                if (void 0 !== n) {
                    const i = this._paths
                        , r = this._parsedPaths
                        , o = this._bindings
                        , s = o.length - 1
                        , a = o[s]
                        , c = t[s];
                    e[c] = n,
                        o[n] = a,
                        o.pop(),
                        r[n] = r[s],
                        r.pop(),
                        i[n] = i[s],
                        i.pop()
                }
            }
        }
        $p.prototype.isAnimationObjectGroup = !0;
        class tf {
            constructor(t, e, n=null, i=e.blendMode) {
                this._mixer = t,
                    this._clip = e,
                    this._localRoot = n,
                    this.blendMode = i;
                const r = e.tracks
                    , o = r.length
                    , s = new Array(o)
                    , a = {
                    endingStart: Ne,
                    endingEnd: Ne
                };
                for (let c = 0; c !== o; ++c) {
                    const t = r[c].createInterpolant(null);
                    s[c] = t,
                        t.settings = a
                }
                this._interpolantSettings = a,
                    this._interpolants = s,
                    this._propertyBindings = new Array(o),
                    this._cacheIndex = null,
                    this._byClipCacheIndex = null,
                    this._timeScaleInterpolant = null,
                    this._weightInterpolant = null,
                    this.loop = Re,
                    this._loopCount = -1,
                    this._startTime = null,
                    this.time = 0,
                    this.timeScale = 1,
                    this._effectiveTimeScale = 1,
                    this.weight = 1,
                    this._effectiveWeight = 1,
                    this.repetitions = 1 / 0,
                    this.paused = !1,
                    this.enabled = !0,
                    this.clampWhenFinished = !1,
                    this.zeroSlopeAtStart = !0,
                    this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                    this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                    this.reset()
            }
            reset() {
                return this.paused = !1,
                    this.enabled = !0,
                    this.time = 0,
                    this._loopCount = -1,
                    this._startTime = null,
                    this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t,
                    this
            }
            setLoop(t, e) {
                return this.loop = t,
                    this.repetitions = e,
                    this
            }
            setEffectiveWeight(t) {
                return this.weight = t,
                    this._effectiveWeight = this.enabled ? t : 0,
                    this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e),
                    this.fadeIn(e),
                    n) {
                    const n = this._clip.duration
                        , i = t._clip.duration
                        , r = i / n
                        , o = n / i;
                    t.warp(1, r, e),
                        this.warp(o, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                    this._mixer._takeBackControlInterpolant(t)),
                    this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t,
                    this._effectiveTimeScale = this.paused ? 0 : t,
                    this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t,
                    this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time,
                    this.timeScale = t.timeScale,
                    this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const i = this._mixer
                    , r = i.time
                    , o = this.timeScale;
                let s = this._timeScaleInterpolant;
                null === s && (s = i._lendControlInterpolant(),
                    this._timeScaleInterpolant = s);
                const a = s.parameterPositions
                    , c = s.sampleValues;
                return a[0] = r,
                    a[1] = r + n,
                    c[0] = t / o,
                    c[1] = e / o,
                    this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                    this._mixer._takeBackControlInterpolant(t)),
                    this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, i) {
                if (!this.enabled)
                    return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    if (i < 0 || 0 === n)
                        return;
                    this._startTime = null,
                        e = n * i
                }
                e *= this._updateTimeScale(t);
                const o = this._updateTime(e)
                    , s = this._updateWeight(t);
                if (s > 0) {
                    const t = this._interpolants
                        , e = this._propertyBindings;
                    switch (this.blendMode) {
                        case He:
                            for (let n = 0, i = t.length; n !== i; ++n)
                                t[n].evaluate(o),
                                    e[n].accumulateAdditive(s);
                            break;
                        case ke:
                        default:
                            for (let n = 0, r = t.length; n !== r; ++n)
                                t[n].evaluate(o),
                                    e[n].accumulate(i, s)
                    }
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i,
                        t > n.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                    e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i,
                        t > n.parameterPositions[1] && (this.stopWarping(),
                            0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e,
                    e
            }
            _updateTime(t) {
                const e = this._clip.duration
                    , n = this.loop;
                let i = this.time + t
                    , r = this._loopCount;
                const o = n === Ce;
                if (0 === t)
                    return -1 === r ? i : o && 1 === (1 & r) ? e - i : i;
                if (n === Le) {
                    -1 === r && (this._loopCount = 0,
                        this._setEndings(!0, !0, !1));
                    t: {
                        if (i >= e)
                            i = e;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0,
                        this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                    i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n,
                            r += Math.abs(n);
                        const s = this.repetitions - r;
                        if (s <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                i = t > 0 ? e : 0,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                        else {
                            if (1 === s) {
                                const e = t < 0;
                                this._setEndings(e, !e, o)
                            } else
                                this._setEndings(!1, !1, o);
                            this._loopCount = r,
                                this.time = i,
                                this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                        }
                    } else
                        this.time = i;
                    if (o && 1 === (1 & r))
                        return e - i
                }
                return i
            }
            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = De,
                    i.endingEnd = De) : (i.endingStart = t ? this.zeroSlopeAtStart ? De : Ne : Fe,
                    i.endingEnd = e ? this.zeroSlopeAtEnd ? De : Ne : Fe)
            }
            _scheduleFading(t, e, n) {
                const i = this._mixer
                    , r = i.time;
                let o = this._weightInterpolant;
                null === o && (o = i._lendControlInterpolant(),
                    this._weightInterpolant = o);
                const s = o.parameterPositions
                    , a = o.sampleValues;
                return s[0] = r,
                    a[0] = e,
                    s[1] = r + t,
                    a[1] = n,
                    this
            }
        }
        class ef extends sn {
            constructor(t) {
                super(),
                    this._root = t,
                    this._initMemoryManager(),
                    this._accuIndex = 0,
                    this.time = 0,
                    this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root
                    , i = t._clip.tracks
                    , r = i.length
                    , o = t._propertyBindings
                    , s = t._interpolants
                    , a = n.uuid
                    , c = this._bindingsByRootAndName;
                let l = c[a];
                void 0 === l && (l = {},
                    c[a] = l);
                for (let u = 0; u !== r; ++u) {
                    const t = i[u]
                        , r = t.name;
                    let c = l[r];
                    if (void 0 !== c)
                        o[u] = c;
                    else {
                        if (c = o[u],
                        void 0 !== c) {
                            null === c._cacheIndex && (++c.referenceCount,
                                this._addInactiveBinding(c, a, r));
                            continue
                        }
                        const i = e && e._propertyBindings[u].binding.parsedPath;
                        c = new zp(Qp.create(n, r, i),t.ValueTypeName,t.getValueSize()),
                            ++c.referenceCount,
                            this._addInactiveBinding(c, a, r),
                            o[u] = c
                    }
                    s[u].resultBuffer = c.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid
                            , n = t._clip.uuid
                            , i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]),
                            this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 === n.useCount++ && (this._lendBinding(n),
                            n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 === --n.useCount && (n.restoreOriginalState(),
                            this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                    this._nActiveActions = 0,
                    this._actionsByClip = {},
                    this._bindings = [],
                    this._nActiveBindings = 0,
                    this._bindingsByRootAndName = {},
                    this._controlInterpolants = [],
                    this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const i = this._actions
                    , r = this._actionsByClip;
                let o = r[e];
                if (void 0 === o)
                    o = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                        t._byClipCacheIndex = 0,
                        r[e] = o;
                else {
                    const e = o.knownActions;
                    t._byClipCacheIndex = e.length,
                        e.push(t)
                }
                t._cacheIndex = i.length,
                    i.push(t),
                    o.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions
                    , n = e[e.length - 1]
                    , i = t._cacheIndex;
                n._cacheIndex = i,
                    e[i] = n,
                    e.pop(),
                    t._cacheIndex = null;
                const r = t._clip.uuid
                    , o = this._actionsByClip
                    , s = o[r]
                    , a = s.knownActions
                    , c = a[a.length - 1]
                    , l = t._byClipCacheIndex;
                c._byClipCacheIndex = l,
                    a[l] = c,
                    a.pop(),
                    t._byClipCacheIndex = null;
                const u = s.actionByRoot
                    , h = (t._localRoot || this._root).uuid;
                delete u[h],
                0 === a.length && delete o[r],
                    this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let n = 0, i = e.length; n !== i; ++n) {
                    const t = e[n];
                    0 === --t.referenceCount && this._removeInactiveBinding(t)
                }
            }
            _lendAction(t) {
                const e = this._actions
                    , n = t._cacheIndex
                    , i = this._nActiveActions++
                    , r = e[i];
                t._cacheIndex = i,
                    e[i] = t,
                    r._cacheIndex = n,
                    e[n] = r
            }
            _takeBackAction(t) {
                const e = this._actions
                    , n = t._cacheIndex
                    , i = --this._nActiveActions
                    , r = e[i];
                t._cacheIndex = i,
                    e[i] = t,
                    r._cacheIndex = n,
                    e[n] = r
            }
            _addInactiveBinding(t, e, n) {
                const i = this._bindingsByRootAndName
                    , r = this._bindings;
                let o = i[e];
                void 0 === o && (o = {},
                    i[e] = o),
                    o[n] = t,
                    t._cacheIndex = r.length,
                    r.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings
                    , n = t.binding
                    , i = n.rootNode.uuid
                    , r = n.path
                    , o = this._bindingsByRootAndName
                    , s = o[i]
                    , a = e[e.length - 1]
                    , c = t._cacheIndex;
                a._cacheIndex = c,
                    e[c] = a,
                    e.pop(),
                    delete s[r],
                0 === Object.keys(s).length && delete o[i]
            }
            _lendBinding(t) {
                const e = this._bindings
                    , n = t._cacheIndex
                    , i = this._nActiveBindings++
                    , r = e[i];
                t._cacheIndex = i,
                    e[i] = t,
                    r._cacheIndex = n,
                    e[n] = r
            }
            _takeBackBinding(t) {
                const e = this._bindings
                    , n = t._cacheIndex
                    , i = --this._nActiveBindings
                    , r = e[i];
                t._cacheIndex = i,
                    e[i] = t,
                    r._cacheIndex = n,
                    e[n] = r
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants
                    , e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new od(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                    n.__cacheIndex = e,
                    t[e] = n),
                    n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants
                    , n = t.__cacheIndex
                    , i = --this._nActiveControlInterpolants
                    , r = e[i];
                t.__cacheIndex = i,
                    e[i] = t,
                    r.__cacheIndex = n,
                    e[n] = r
            }
            clipAction(t, e, n) {
                const i = e || this._root
                    , r = i.uuid;
                let o = "string" === typeof t ? md.findByName(i, t) : t;
                const s = null !== o ? o.uuid : t
                    , a = this._actionsByClip[s];
                let c = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : ke),
                void 0 !== a) {
                    const t = a.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n)
                        return t;
                    c = a.knownActions[0],
                    null === o && (o = c._clip)
                }
                if (null === o)
                    return null;
                const l = new tf(this,o,e,n);
                return this._bindAction(l, c),
                    this._addInactiveAction(l, s, r),
                    l
            }
            existingAction(t, e) {
                const n = e || this._root
                    , i = n.uuid
                    , r = "string" === typeof t ? md.findByName(n, t) : t
                    , o = r ? r.uuid : t
                    , s = this._actionsByClip[o];
                return void 0 !== s && s.actionByRoot[i] || null
            }
            stopAllAction() {
                const t = this._actions
                    , e = this._nActiveActions;
                for (let n = e - 1; n >= 0; --n)
                    t[n].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions
                    , n = this._nActiveActions
                    , i = this.time += t
                    , r = Math.sign(t)
                    , o = this._accuIndex ^= 1;
                for (let c = 0; c !== n; ++c) {
                    const n = e[c];
                    n._update(i, t, r, o)
                }
                const s = this._bindings
                    , a = this._nActiveBindings;
                for (let c = 0; c !== a; ++c)
                    s[c].apply(o);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let e = 0; e < this._actions.length; e++)
                    this._actions[e].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions
                    , n = t.uuid
                    , i = this._actionsByClip
                    , r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex
                            , o = e[e.length - 1];
                        i._cacheIndex = null,
                            i._byClipCacheIndex = null,
                            o._cacheIndex = r,
                            e[r] = o,
                            e.pop(),
                            this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid
                    , n = this._actionsByClip;
                for (const o in n) {
                    const t = n[o].actionByRoot
                        , i = t[e];
                    void 0 !== i && (this._deactivateAction(i),
                        this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName
                    , r = i[e];
                if (void 0 !== r)
                    for (const o in r) {
                        const t = r[o];
                        t.restoreOriginalState(),
                            this._removeInactiveBinding(t)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n),
                    this._removeInactiveAction(n))
            }
        }
        ef.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class nf {
            constructor(t) {
                "string" === typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                    t = arguments[1]),
                    this.value = t
            }
            clone() {
                return new nf(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        function rf(t, e, n) {
            eu.call(this, t, e),
                this.meshPerAttribute = n || 1
        }
        function of(t, e, n, i, r) {
            this.buffer = t,
                this.type = e,
                this.itemSize = n,
                this.elementSize = i,
                this.count = r,
                this.version = 0
        }
        function sf(t, e, n=0, i=1 / 0) {
            this.ray = new Kn(t,e),
                this.near = n,
                this.far = i,
                this.camera = null,
                this.layers = new li,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                },
                Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                                this.Points
                        }
                    }
                })
        }
        function af(t, e) {
            return t.distance - e.distance
        }
        function cf(t, e, n, i) {
            if (t.layers.test(e.layers) && t.raycast(e, n),
            !0 === i) {
                const i = t.children;
                for (let t = 0, r = i.length; t < r; t++)
                    cf(i[t], e, n, !0)
            }
        }
        rf.prototype = Object.assign(Object.create(eu.prototype), {
            constructor: rf,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return eu.prototype.copy.call(this, t),
                    this.meshPerAttribute = t.meshPerAttribute,
                    this
            },
            clone: function(t) {
                const e = eu.prototype.clone.call(this, t);
                return e.meshPerAttribute = this.meshPerAttribute,
                    e
            },
            toJSON: function(t) {
                const e = eu.prototype.toJSON.call(this, t);
                return e.isInstancedInterleavedBuffer = !0,
                    e.meshPerAttribute = this.meshPerAttribute,
                    e
            }
        }),
            Object.defineProperty(of.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }),
            Object.assign(of.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(t) {
                    return this.buffer = t,
                        this
                },
                setType: function(t, e) {
                    return this.type = t,
                        this.elementSize = e,
                        this
                },
                setItemSize: function(t) {
                    return this.itemSize = t,
                        this
                },
                setCount: function(t) {
                    return this.count = t,
                        this
                }
            }),
            Object.assign(sf.prototype, {
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
                        this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                        this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                },
                intersectObject: function(t, e=!1, n=[]) {
                    return cf(t, this, n, e),
                        n.sort(af),
                        n
                },
                intersectObjects: function(t, e=!1, n=[]) {
                    for (let i = 0, r = t.length; i < r; i++)
                        cf(t[i], this, n, e);
                    return n.sort(af),
                        n
                }
            });
        class lf {
            constructor(t=1, e=0, n=0) {
                return this.radius = t,
                    this.phi = e,
                    this.theta = n,
                    this
            }
            set(t, e, n) {
                return this.radius = t,
                    this.phi = e,
                    this.theta = n,
                    this
            }
            copy(t) {
                return this.radius = t.radius,
                    this.phi = t.phi,
                    this.theta = t.theta,
                    this
            }
            makeSafe() {
                const t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
                    this
            }
            setFromVector3(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }
            setFromCartesianCoords(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n),
                    0 === this.radius ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(t, n),
                        this.phi = Math.acos(ln.clamp(e / this.radius, -1, 1))),
                    this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const uf = new un;
        class hf {
            constructor(t=new un(1 / 0,1 / 0), e=new un(-1 / 0,-1 / 0)) {
                this.min = t,
                    this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                    this.max.copy(e),
                    this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = uf.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                    this.max.copy(t).add(n),
                    this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                    this.max.copy(t.max),
                    this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                    this.max.x = this.max.y = -1 / 0,
                    this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"),
                    t = new un),
                    this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"),
                    t = new un),
                    this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                    this.max.max(t),
                    this
            }
            expandByVector(t) {
                return this.min.sub(t),
                    this.max.add(t),
                    this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                    this.max.addScalar(t),
                    this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"),
                    e = new un),
                    e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"),
                    e = new un),
                    e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                const e = uf.copy(t).clamp(this.min, this.max);
                return e.sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min),
                    this.max.min(t.max),
                    this
            }
            union(t) {
                return this.min.min(t.min),
                    this.max.max(t.max),
                    this
            }
            translate(t) {
                return this.min.add(t),
                    this.max.add(t),
                    this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        hf.prototype.isBox2 = !0;
        const df = new bn
            , pf = new bn;
        class ff {
            constructor(t=new bn, e=new bn) {
                this.start = t,
                    this.end = e
            }
            set(t, e) {
                return this.start.copy(t),
                    this.end.copy(e),
                    this
            }
            copy(t) {
                return this.start.copy(t.start),
                    this.end.copy(t.end),
                    this
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"),
                    t = new bn),
                    t.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(t) {
                return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"),
                    t = new bn),
                    t.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(t, e) {
                return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"),
                    e = new bn),
                    this.delta(e).multiplyScalar(t).add(this.start)
            }
            closestPointToPointParameter(t, e) {
                df.subVectors(t, this.start),
                    pf.subVectors(this.end, this.start);
                const n = pf.dot(pf)
                    , i = pf.dot(df);
                let r = i / n;
                return e && (r = ln.clamp(r, 0, 1)),
                    r
            }
            closestPointToPoint(t, e, n) {
                const i = this.closestPointToPointParameter(t, e);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
                    n = new bn),
                    this.delta(n).multiplyScalar(i).add(this.start)
            }
            applyMatrix4(t) {
                return this.start.applyMatrix4(t),
                    this.end.applyMatrix4(t),
                    this
            }
            equals(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function mf(t) {
            Mi.call(this),
                this.material = t,
                this.render = function() {}
                ,
                this.hasPositions = !1,
                this.hasNormals = !1,
                this.hasColors = !1,
                this.hasUvs = !1,
                this.positionArray = null,
                this.normalArray = null,
                this.colorArray = null,
                this.uvArray = null,
                this.count = 0
        }
        mf.prototype = Object.create(Mi.prototype),
            mf.prototype.constructor = mf,
            mf.prototype.isImmediateRenderObject = !0;
        const gf = new bn
            , vf = new Qn
            , yf = new Qn;
        class _f extends Vu {
            constructor(t) {
                const e = xf(t)
                    , n = new gr
                    , i = []
                    , r = []
                    , o = new Xi(0,0,1)
                    , s = new Xi(0,1,0);
                for (let c = 0; c < e.length; c++) {
                    const t = e[c];
                    t.parent && t.parent.isBone && (i.push(0, 0, 0),
                        i.push(0, 0, 0),
                        r.push(o.r, o.g, o.b),
                        r.push(s.r, s.g, s.b))
                }
                n.setAttribute("position", new sr(i,3)),
                    n.setAttribute("color", new sr(r,3));
                const a = new Du({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                });
                super(n, a),
                    this.type = "SkeletonHelper",
                    this.isSkeletonHelper = !0,
                    this.root = t,
                    this.bones = e,
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones
                    , n = this.geometry
                    , i = n.getAttribute("position");
                yf.copy(this.root.matrixWorld).invert();
                for (let r = 0, o = 0; r < e.length; r++) {
                    const t = e[r];
                    t.parent && t.parent.isBone && (vf.multiplyMatrices(yf, t.matrixWorld),
                        gf.setFromMatrixPosition(vf),
                        i.setXYZ(o, gf.x, gf.y, gf.z),
                        vf.multiplyMatrices(yf, t.parent.matrixWorld),
                        gf.setFromMatrixPosition(vf),
                        i.setXYZ(o + 1, gf.x, gf.y, gf.z),
                        o += 2)
                }
                n.getAttribute("position").needsUpdate = !0,
                    super.updateMatrixWorld(t)
            }
        }
        function xf(t) {
            const e = [];
            t && t.isBone && e.push(t);
            for (let n = 0; n < t.children.length; n++)
                e.push.apply(e, xf(t.children[n]));
            return e
        }
        class bf extends Vu {
            constructor(t=10, e=10, n=4473924, i=8947848) {
                n = new Xi(n),
                    i = new Xi(i);
                const r = e / 2
                    , o = t / e
                    , s = t / 2
                    , a = []
                    , c = [];
                for (let h = 0, d = 0, p = -s; h <= e; h++,
                    p += o) {
                    a.push(-s, 0, p, s, 0, p),
                        a.push(p, 0, -s, p, 0, s);
                    const t = h === r ? n : i;
                    t.toArray(c, d),
                        d += 3,
                        t.toArray(c, d),
                        d += 3,
                        t.toArray(c, d),
                        d += 3,
                        t.toArray(c, d),
                        d += 3
                }
                const l = new gr;
                l.setAttribute("position", new sr(a,3)),
                    l.setAttribute("color", new sr(c,3));
                const u = new Du({
                    vertexColors: !0,
                    toneMapped: !1
                });
                super(l, u),
                    this.type = "GridHelper"
            }
        }
        const wf = new Float32Array(1)
            , Mf = (new Int32Array(wf.buffer),
            4)
            , Sf = 8
            , Ef = (Math.pow(2, Sf),
            [.125, .215, .35, .446, .526, .582])
            , Tf = Sf - Mf + 1 + Ef.length
            , Af = new Yi({
            side: p,
            depthWrite: !1,
            depthTest: !1
        })
            , {_lodPlanes: Lf, _sizeLods: Rf, _sigmas: Cf} = (new Nr(new kr,Af),
            Pf());
        Math.sqrt(5);
        function Pf() {
            const t = []
                , e = []
                , n = [];
            let i = Sf;
            for (let r = 0; r < Tf; r++) {
                const o = Math.pow(2, i);
                e.push(o);
                let s = 1 / o;
                r > Sf - Mf ? s = Ef[r - Sf + Mf - 1] : 0 == r && (s = 0),
                    n.push(s);
                const a = 1 / (o - 1)
                    , c = -a / 2
                    , l = 1 + a / 2
                    , u = [c, c, l, c, l, l, c, c, l, l, c, l]
                    , h = 6
                    , d = 6
                    , p = 3
                    , f = 2
                    , m = 1
                    , g = new Float32Array(p * d * h)
                    , v = new Float32Array(f * d * h)
                    , y = new Float32Array(m * d * h);
                for (let t = 0; t < h; t++) {
                    const e = t % 3 * 2 / 3 - 1
                        , n = t > 2 ? 0 : -1
                        , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, p * d * t),
                        v.set(u, f * d * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * d * t)
                }
                const _ = new gr;
                _.setAttribute("position", new Ki(g,p)),
                    _.setAttribute("uv", new Ki(v,f)),
                    _.setAttribute("faceIndex", new Ki(y,m)),
                    t.push(_),
                i > Mf && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }
        Rd.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"),
                t.prototype = Object.create(Rd.prototype),
                t.prototype.constructor = t,
                t.prototype.getPoint = e,
                t
        }
            ,
            ip.prototype.fromPoints = function(t) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
                    this.setFromPoints(t)
            }
            ,
            bf.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }
            ,
            _f.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }
            ,
            bd.prototype.extractUrlBase = function(t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
                    Ep.extractUrlBase(t)
            }
            ,
            bd.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            },
            hf.prototype.center = function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
                    this.getCenter(t)
            }
            ,
            hf.prototype.empty = function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
            }
            ,
            hf.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
            }
            ,
            hf.prototype.size = function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
                    this.getSize(t)
            }
            ,
            Sn.prototype.center = function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
                    this.getCenter(t)
            }
            ,
            Sn.prototype.empty = function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
            }
            ,
            Sn.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
            }
            ,
            Sn.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
            }
            ,
            Sn.prototype.size = function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
                    this.getSize(t)
            }
            ,
            Gn.prototype.empty = function() {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
                    this.isEmpty()
            }
            ,
            to.prototype.setFromMatrix = function(t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
                    this.setFromProjectionMatrix(t)
            }
            ,
            ff.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
                    this.getCenter(t)
            }
            ,
            ln.random16 = function() {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
                    Math.random()
            }
            ,
            ln.nearestPowerOfTwo = function(t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
                    ln.floorPowerOfTwo(t)
            }
            ,
            ln.nextPowerOfTwo = function(t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
                    ln.ceilPowerOfTwo(t)
            }
            ,
            hn.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
                    this.toArray(t, e)
            }
            ,
            hn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                    t.applyMatrix3(this)
            }
            ,
            hn.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }
            ,
            hn.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
                    t.applyMatrix3(this)
            }
            ,
            hn.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
            ,
            hn.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
                    this.copy(t).invert()
            }
            ,
            Qn.prototype.extractPosition = function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                    this.copyPosition(t)
            }
            ,
            Qn.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
                    this.toArray(t, e)
            }
            ,
            Qn.prototype.getPosition = function() {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                    (new bn).setFromMatrixColumn(this, 3)
            }
            ,
            Qn.prototype.setRotationFromQuaternion = function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                    this.makeRotationFromQuaternion(t)
            }
            ,
            Qn.prototype.multiplyToArray = function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }
            ,
            Qn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
            }
            ,
            Qn.prototype.multiplyVector4 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
            }
            ,
            Qn.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }
            ,
            Qn.prototype.rotateAxis = function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                    t.transformDirection(this)
            }
            ,
            Qn.prototype.crossVector = function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
            }
            ,
            Qn.prototype.translate = function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }
            ,
            Qn.prototype.rotateX = function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }
            ,
            Qn.prototype.rotateY = function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }
            ,
            Qn.prototype.rotateZ = function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }
            ,
            Qn.prototype.rotateByAxis = function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }
            ,
            Qn.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
                    t.applyMatrix4(this)
            }
            ,
            Qn.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }
            ,
            Qn.prototype.makeFrustum = function(t, e, n, i, r, o) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
                    this.makePerspective(t, e, i, n, r, o)
            }
            ,
            Qn.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
                    this.copy(t).invert()
            }
            ,
            Ai.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                    this.intersectsLine(t)
            }
            ,
            xn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                    t.applyQuaternion(this)
            }
            ,
            xn.prototype.inverse = function() {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
                    this.invert()
            }
            ,
            Kn.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(t)
            }
            ,
            Kn.prototype.isIntersectionPlane = function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                    this.intersectsPlane(t)
            }
            ,
            Kn.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                    this.intersectsSphere(t)
            }
            ,
            Hi.prototype.area = function() {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
                    this.getArea()
            }
            ,
            Hi.prototype.barycoordFromPoint = function(t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
                    this.getBarycoord(t, e)
            }
            ,
            Hi.prototype.midpoint = function(t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
                    this.getMidpoint(t)
            }
            ,
            Hi.prototypenormal = function(t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
                    this.getNormal(t)
            }
            ,
            Hi.prototype.plane = function(t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
                    this.getPlane(t)
            }
            ,
            Hi.barycoordFromPoint = function(t, e, n, i, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
                    Hi.getBarycoord(t, e, n, i, r)
            }
            ,
            Hi.normal = function(t, e, n, i) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
                    Hi.getNormal(t, e, n, i)
            }
            ,
            rp.prototype.extractAllPoints = function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
                    this.extractPoints(t)
            }
            ,
            rp.prototype.extrude = function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
                    new Bh(this,t)
            }
            ,
            rp.prototype.makeGeometry = function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
                    new Vh(this,t)
            }
            ,
            un.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                    this.fromBufferAttribute(t, e, n)
            }
            ,
            un.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
                    this.manhattanDistanceTo(t)
            }
            ,
            un.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
                    this.manhattanLength()
            }
            ,
            bn.prototype.setEulerFromRotationMatrix = function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }
            ,
            bn.prototype.setEulerFromQuaternion = function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }
            ,
            bn.prototype.getPositionFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                    this.setFromMatrixPosition(t)
            }
            ,
            bn.prototype.getScaleFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                    this.setFromMatrixScale(t)
            }
            ,
            bn.prototype.getColumnFromMatrix = function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                    this.setFromMatrixColumn(e, t)
            }
            ,
            bn.prototype.applyProjection = function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
                    this.applyMatrix4(t)
            }
            ,
            bn.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                    this.fromBufferAttribute(t, e, n)
            }
            ,
            bn.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
                    this.manhattanDistanceTo(t)
            }
            ,
            bn.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
                    this.manhattanLength()
            }
            ,
            vn.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
                    this.fromBufferAttribute(t, e, n)
            }
            ,
            vn.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
                    this.manhattanLength()
            }
            ,
            Mi.prototype.getChildByName = function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                    this.getObjectByName(t)
            }
            ,
            Mi.prototype.renderDepth = function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }
            ,
            Mi.prototype.translate = function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                    this.translateOnAxis(e, t)
            }
            ,
            Mi.prototype.getWorldRotation = function() {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }
            ,
            Mi.prototype.applyMatrix = function(t) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
                    this.applyMatrix4(t)
            }
            ,
            Object.defineProperties(Mi.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }),
            Nr.prototype.setDrawMode = function() {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
            ,
            Object.defineProperties(Nr.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                            Be
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }),
            Eu.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }
            ,
            Object.defineProperty(Rd.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                        this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
                        this.arcLengthDivisions = t
                }
            }),
            Wr.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
                void 0 !== e && (this.filmGauge = e),
                    this.setFocalLength(t)
            }
            ,
            Object.defineProperties(op.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                            this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                            this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                            this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                            this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                            this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                            this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                            this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                            this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                            this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                            this.shadow.mapSize.height = t
                    }
                }
            }),
            Object.defineProperties(Ki.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                            this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                        this.usage === rn
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                            this.setUsage(rn)
                    }
                }
            }),
            Ki.prototype.setDynamic = function(t) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
                    this.setUsage(!0 === t ? rn : nn),
                    this
            }
            ,
            Ki.prototype.copyIndicesArray = function() {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }
            ,
            Ki.prototype.setArray = function() {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }
            ,
            gr.prototype.addIndex = function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                    this.setIndex(t)
            }
            ,
            gr.prototype.addAttribute = function(t, e) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
                    e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                        this.setIndex(e),
                        this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                        this.setAttribute(t, new Ki(arguments[1],arguments[2])))
            }
            ,
            gr.prototype.addDrawCall = function(t, e, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                    this.addGroup(t, e)
            }
            ,
            gr.prototype.clearDrawCalls = function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                    this.clearGroups()
            }
            ,
            gr.prototype.computeOffsets = function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
            ,
            gr.prototype.removeAttribute = function(t) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
                    this.deleteAttribute(t)
            }
            ,
            gr.prototype.applyMatrix = function(t) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
                    this.applyMatrix4(t)
            }
            ,
            Object.defineProperties(gr.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                            this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                            this.groups
                    }
                }
            }),
            Object.defineProperties(Tp.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                            this.instanceCount
                    },
                    set: function(t) {
                        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                            this.instanceCount = t
                    }
                }
            }),
        Object.defineProperties(sf.prototype, {
            linePrecision: {
                get: function() {
                    return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                        this.params.Line.threshold
                },
                set: function(t) {
                    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                        this.params.Line.threshold = t
                }
            }
        }),
        Object.defineProperties(eu.prototype, {
            dynamic: {
                get: function() {
                    return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                    this.usage === rn
                },
                set: function(t) {
                    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                        this.setUsage(t)
                }
            }
        }),
        eu.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
                this.setUsage(!0 === t ? rn : nn),
                this
        }
        ,
        eu.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        Bh.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }
        ,
        Bh.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }
        ,
        Bh.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }
        ,
        tu.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }
        ,
        nf.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
        }
        ,
        Object.defineProperties(zi.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."),
                        new Xi
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = t === m
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                        this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                        this.stencilFuncMask = t
                }
            }
        }),
        Object.defineProperties(Zh.prototype, {
            transparency: {
                get: function() {
                    return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                        this.transmission
                },
                set: function(t) {
                    console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                        this.transmission = t
                }
            }
        }),
        Object.defineProperties(Gr.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                        this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                        this.extensions.derivatives = t
                }
            }
        }),
        Jl.prototype.clearTarget = function(t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
                this.setRenderTarget(t),
                this.clear(e, n, i)
        }
        ,
        Jl.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
                this.setAnimationLoop(t)
        }
        ,
        Jl.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
                this.getRenderTarget()
        }
        ,
        Jl.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
                this.capabilities.getMaxAnisotropy()
        }
        ,
        Jl.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
                this.capabilities.precision
        }
        ,
        Jl.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
                this.state.reset()
        }
        ,
        Jl.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                this.extensions.get("OES_texture_float")
        }
        ,
        Jl.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                this.extensions.get("OES_texture_half_float")
        }
        ,
        Jl.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                this.extensions.get("OES_standard_derivatives")
        }
        ,
        Jl.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                this.extensions.get("WEBGL_compressed_texture_s3tc")
        }
        ,
        Jl.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }
        ,
        Jl.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                this.extensions.get("EXT_blend_minmax")
        }
        ,
        Jl.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
                this.capabilities.vertexTextures
        }
        ,
        Jl.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                this.extensions.get("ANGLE_instanced_arrays")
        }
        ,
        Jl.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                this.setScissorTest(t)
        }
        ,
        Jl.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }
        ,
        Jl.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }
        ,
        Jl.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }
        ,
        Jl.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
        ,
        Jl.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
        ,
        Jl.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }
        ,
        Jl.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }
        ,
        Jl.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }
        ,
        Jl.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
        ,
        Jl.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
                this.getActiveMipmapLevel()
        }
        ,
        Object.defineProperties(Jl.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                        this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                        this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                        this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                        this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                        !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                        !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                        this.outputEncoding = !0 === t ? Ge : je
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                        1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }),
        Object.defineProperties(zl.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }),
        Object.defineProperties(yn.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                        this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                        this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                        this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                        this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                        this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                        this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                        this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                        this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                        this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                        this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                        this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                        this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                        this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                        this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                        this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                        this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                        this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                        this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                        this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                        this.texture.generateMipmaps = t
                }
            }
        }),
        Hp.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this
                , n = new Dp;
            return n.load(t, (function(t) {
                    e.setBuffer(t)
                }
            )),
                this
        }
        ,
        Bp.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
                this.getFrequencyData()
        }
        ,
        Yr.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
                this.update(t, e)
        }
        ,
        Yr.prototype.clear = function(t, e, n, i) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
                this.renderTarget.clear(t, e, n, i)
        }
        ,
        pn.crossOrigin = void 0,
        pn.loadTexture = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const r = new Ld;
            r.setCrossOrigin(this.crossOrigin);
            const o = r.load(t, n, void 0, i);
            return e && (o.mapping = e),
                o
        }
        ,
        pn.loadTextureCube = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const r = new Td;
            r.setCrossOrigin(this.crossOrigin);
            const o = r.load(t, n, void 0, i);
            return e && (o.mapping = e),
                o
        }
        ,
        pn.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        pn.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
        ;
        "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: i
            }
        })),
        "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
    },
    "5c6c": function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    },
    "5cc6": function(t, e, n) {
        var i = n("74e8");
        i("Uint8", (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
        ))
    },
    "5f96": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = i.aTypedArray
            , o = i.exportTypedArrayMethod
            , s = [].join;
        o("join", (function(t) {
                return s.apply(r(this), arguments)
            }
        ))
    },
    "605d": function(t, e, n) {
        var i = n("c6b6")
            , r = n("da84");
        t.exports = "process" == i(r.process)
    },
    "60bd": function(t, e, n) {
        "use strict";
        var i = n("da84")
            , r = n("ebb5")
            , o = n("e260")
            , s = n("b622")
            , a = s("iterator")
            , c = i.Uint8Array
            , l = o.values
            , u = o.keys
            , h = o.entries
            , d = r.aTypedArray
            , p = r.exportTypedArrayMethod
            , f = c && c.prototype[a]
            , m = !!f && ("values" == f.name || void 0 == f.name)
            , g = function() {
            return l.call(d(this))
        };
        p("entries", (function() {
                return h.call(d(this))
            }
        )),
            p("keys", (function() {
                    return u.call(d(this))
                }
            )),
            p("values", g, !m),
            p(a, g, !m)
    },
    "60da": function(t, e, n) {
        "use strict";
        var i = n("83ab")
            , r = n("d039")
            , o = n("df75")
            , s = n("7418")
            , a = n("d1e7")
            , c = n("7b0b")
            , l = n("44ad")
            , u = Object.assign
            , h = Object.defineProperty;
        t.exports = !u || r((function() {
                if (i && 1 !== u({
                    b: 1
                }, u(h({}, "a", {
                    enumerable: !0,
                    get: function() {
                        h(this, "b", {
                            value: 3,
                            enumerable: !1
                        })
                    }
                }), {
                    b: 2
                })).b)
                    return !0;
                var t = {}
                    , e = {}
                    , n = Symbol()
                    , r = "abcdefghijklmnopqrst";
                return t[n] = 7,
                    r.split("").forEach((function(t) {
                            e[t] = t
                        }
                    )),
                7 != u({}, t)[n] || o(u({}, e)).join("") != r
            }
        )) ? function(t, e) {
                var n = c(t)
                    , r = arguments.length
                    , u = 1
                    , h = s.f
                    , d = a.f;
                while (r > u) {
                    var p, f = l(arguments[u++]), m = h ? o(f).concat(h(f)) : o(f), g = m.length, v = 0;
                    while (g > v)
                        p = m[v++],
                        i && !d.call(f, p) || (n[p] = f[p])
                }
                return n
            }
            : u
    },
    "621a": function(t, e, n) {
        "use strict";
        var i = n("da84")
            , r = n("83ab")
            , o = n("a981")
            , s = n("9112")
            , a = n("e2cc")
            , c = n("d039")
            , l = n("19aa")
            , u = n("a691")
            , h = n("50c4")
            , d = n("0b25")
            , p = n("77a7")
            , f = n("e163")
            , m = n("d2bb")
            , g = n("241c").f
            , v = n("9bf2").f
            , y = n("81d5")
            , _ = n("d44e")
            , x = n("69f3")
            , b = x.get
            , w = x.set
            , M = "ArrayBuffer"
            , S = "DataView"
            , E = "prototype"
            , T = "Wrong length"
            , A = "Wrong index"
            , L = i[M]
            , R = L
            , C = i[S]
            , P = C && C[E]
            , O = Object.prototype
            , I = i.RangeError
            , N = p.pack
            , D = p.unpack
            , F = function(t) {
            return [255 & t]
        }
            , k = function(t) {
            return [255 & t, t >> 8 & 255]
        }
            , H = function(t) {
            return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
        }
            , B = function(t) {
            return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
        }
            , z = function(t) {
            return N(t, 23, 4)
        }
            , U = function(t) {
            return N(t, 52, 8)
        }
            , j = function(t, e) {
            v(t[E], e, {
                get: function() {
                    return b(this)[e]
                }
            })
        }
            , G = function(t, e, n, i) {
            var r = d(n)
                , o = b(t);
            if (r + e > o.byteLength)
                throw I(A);
            var s = b(o.buffer).bytes
                , a = r + o.byteOffset
                , c = s.slice(a, a + e);
            return i ? c : c.reverse()
        }
            , V = function(t, e, n, i, r, o) {
            var s = d(n)
                , a = b(t);
            if (s + e > a.byteLength)
                throw I(A);
            for (var c = b(a.buffer).bytes, l = s + a.byteOffset, u = i(+r), h = 0; h < e; h++)
                c[l + h] = u[o ? h : e - h - 1]
        };
        if (o) {
            if (!c((function() {
                    L(1)
                }
            )) || !c((function() {
                    new L(-1)
                }
            )) || c((function() {
                    return new L,
                        new L(1.5),
                        new L(NaN),
                    L.name != M
                }
            ))) {
                R = function(t) {
                    return l(this, R),
                        new L(d(t))
                }
                ;
                for (var W, q = R[E] = L[E], X = g(L), Y = 0; X.length > Y; )
                    (W = X[Y++])in R || s(R, W, L[W]);
                q.constructor = R
            }
            m && f(P) !== O && m(P, O);
            var Z = new C(new R(2))
                , J = P.setInt8;
            Z.setInt8(0, 2147483648),
                Z.setInt8(1, 2147483649),
            !Z.getInt8(0) && Z.getInt8(1) || a(P, {
                setInt8: function(t, e) {
                    J.call(this, t, e << 24 >> 24)
                },
                setUint8: function(t, e) {
                    J.call(this, t, e << 24 >> 24)
                }
            }, {
                unsafe: !0
            })
        } else
            R = function(t) {
                l(this, R, M);
                var e = d(t);
                w(this, {
                    bytes: y.call(new Array(e), 0),
                    byteLength: e
                }),
                r || (this.byteLength = e)
            }
                ,
                C = function(t, e, n) {
                    l(this, C, S),
                        l(t, R, S);
                    var i = b(t).byteLength
                        , o = u(e);
                    if (o < 0 || o > i)
                        throw I("Wrong offset");
                    if (n = void 0 === n ? i - o : h(n),
                    o + n > i)
                        throw I(T);
                    w(this, {
                        buffer: t,
                        byteLength: n,
                        byteOffset: o
                    }),
                    r || (this.buffer = t,
                        this.byteLength = n,
                        this.byteOffset = o)
                }
                ,
            r && (j(R, "byteLength"),
                j(C, "buffer"),
                j(C, "byteLength"),
                j(C, "byteOffset")),
                a(C[E], {
                    getInt8: function(t) {
                        return G(this, 1, t)[0] << 24 >> 24
                    },
                    getUint8: function(t) {
                        return G(this, 1, t)[0]
                    },
                    getInt16: function(t) {
                        var e = G(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                        return (e[1] << 8 | e[0]) << 16 >> 16
                    },
                    getUint16: function(t) {
                        var e = G(this, 2, t, arguments.length > 1 ? arguments[1] : void 0);
                        return e[1] << 8 | e[0]
                    },
                    getInt32: function(t) {
                        return B(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0))
                    },
                    getUint32: function(t) {
                        return B(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
                    },
                    getFloat32: function(t) {
                        return D(G(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23)
                    },
                    getFloat64: function(t) {
                        return D(G(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52)
                    },
                    setInt8: function(t, e) {
                        V(this, 1, t, F, e)
                    },
                    setUint8: function(t, e) {
                        V(this, 1, t, F, e)
                    },
                    setInt16: function(t, e) {
                        V(this, 2, t, k, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    setUint16: function(t, e) {
                        V(this, 2, t, k, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    setInt32: function(t, e) {
                        V(this, 4, t, H, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    setUint32: function(t, e) {
                        V(this, 4, t, H, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    setFloat32: function(t, e) {
                        V(this, 4, t, z, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    setFloat64: function(t, e) {
                        V(this, 8, t, U, e, arguments.length > 2 ? arguments[2] : void 0)
                    }
                });
        _(R, M),
            _(C, S),
            t.exports = {
                ArrayBuffer: R,
                DataView: C
            }
    },
    "649e": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").some
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("some", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    "65f0": function(t, e, n) {
        var i = n("861d")
            , r = n("e8b5")
            , o = n("b622")
            , s = o("species");
        t.exports = function(t, e) {
            var n;
            return r(t) && (n = t.constructor,
                "function" != typeof n || n !== Array && !r(n.prototype) ? i(n) && (n = n[s],
                null === n && (n = void 0)) : n = void 0),
                new (void 0 === n ? Array : n)(0 === e ? 0 : e)
        }
    },
    "69f3": function(t, e, n) {
        var i, r, o, s = n("7f9a"), a = n("da84"), c = n("861d"), l = n("9112"), u = n("5135"), h = n("c6cd"), d = n("f772"), p = n("d012"), f = a.WeakMap, m = function(t) {
            return o(t) ? r(t) : i(t, {})
        }, g = function(t) {
            return function(e) {
                var n;
                if (!c(e) || (n = r(e)).type !== t)
                    throw TypeError("Incompatible receiver, " + t + " required");
                return n
            }
        };
        if (s) {
            var v = h.state || (h.state = new f)
                , y = v.get
                , _ = v.has
                , x = v.set;
            i = function(t, e) {
                return e.facade = t,
                    x.call(v, t, e),
                    e
            }
                ,
                r = function(t) {
                    return y.call(v, t) || {}
                }
                ,
                o = function(t) {
                    return _.call(v, t)
                }
        } else {
            var b = d("state");
            p[b] = !0,
                i = function(t, e) {
                    return e.facade = t,
                        l(t, b, e),
                        e
                }
                ,
                r = function(t) {
                    return u(t, b) ? t[b] : {}
                }
                ,
                o = function(t) {
                    return u(t, b)
                }
        }
        t.exports = {
            set: i,
            get: r,
            has: o,
            enforce: m,
            getterFor: g
        }
    },
    "6eeb": function(t, e, n) {
        var i = n("da84")
            , r = n("9112")
            , o = n("5135")
            , s = n("ce4e")
            , a = n("8925")
            , c = n("69f3")
            , l = c.get
            , u = c.enforce
            , h = String(String).split("String");
        (t.exports = function(t, e, n, a) {
                var c, l = !!a && !!a.unsafe, d = !!a && !!a.enumerable, p = !!a && !!a.noTargetGet;
                "function" == typeof n && ("string" != typeof e || o(n, "name") || r(n, "name", e),
                    c = u(n),
                c.source || (c.source = h.join("string" == typeof e ? e : ""))),
                    t !== i ? (l ? !p && t[e] && (d = !0) : delete t[e],
                        d ? t[e] = n : r(t, e, n)) : d ? t[e] = n : s(e, n)
            }
        )(Function.prototype, "toString", (function() {
                return "function" == typeof this && l(this).source || a(this)
            }
        ))
    },
    7156: function(t, e, n) {
        var i = n("861d")
            , r = n("d2bb");
        t.exports = function(t, e, n) {
            var o, s;
            return r && "function" == typeof (o = e.constructor) && o !== n && i(s = o.prototype) && s !== n.prototype && r(t, s),
                t
        }
    },
    "72f7": function(t, e, n) {
        "use strict";
        var i = n("ebb5").exportTypedArrayMethod
            , r = n("d039")
            , o = n("da84")
            , s = o.Uint8Array
            , a = s && s.prototype || {}
            , c = [].toString
            , l = [].join;
        r((function() {
                c.call({})
            }
        )) && (c = function() {
                return l.call(this)
            }
        );
        var u = a.toString != c;
        i("toString", c, u)
    },
    "735e": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("81d5")
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("fill", (function(t) {
                return r.apply(o(this), arguments)
            }
        ))
    },
    7418: function(t, e) {
        e.f = Object.getOwnPropertySymbols
    },
    "74e8": function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("da84")
            , o = n("83ab")
            , s = n("8aa7")
            , a = n("ebb5")
            , c = n("621a")
            , l = n("19aa")
            , u = n("5c6c")
            , h = n("9112")
            , d = n("50c4")
            , p = n("0b25")
            , f = n("182d")
            , m = n("c04e")
            , g = n("5135")
            , v = n("f5df")
            , y = n("861d")
            , _ = n("7c73")
            , x = n("d2bb")
            , b = n("241c").f
            , w = n("a078")
            , M = n("b727").forEach
            , S = n("2626")
            , E = n("9bf2")
            , T = n("06cf")
            , A = n("69f3")
            , L = n("7156")
            , R = A.get
            , C = A.set
            , P = E.f
            , O = T.f
            , I = Math.round
            , N = r.RangeError
            , D = c.ArrayBuffer
            , F = c.DataView
            , k = a.NATIVE_ARRAY_BUFFER_VIEWS
            , H = a.TYPED_ARRAY_TAG
            , B = a.TypedArray
            , z = a.TypedArrayPrototype
            , U = a.aTypedArrayConstructor
            , j = a.isTypedArray
            , G = "BYTES_PER_ELEMENT"
            , V = "Wrong length"
            , W = function(t, e) {
            var n = 0
                , i = e.length
                , r = new (U(t))(i);
            while (i > n)
                r[n] = e[n++];
            return r
        }
            , q = function(t, e) {
            P(t, e, {
                get: function() {
                    return R(this)[e]
                }
            })
        }
            , X = function(t) {
            var e;
            return t instanceof D || "ArrayBuffer" == (e = v(t)) || "SharedArrayBuffer" == e
        }
            , Y = function(t, e) {
            return j(t) && "symbol" != typeof e && e in t && String(+e) == String(e)
        }
            , Z = function(t, e) {
            return Y(t, e = m(e, !0)) ? u(2, t[e]) : O(t, e)
        }
            , J = function(t, e, n) {
            return !(Y(t, e = m(e, !0)) && y(n) && g(n, "value")) || g(n, "get") || g(n, "set") || n.configurable || g(n, "writable") && !n.writable || g(n, "enumerable") && !n.enumerable ? P(t, e, n) : (t[e] = n.value,
                t)
        };
        o ? (k || (T.f = Z,
                E.f = J,
                q(z, "buffer"),
                q(z, "byteOffset"),
                q(z, "byteLength"),
                q(z, "length")),
                i({
                    target: "Object",
                    stat: !0,
                    forced: !k
                }, {
                    getOwnPropertyDescriptor: Z,
                    defineProperty: J
                }),
                t.exports = function(t, e, n) {
                    var o = t.match(/\d+$/)[0] / 8
                        , a = t + (n ? "Clamped" : "") + "Array"
                        , c = "get" + t
                        , u = "set" + t
                        , m = r[a]
                        , g = m
                        , v = g && g.prototype
                        , E = {}
                        , T = function(t, e) {
                        var n = R(t);
                        return n.view[c](e * o + n.byteOffset, !0)
                    }
                        , A = function(t, e, i) {
                        var r = R(t);
                        n && (i = (i = I(i)) < 0 ? 0 : i > 255 ? 255 : 255 & i),
                            r.view[u](e * o + r.byteOffset, i, !0)
                    }
                        , O = function(t, e) {
                        P(t, e, {
                            get: function() {
                                return T(this, e)
                            },
                            set: function(t) {
                                return A(this, e, t)
                            },
                            enumerable: !0
                        })
                    };
                    k ? s && (g = e((function(t, e, n, i) {
                            return l(t, g, a),
                                L(function() {
                                    return y(e) ? X(e) ? void 0 !== i ? new m(e,f(n, o),i) : void 0 !== n ? new m(e,f(n, o)) : new m(e) : j(e) ? W(g, e) : w.call(g, e) : new m(p(e))
                                }(), t, g)
                        }
                    )),
                    x && x(g, B),
                        M(b(m), (function(t) {
                                t in g || h(g, t, m[t])
                            }
                        )),
                        g.prototype = v) : (g = e((function(t, e, n, i) {
                            l(t, g, a);
                            var r, s, c, u = 0, h = 0;
                            if (y(e)) {
                                if (!X(e))
                                    return j(e) ? W(g, e) : w.call(g, e);
                                r = e,
                                    h = f(n, o);
                                var m = e.byteLength;
                                if (void 0 === i) {
                                    if (m % o)
                                        throw N(V);
                                    if (s = m - h,
                                    s < 0)
                                        throw N(V)
                                } else if (s = d(i) * o,
                                s + h > m)
                                    throw N(V);
                                c = s / o
                            } else
                                c = p(e),
                                    s = c * o,
                                    r = new D(s);
                            C(t, {
                                buffer: r,
                                byteOffset: h,
                                byteLength: s,
                                length: c,
                                view: new F(r)
                            });
                            while (u < c)
                                O(t, u++)
                        }
                    )),
                    x && x(g, B),
                        v = g.prototype = _(z)),
                    v.constructor !== g && h(v, "constructor", g),
                    H && h(v, H, a),
                        E[a] = g,
                        i({
                            global: !0,
                            forced: g != m,
                            sham: !k
                        }, E),
                    G in g || h(g, G, o),
                    G in v || h(v, G, o),
                        S(a)
                }
        ) : t.exports = function() {}
    },
    "77a7": function(t, e) {
        var n = Math.abs
            , i = Math.pow
            , r = Math.floor
            , o = Math.log
            , s = Math.LN2
            , a = function(t, e, a) {
            var c, l, u, h = new Array(a), d = 8 * a - e - 1, p = (1 << d) - 1, f = p >> 1, m = 23 === e ? i(2, -24) - i(2, -77) : 0, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0, v = 0;
            for (t = n(t),
                     t != t || t === 1 / 0 ? (l = t != t ? 1 : 0,
                         c = p) : (c = r(o(t) / s),
                     t * (u = i(2, -c)) < 1 && (c--,
                         u *= 2),
                         t += c + f >= 1 ? m / u : m * i(2, 1 - f),
                     t * u >= 2 && (c++,
                         u /= 2),
                         c + f >= p ? (l = 0,
                             c = p) : c + f >= 1 ? (l = (t * u - 1) * i(2, e),
                             c += f) : (l = t * i(2, f - 1) * i(2, e),
                             c = 0)); e >= 8; h[v++] = 255 & l,
                     l /= 256,
                     e -= 8)
                ;
            for (c = c << e | l,
                     d += e; d > 0; h[v++] = 255 & c,
                     c /= 256,
                     d -= 8)
                ;
            return h[--v] |= 128 * g,
                h
        }
            , c = function(t, e) {
            var n, r = t.length, o = 8 * r - e - 1, s = (1 << o) - 1, a = s >> 1, c = o - 7, l = r - 1, u = t[l--], h = 127 & u;
            for (u >>= 7; c > 0; h = 256 * h + t[l],
                l--,
                c -= 8)
                ;
            for (n = h & (1 << -c) - 1,
                     h >>= -c,
                     c += e; c > 0; n = 256 * n + t[l],
                     l--,
                     c -= 8)
                ;
            if (0 === h)
                h = 1 - a;
            else {
                if (h === s)
                    return n ? NaN : u ? -1 / 0 : 1 / 0;
                n += i(2, e),
                    h -= a
            }
            return (u ? -1 : 1) * n * i(2, h - e)
        };
        t.exports = {
            pack: a,
            unpack: c
        }
    },
    7839: function(t, e) {
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    },
    "7a23": function(t, e, n) {
        "use strict";
        n.d(e, "k", (function() {
                return i["I"]
            }
        )),
            n.d(e, "a", (function() {
                    return Wn
                }
            )),
            n.d(e, "c", (function() {
                    return ti
                }
            )),
            n.d(e, "d", (function() {
                    return ui
                }
            )),
            n.d(e, "e", (function() {
                    return li
                }
            )),
            n.d(e, "f", (function() {
                    return si
                }
            )),
            n.d(e, "g", (function() {
                    return Kn
                }
            )),
            n.d(e, "h", (function() {
                    return fe
                }
            )),
            n.d(e, "i", (function() {
                    return pe
                }
            )),
            n.d(e, "j", (function() {
                    return Un
                }
            )),
            n.d(e, "l", (function() {
                    return me
                }
            )),
            n.d(e, "b", (function() {
                    return Yr
                }
            ));
        var i = n("9ff4");
        const r = new WeakMap
            , o = [];
        let s;
        const a = Symbol("")
            , c = Symbol("");
        function l(t) {
            return t && !0 === t._isEffect
        }
        function u(t, e=i["b"]) {
            l(t) && (t = t.raw);
            const n = p(t, e);
            return e.lazy || n(),
                n
        }
        function h(t) {
            t.active && (f(t),
            t.options.onStop && t.options.onStop(),
                t.active = !1)
        }
        let d = 0;
        function p(t, e) {
            const n = function() {
                if (!n.active)
                    return e.scheduler ? void 0 : t();
                if (!o.includes(n)) {
                    f(n);
                    try {
                        return y(),
                            o.push(n),
                            s = n,
                            t()
                    } finally {
                        o.pop(),
                            _(),
                            s = o[o.length - 1]
                    }
                }
            };
            return n.id = d++,
                n.allowRecurse = !!e.allowRecurse,
                n._isEffect = !0,
                n.active = !0,
                n.raw = t,
                n.deps = [],
                n.options = e,
                n
        }
        function f(t) {
            const {deps: e} = t;
            if (e.length) {
                for (let n = 0; n < e.length; n++)
                    e[n].delete(t);
                e.length = 0
            }
        }
        let m = !0;
        const g = [];
        function v() {
            g.push(m),
                m = !1
        }
        function y() {
            g.push(m),
                m = !0
        }
        function _() {
            const t = g.pop();
            m = void 0 === t || t
        }
        function x(t, e, n) {
            if (!m || void 0 === s)
                return;
            let i = r.get(t);
            i || r.set(t, i = new Map);
            let o = i.get(n);
            o || i.set(n, o = new Set),
            o.has(s) || (o.add(s),
                s.deps.push(o))
        }
        function b(t, e, n, o, l, u) {
            const h = r.get(t);
            if (!h)
                return;
            const d = new Set
                , p = t=>{
                    t && t.forEach(t=>{
                            (t !== s || t.allowRecurse) && d.add(t)
                        }
                    )
                }
            ;
            if ("clear" === e)
                h.forEach(p);
            else if ("length" === n && Object(i["m"])(t))
                h.forEach((t,e)=>{
                        ("length" === e || e >= o) && p(t)
                    }
                );
            else
                switch (void 0 !== n && p(h.get(n)),
                    e) {
                    case "add":
                        Object(i["m"])(t) ? Object(i["q"])(n) && p(h.get("length")) : (p(h.get(a)),
                        Object(i["r"])(t) && p(h.get(c)));
                        break;
                    case "delete":
                        Object(i["m"])(t) || (p(h.get(a)),
                        Object(i["r"])(t) && p(h.get(c)));
                        break;
                    case "set":
                        Object(i["r"])(t) && p(h.get(a));
                        break
                }
            const f = t=>{
                    t.options.scheduler ? t.options.scheduler(t) : t()
                }
            ;
            d.forEach(f)
        }
        const w = Object(i["E"])("__proto__,__v_isRef,__isVue")
            , M = new Set(Object.getOwnPropertyNames(Symbol).map(t=>Symbol[t]).filter(i["B"]))
            , S = R()
            , E = R(!1, !0)
            , T = R(!0)
            , A = R(!0, !0)
            , L = {};
        function R(t=!1, e=!1) {
            return function(n, r, o) {
                if ("__v_isReactive" === r)
                    return !t;
                if ("__v_isReadonly" === r)
                    return t;
                if ("__v_raw" === r && o === (t ? e ? ht : ut : e ? lt : ct).get(n))
                    return n;
                const s = Object(i["m"])(n);
                if (!t && s && Object(i["j"])(L, r))
                    return Reflect.get(L, r, o);
                const a = Reflect.get(n, r, o);
                if (Object(i["B"])(r) ? M.has(r) : w(r))
                    return a;
                if (t || x(n, "get", r),
                    e)
                    return a;
                if (wt(a)) {
                    const t = !s || !Object(i["q"])(r);
                    return t ? a.value : a
                }
                return Object(i["t"])(a) ? t ? gt(a) : ft(a) : a
            }
        }
        ["includes", "indexOf", "lastIndexOf"].forEach(t=>{
                const e = Array.prototype[t];
                L[t] = function(...t) {
                    const n = bt(this);
                    for (let e = 0, r = this.length; e < r; e++)
                        x(n, "get", e + "");
                    const i = e.apply(n, t);
                    return -1 === i || !1 === i ? e.apply(n, t.map(bt)) : i
                }
            }
        ),
            ["push", "pop", "shift", "unshift", "splice"].forEach(t=>{
                    const e = Array.prototype[t];
                    L[t] = function(...t) {
                        v();
                        const n = e.apply(this, t);
                        return _(),
                            n
                    }
                }
            );
        const C = O()
            , P = O(!0);
        function O(t=!1) {
            return function(e, n, r, o) {
                let s = e[n];
                if (!t && (r = bt(r),
                    s = bt(s),
                !Object(i["m"])(e) && wt(s) && !wt(r)))
                    return s.value = r,
                        !0;
                const a = Object(i["m"])(e) && Object(i["q"])(n) ? Number(n) < e.length : Object(i["j"])(e, n)
                    , c = Reflect.set(e, n, r, o);
                return e === bt(o) && (a ? Object(i["i"])(r, s) && b(e, "set", n, r, s) : b(e, "add", n, r)),
                    c
            }
        }
        function I(t, e) {
            const n = Object(i["j"])(t, e)
                , r = t[e]
                , o = Reflect.deleteProperty(t, e);
            return o && n && b(t, "delete", e, void 0, r),
                o
        }
        function N(t, e) {
            const n = Reflect.has(t, e);
            return Object(i["B"])(e) && M.has(e) || x(t, "has", e),
                n
        }
        function D(t) {
            return x(t, "iterate", Object(i["m"])(t) ? "length" : a),
                Reflect.ownKeys(t)
        }
        const F = {
            get: S,
            set: C,
            deleteProperty: I,
            has: N,
            ownKeys: D
        }
            , k = {
            get: T,
            set(t, e) {
                return !0
            },
            deleteProperty(t, e) {
                return !0
            }
        }
            , H = Object(i["h"])({}, F, {
            get: E,
            set: P
        })
            , B = (Object(i["h"])({}, k, {
            get: A
        }),
            t=>Object(i["t"])(t) ? ft(t) : t)
            , z = t=>Object(i["t"])(t) ? gt(t) : t
            , U = t=>t
            , j = t=>Reflect.getPrototypeOf(t);
        function G(t, e, n=!1, i=!1) {
            t = t["__v_raw"];
            const r = bt(t)
                , o = bt(e);
            e !== o && !n && x(r, "get", e),
            !n && x(r, "get", o);
            const {has: s} = j(r)
                , a = i ? U : n ? z : B;
            return s.call(r, e) ? a(t.get(e)) : s.call(r, o) ? a(t.get(o)) : void 0
        }
        function V(t, e=!1) {
            const n = this["__v_raw"]
                , i = bt(n)
                , r = bt(t);
            return t !== r && !e && x(i, "has", t),
            !e && x(i, "has", r),
                t === r ? n.has(t) : n.has(t) || n.has(r)
        }
        function W(t, e=!1) {
            return t = t["__v_raw"],
            !e && x(bt(t), "iterate", a),
                Reflect.get(t, "size", t)
        }
        function q(t) {
            t = bt(t);
            const e = bt(this)
                , n = j(e)
                , i = n.has.call(e, t);
            return i || (e.add(t),
                b(e, "add", t, t)),
                this
        }
        function X(t, e) {
            e = bt(e);
            const n = bt(this)
                , {has: r, get: o} = j(n);
            let s = r.call(n, t);
            s || (t = bt(t),
                s = r.call(n, t));
            const a = o.call(n, t);
            return n.set(t, e),
                s ? Object(i["i"])(e, a) && b(n, "set", t, e, a) : b(n, "add", t, e),
                this
        }
        function Y(t) {
            const e = bt(this)
                , {has: n, get: i} = j(e);
            let r = n.call(e, t);
            r || (t = bt(t),
                r = n.call(e, t));
            const o = i ? i.call(e, t) : void 0
                , s = e.delete(t);
            return r && b(e, "delete", t, void 0, o),
                s
        }
        function Z() {
            const t = bt(this)
                , e = 0 !== t.size
                , n = void 0
                , i = t.clear();
            return e && b(t, "clear", void 0, void 0, n),
                i
        }
        function J(t, e) {
            return function(n, i) {
                const r = this
                    , o = r["__v_raw"]
                    , s = bt(o)
                    , c = e ? U : t ? z : B;
                return !t && x(s, "iterate", a),
                    o.forEach((t,e)=>n.call(i, c(t), c(e), r))
            }
        }
        function K(t, e, n) {
            return function(...r) {
                const o = this["__v_raw"]
                    , s = bt(o)
                    , l = Object(i["r"])(s)
                    , u = "entries" === t || t === Symbol.iterator && l
                    , h = "keys" === t && l
                    , d = o[t](...r)
                    , p = n ? U : e ? z : B;
                return !e && x(s, "iterate", h ? c : a),
                    {
                        next() {
                            const {value: t, done: e} = d.next();
                            return e ? {
                                value: t,
                                done: e
                            } : {
                                value: u ? [p(t[0]), p(t[1])] : p(t),
                                done: e
                            }
                        },
                        [Symbol.iterator]() {
                            return this
                        }
                    }
            }
        }
        function Q(t) {
            return function(...e) {
                return "delete" !== t && this
            }
        }
        const $ = {
            get(t) {
                return G(this, t)
            },
            get size() {
                return W(this)
            },
            has: V,
            add: q,
            set: X,
            delete: Y,
            clear: Z,
            forEach: J(!1, !1)
        }
            , tt = {
            get(t) {
                return G(this, t, !1, !0)
            },
            get size() {
                return W(this)
            },
            has: V,
            add: q,
            set: X,
            delete: Y,
            clear: Z,
            forEach: J(!1, !0)
        }
            , et = {
            get(t) {
                return G(this, t, !0)
            },
            get size() {
                return W(this, !0)
            },
            has(t) {
                return V.call(this, t, !0)
            },
            add: Q("add"),
            set: Q("set"),
            delete: Q("delete"),
            clear: Q("clear"),
            forEach: J(!0, !1)
        }
            , nt = {
            get(t) {
                return G(this, t, !0, !0)
            },
            get size() {
                return W(this, !0)
            },
            has(t) {
                return V.call(this, t, !0)
            },
            add: Q("add"),
            set: Q("set"),
            delete: Q("delete"),
            clear: Q("clear"),
            forEach: J(!0, !0)
        }
            , it = ["keys", "values", "entries", Symbol.iterator];
        function rt(t, e) {
            const n = e ? t ? nt : tt : t ? et : $;
            return (e,r,o)=>"__v_isReactive" === r ? !t : "__v_isReadonly" === r ? t : "__v_raw" === r ? e : Reflect.get(Object(i["j"])(n, r) && r in e ? n : e, r, o)
        }
        it.forEach(t=>{
                $[t] = K(t, !1, !1),
                    et[t] = K(t, !0, !1),
                    tt[t] = K(t, !1, !0),
                    nt[t] = K(t, !0, !0)
            }
        );
        const ot = {
            get: rt(!1, !1)
        }
            , st = {
            get: rt(!1, !0)
        }
            , at = {
            get: rt(!0, !1)
        };
        rt(!0, !0);
        const ct = new WeakMap
            , lt = new WeakMap
            , ut = new WeakMap
            , ht = new WeakMap;
        function dt(t) {
            switch (t) {
                case "Object":
                case "Array":
                    return 1;
                case "Map":
                case "Set":
                case "WeakMap":
                case "WeakSet":
                    return 2;
                default:
                    return 0
            }
        }
        function pt(t) {
            return t["__v_skip"] || !Object.isExtensible(t) ? 0 : dt(Object(i["L"])(t))
        }
        function ft(t) {
            return t && t["__v_isReadonly"] ? t : vt(t, !1, F, ot, ct)
        }
        function mt(t) {
            return vt(t, !1, H, st, lt)
        }
        function gt(t) {
            return vt(t, !0, k, at, ut)
        }
        function vt(t, e, n, r, o) {
            if (!Object(i["t"])(t))
                return t;
            if (t["__v_raw"] && (!e || !t["__v_isReactive"]))
                return t;
            const s = o.get(t);
            if (s)
                return s;
            const a = pt(t);
            if (0 === a)
                return t;
            const c = new Proxy(t,2 === a ? r : n);
            return o.set(t, c),
                c
        }
        function yt(t) {
            return _t(t) ? yt(t["__v_raw"]) : !(!t || !t["__v_isReactive"])
        }
        function _t(t) {
            return !(!t || !t["__v_isReadonly"])
        }
        function xt(t) {
            return yt(t) || _t(t)
        }
        function bt(t) {
            return t && bt(t["__v_raw"]) || t
        }
        function wt(t) {
            return Boolean(t && !0 === t.__v_isRef)
        }
        function Mt(t) {
            return wt(t) ? t.value : t
        }
        const St = {
            get: (t,e,n)=>Mt(Reflect.get(t, e, n)),
            set: (t,e,n,i)=>{
                const r = t[e];
                return wt(r) && !wt(n) ? (r.value = n,
                    !0) : Reflect.set(t, e, n, i)
            }
        };
        function Et(t) {
            return yt(t) ? t : new Proxy(t,St)
        }
        class Tt {
            constructor(t, e) {
                this._object = t,
                    this._key = e,
                    this.__v_isRef = !0
            }
            get value() {
                return this._object[this._key]
            }
            set value(t) {
                this._object[this._key] = t
            }
        }
        function At(t, e) {
            return wt(t[e]) ? t[e] : new Tt(t,e)
        }
        class Lt {
            constructor(t, e, n) {
                this._setter = e,
                    this._dirty = !0,
                    this.__v_isRef = !0,
                    this.effect = u(t, {
                        lazy: !0,
                        scheduler: ()=>{
                            this._dirty || (this._dirty = !0,
                                b(bt(this), "set", "value"))
                        }
                    }),
                    this["__v_isReadonly"] = n
            }
            get value() {
                const t = bt(this);
                return t._dirty && (t._value = this.effect(),
                    t._dirty = !1),
                    x(t, "get", "value"),
                    t._value
            }
            set value(t) {
                this._setter(t)
            }
        }
        function Rt(t) {
            let e, n;
            return Object(i["n"])(t) ? (e = t,
                n = i["d"]) : (e = t.get,
                n = t.set),
                new Lt(e,n,Object(i["n"])(t) || !t.set)
        }
        function Ct(t, e, n, i) {
            let r;
            try {
                r = i ? t(...i) : t()
            } catch (o) {
                Ot(o, e, n)
            }
            return r
        }
        function Pt(t, e, n, r) {
            if (Object(i["n"])(t)) {
                const o = Ct(t, e, n, r);
                return o && Object(i["v"])(o) && o.catch(t=>{
                        Ot(t, e, n)
                    }
                ),
                    o
            }
            const o = [];
            for (let i = 0; i < t.length; i++)
                o.push(Pt(t[i], e, n, r));
            return o
        }
        function Ot(t, e, n, i=!0) {
            const r = e ? e.vnode : null;
            if (e) {
                let i = e.parent;
                const r = e.proxy
                    , o = n;
                while (i) {
                    const e = i.ec;
                    if (e)
                        for (let n = 0; n < e.length; n++)
                            if (!1 === e[n](t, r, o))
                                return;
                    i = i.parent
                }
                const s = e.appContext.config.errorHandler;
                if (s)
                    return void Ct(s, null, 10, [t, r, o])
            }
            It(t, n, r, i)
        }
        function It(t, e, n, i=!0) {
            console.error(t)
        }
        let Nt = !1
            , Dt = !1;
        const Ft = [];
        let kt = 0;
        const Ht = [];
        let Bt = null
            , zt = 0;
        const Ut = [];
        let jt = null
            , Gt = 0;
        const Vt = Promise.resolve();
        let Wt = null
            , qt = null;
        function Xt(t) {
            const e = Wt || Vt;
            return t ? e.then(this ? t.bind(this) : t) : e
        }
        function Yt(t) {
            let e = kt + 1
                , n = Ft.length;
            const i = ie(t);
            while (e < n) {
                const t = e + n >>> 1
                    , r = ie(Ft[t]);
                r < i ? e = t + 1 : n = t
            }
            return e
        }
        function Zt(t) {
            if ((!Ft.length || !Ft.includes(t, Nt && t.allowRecurse ? kt + 1 : kt)) && t !== qt) {
                const e = Yt(t);
                e > -1 ? Ft.splice(e, 0, t) : Ft.push(t),
                    Jt()
            }
        }
        function Jt() {
            Nt || Dt || (Dt = !0,
                Wt = Vt.then(re))
        }
        function Kt(t) {
            const e = Ft.indexOf(t);
            e > kt && Ft.splice(e, 1)
        }
        function Qt(t, e, n, r) {
            Object(i["m"])(t) ? n.push(...t) : e && e.includes(t, t.allowRecurse ? r + 1 : r) || n.push(t),
                Jt()
        }
        function $t(t) {
            Qt(t, Bt, Ht, zt)
        }
        function te(t) {
            Qt(t, jt, Ut, Gt)
        }
        function ee(t, e=null) {
            if (Ht.length) {
                for (qt = e,
                         Bt = [...new Set(Ht)],
                         Ht.length = 0,
                         zt = 0; zt < Bt.length; zt++)
                    Bt[zt]();
                Bt = null,
                    zt = 0,
                    qt = null,
                    ee(t, e)
            }
        }
        function ne(t) {
            if (Ut.length) {
                const t = [...new Set(Ut)];
                if (Ut.length = 0,
                    jt)
                    return void jt.push(...t);
                for (jt = t,
                         jt.sort((t,e)=>ie(t) - ie(e)),
                         Gt = 0; Gt < jt.length; Gt++)
                    jt[Gt]();
                jt = null,
                    Gt = 0
            }
        }
        const ie = t=>null == t.id ? 1 / 0 : t.id;
        function re(t) {
            Dt = !1,
                Nt = !0,
                ee(t),
                Ft.sort((t,e)=>ie(t) - ie(e));
            try {
                for (kt = 0; kt < Ft.length; kt++) {
                    const t = Ft[kt];
                    t && Ct(t, null, 14)
                }
            } finally {
                kt = 0,
                    Ft.length = 0,
                    ne(t),
                    Nt = !1,
                    Wt = null,
                (Ft.length || Ut.length) && re(t)
            }
        }
        new Set;
        new Map;
        function oe(t, e, ...n) {
            const r = t.vnode.props || i["b"];
            let o = n;
            const s = e.startsWith("update:")
                , a = s && e.slice(7);
            if (a && a in r) {
                const t = ("modelValue" === a ? "model" : a) + "Modifiers"
                    , {number: e, trim: s} = r[t] || i["b"];
                s ? o = n.map(t=>t.trim()) : e && (o = n.map(i["K"]))
            }
            let c;
            let l = r[c = Object(i["J"])(e)] || r[c = Object(i["J"])(Object(i["e"])(e))];
            !l && s && (l = r[c = Object(i["J"])(Object(i["k"])(e))]),
            l && Pt(l, t, 6, o);
            const u = r[c + "Once"];
            if (u) {
                if (t.emitted) {
                    if (t.emitted[c])
                        return
                } else
                    (t.emitted = {})[c] = !0;
                Pt(u, t, 6, o)
            }
        }
        function se(t, e, n=!1) {
            if (!e.deopt && void 0 !== t.__emits)
                return t.__emits;
            const r = t.emits;
            let o = {}
                , s = !1;
            if (!Object(i["n"])(t)) {
                const r = t=>{
                        const n = se(t, e, !0);
                        n && (s = !0,
                            Object(i["h"])(o, n))
                    }
                ;
                !n && e.mixins.length && e.mixins.forEach(r),
                t.extends && r(t.extends),
                t.mixins && t.mixins.forEach(r)
            }
            return r || s ? (Object(i["m"])(r) ? r.forEach(t=>o[t] = null) : Object(i["h"])(o, r),
                t.__emits = o) : t.__emits = null
        }
        function ae(t, e) {
            return !(!t || !Object(i["u"])(e)) && (e = e.slice(2).replace(/Once$/, ""),
            Object(i["j"])(t, e[0].toLowerCase() + e.slice(1)) || Object(i["j"])(t, Object(i["k"])(e)) || Object(i["j"])(t, e))
        }
        let ce = 0;
        const le = t=>ce += t;
        let ue = null
            , he = null;
        function de(t) {
            const e = ue;
            return ue = t,
                he = t && t.type.__scopeId || null,
                e
        }
        function pe(t) {
            he = t
        }
        function fe() {
            he = null
        }
        const me = t=>ge;
        function ge(t, e=ue) {
            if (!e)
                return t;
            const n = (...n)=>{
                    ce || Kn(!0);
                    const i = de(e)
                        , r = t(...n);
                    return de(i),
                    ce || Qn(),
                        r
                }
            ;
            return n._c = !0,
                n
        }
        function ve(t) {
            const {type: e, vnode: n, proxy: r, withProxy: o, props: s, propsOptions: [a], slots: c, attrs: l, emit: u, render: h, renderCache: d, data: p, setupState: f, ctx: m} = t;
            let g;
            const v = de(t);
            try {
                let t;
                if (4 & n.shapeFlag) {
                    const e = o || r;
                    g = hi(h.call(e, e, d, s, f, p, m)),
                        t = l
                } else {
                    const n = e;
                    0,
                        g = hi(n.length > 1 ? n(s, {
                            attrs: l,
                            slots: c,
                            emit: u
                        }) : n(s, null)),
                        t = e.props ? l : _e(l)
                }
                let v = g;
                if (!1 !== e.inheritAttrs && t) {
                    const e = Object.keys(t)
                        , {shapeFlag: n} = v;
                    e.length && (1 & n || 6 & n) && (a && e.some(i["s"]) && (t = xe(t, a)),
                        v = ci(v, t))
                }
                n.dirs && (v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs),
                n.transition && (v.transition = n.transition),
                    g = v
            } catch (y) {
                Zn.length = 0,
                    Ot(y, t, 1),
                    g = si(Xn)
            }
            return de(v),
                g
        }
        function ye(t) {
            let e;
            for (let n = 0; n < t.length; n++) {
                const i = t[n];
                if (!ei(i))
                    return;
                if (i.type !== Xn || "v-if" === i.children) {
                    if (e)
                        return;
                    e = i
                }
            }
            return e
        }
        const _e = t=>{
                let e;
                for (const n in t)
                    ("class" === n || "style" === n || Object(i["u"])(n)) && ((e || (e = {}))[n] = t[n]);
                return e
            }
            , xe = (t,e)=>{
                const n = {};
                for (const r in t)
                    Object(i["s"])(r) && r.slice(9)in e || (n[r] = t[r]);
                return n
            }
        ;
        function be(t, e, n) {
            const {props: i, children: r, component: o} = t
                , {props: s, children: a, patchFlag: c} = e
                , l = o.emitsOptions;
            if (e.dirs || e.transition)
                return !0;
            if (!(n && c >= 0))
                return !(!r && !a || a && a.$stable) || i !== s && (i ? !s || we(i, s, l) : !!s);
            if (1024 & c)
                return !0;
            if (16 & c)
                return i ? we(i, s, l) : !!s;
            if (8 & c) {
                const t = e.dynamicProps;
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    if (s[n] !== i[n] && !ae(l, n))
                        return !0
                }
            }
            return !1
        }
        function we(t, e, n) {
            const i = Object.keys(e);
            if (i.length !== Object.keys(t).length)
                return !0;
            for (let r = 0; r < i.length; r++) {
                const o = i[r];
                if (e[o] !== t[o] && !ae(n, o))
                    return !0
            }
            return !1
        }
        function Me({vnode: t, parent: e}, n) {
            while (e && e.subTree === t)
                (t = e.vnode).el = n,
                    e = e.parent
        }
        const Se = t=>t.__isSuspense;
        function Ee(t) {
            const {shapeFlag: e, children: n} = t;
            let i, r;
            return 32 & e ? (i = Te(n.default),
                r = Te(n.fallback)) : (i = Te(n),
                r = hi(null)),
                {
                    content: i,
                    fallback: r
                }
        }
        function Te(t) {
            if (Object(i["n"])(t) && (t = t()),
                Object(i["m"])(t)) {
                const e = ye(t);
                0,
                    t = e
            }
            return hi(t)
        }
        function Ae(t, e) {
            e && e.pendingBranch ? Object(i["m"])(t) ? e.effects.push(...t) : e.effects.push(t) : te(t)
        }
        function Le(t, e, n, r=!1) {
            const o = {}
                , s = {};
            Object(i["g"])(s, ii, 1),
                t.propsDefaults = Object.create(null),
                Ce(t, e, o, s),
                n ? t.props = r ? o : mt(o) : t.type.props ? t.props = o : t.props = s,
                t.attrs = s
        }
        function Re(t, e, n, r) {
            const {props: o, attrs: s, vnode: {patchFlag: a}} = t
                , c = bt(o)
                , [l] = t.propsOptions;
            if (!(r || a > 0) || 16 & a) {
                let r;
                Ce(t, e, o, s);
                for (const s in c)
                    e && (Object(i["j"])(e, s) || (r = Object(i["k"])(s)) !== s && Object(i["j"])(e, r)) || (l ? !n || void 0 === n[s] && void 0 === n[r] || (o[s] = Pe(l, e || i["b"], s, void 0, t)) : delete o[s]);
                if (s !== c)
                    for (const t in s)
                        e && Object(i["j"])(e, t) || delete s[t]
            } else if (8 & a) {
                const n = t.vnode.dynamicProps;
                for (let r = 0; r < n.length; r++) {
                    const a = n[r]
                        , u = e[a];
                    if (l)
                        if (Object(i["j"])(s, a))
                            s[a] = u;
                        else {
                            const e = Object(i["e"])(a);
                            o[e] = Pe(l, c, e, u, t)
                        }
                    else
                        s[a] = u
                }
            }
            b(t, "set", "$attrs")
        }
        function Ce(t, e, n, r) {
            const [o,s] = t.propsOptions;
            if (e)
                for (const a in e) {
                    const s = e[a];
                    if (Object(i["w"])(a))
                        continue;
                    let c;
                    o && Object(i["j"])(o, c = Object(i["e"])(a)) ? n[c] = s : ae(t.emitsOptions, a) || (r[a] = s)
                }
            if (s) {
                const e = bt(n);
                for (let i = 0; i < s.length; i++) {
                    const r = s[i];
                    n[r] = Pe(o, e, r, e[r], t)
                }
            }
        }
        function Pe(t, e, n, r, o) {
            const s = t[n];
            if (null != s) {
                const t = Object(i["j"])(s, "default");
                if (t && void 0 === r) {
                    const t = s.default;
                    if (s.type !== Function && Object(i["n"])(t)) {
                        const {propsDefaults: i} = o;
                        n in i ? r = i[n] : (Fi(o),
                            r = i[n] = t(e),
                            Fi(null))
                    } else
                        r = t
                }
                s[0] && (Object(i["j"])(e, n) || t ? !s[1] || "" !== r && r !== Object(i["k"])(n) || (r = !0) : r = !1)
            }
            return r
        }
        function Oe(t, e, n=!1) {
            if (!e.deopt && t.__props)
                return t.__props;
            const r = t.props
                , o = {}
                , s = [];
            let a = !1;
            if (!Object(i["n"])(t)) {
                const r = t=>{
                        a = !0;
                        const [n,r] = Oe(t, e, !0);
                        Object(i["h"])(o, n),
                        r && s.push(...r)
                    }
                ;
                !n && e.mixins.length && e.mixins.forEach(r),
                t.extends && r(t.extends),
                t.mixins && t.mixins.forEach(r)
            }
            if (!r && !a)
                return t.__props = i["a"];
            if (Object(i["m"])(r))
                for (let c = 0; c < r.length; c++) {
                    0;
                    const t = Object(i["e"])(r[c]);
                    Ie(t) && (o[t] = i["b"])
                }
            else if (r) {
                0;
                for (const t in r) {
                    const e = Object(i["e"])(t);
                    if (Ie(e)) {
                        const n = r[t]
                            , a = o[e] = Object(i["m"])(n) || Object(i["n"])(n) ? {
                            type: n
                        } : n;
                        if (a) {
                            const t = Fe(Boolean, a.type)
                                , n = Fe(String, a.type);
                            a[0] = t > -1,
                                a[1] = n < 0 || t < n,
                            (t > -1 || Object(i["j"])(a, "default")) && s.push(e)
                        }
                    }
                }
            }
            return t.__props = [o, s]
        }
        function Ie(t) {
            return "$" !== t[0]
        }
        function Ne(t) {
            const e = t && t.toString().match(/^\s*function (\w+)/);
            return e ? e[1] : ""
        }
        function De(t, e) {
            return Ne(t) === Ne(e)
        }
        function Fe(t, e) {
            return Object(i["m"])(e) ? e.findIndex(e=>De(e, t)) : Object(i["n"])(e) && De(e, t) ? 0 : -1
        }
        function ke(t, e, n=Ni, i=!1) {
            if (n) {
                const r = n[t] || (n[t] = [])
                    , o = e.__weh || (e.__weh = (...i)=>{
                        if (n.isUnmounted)
                            return;
                        v(),
                            Fi(n);
                        const r = Pt(e, n, t, i);
                        return Fi(null),
                            _(),
                            r
                    }
                );
                return i ? r.unshift(o) : r.push(o),
                    o
            }
        }
        const He = t=>(e,n=Ni)=>!Bi && ke(t, e, n)
            , Be = He("bm")
            , ze = He("m")
            , Ue = He("bu")
            , je = He("u")
            , Ge = He("bum")
            , Ve = He("um")
            , We = He("rtg")
            , qe = He("rtc")
            , Xe = (t,e=Ni)=>{
                ke("ec", t, e)
            }
        ;
        const Ye = {};
        function Ze(t, e, n) {
            return Je(t, e, n)
        }
        function Je(t, e, {immediate: n, deep: r, flush: o, onTrack: s, onTrigger: a}=i["b"], c=Ni) {
            let l, d, p = !1;
            if (wt(t) ? (l = ()=>t.value,
                p = !!t._shallow) : yt(t) ? (l = ()=>t,
                r = !0) : l = Object(i["m"])(t) ? ()=>t.map(t=>wt(t) ? t.value : yt(t) ? Qe(t) : Object(i["n"])(t) ? Ct(t, c, 2, [c && c.proxy]) : void 0) : Object(i["n"])(t) ? e ? ()=>Ct(t, c, 2, [c && c.proxy]) : ()=>{
                    if (!c || !c.isUnmounted)
                        return d && d(),
                            Pt(t, c, 3, [f])
                }
                : i["d"],
            e && r) {
                const t = l;
                l = ()=>Qe(t())
            }
            let f = t=>{
                d = y.options.onStop = ()=>{
                    Ct(t, c, 4)
                }
            }
                , m = Object(i["m"])(t) ? [] : Ye;
            const g = ()=>{
                    if (y.active)
                        if (e) {
                            const t = y();
                            (r || p || Object(i["i"])(t, m)) && (d && d(),
                                Pt(e, c, 3, [t, m === Ye ? void 0 : m, f]),
                                m = t)
                        } else
                            y()
                }
            ;
            let v;
            g.allowRecurse = !!e,
                v = "sync" === o ? g : "post" === o ? ()=>On(g, c && c.suspense) : ()=>{
                    !c || c.isMounted ? $t(g) : g()
                }
            ;
            const y = u(l, {
                lazy: !0,
                onTrack: s,
                onTrigger: a,
                scheduler: v
            });
            return Wi(y, c),
                e ? n ? g() : m = y() : "post" === o ? On(y, c && c.suspense) : y(),
                ()=>{
                    h(y),
                    c && Object(i["H"])(c.effects, y)
                }
        }
        function Ke(t, e, n) {
            const r = this.proxy
                , o = Object(i["A"])(t) ? ()=>r[t] : t.bind(r);
            return Je(o, e.bind(r), n, this)
        }
        function Qe(t, e=new Set) {
            if (!Object(i["t"])(t) || e.has(t))
                return t;
            if (e.add(t),
                wt(t))
                Qe(t.value, e);
            else if (Object(i["m"])(t))
                for (let n = 0; n < t.length; n++)
                    Qe(t[n], e);
            else if (Object(i["y"])(t) || Object(i["r"])(t))
                t.forEach(t=>{
                        Qe(t, e)
                    }
                );
            else
                for (const n in t)
                    Qe(t[n], e);
            return t
        }
        function $e() {
            const t = {
                isMounted: !1,
                isLeaving: !1,
                isUnmounting: !1,
                leavingVNodes: new Map
            };
            return ze(()=>{
                    t.isMounted = !0
                }
            ),
                Ge(()=>{
                        t.isUnmounting = !0
                    }
                ),
                t
        }
        const tn = [Function, Array]
            , en = {
            name: "BaseTransition",
            props: {
                mode: String,
                appear: Boolean,
                persisted: Boolean,
                onBeforeEnter: tn,
                onEnter: tn,
                onAfterEnter: tn,
                onEnterCancelled: tn,
                onBeforeLeave: tn,
                onLeave: tn,
                onAfterLeave: tn,
                onLeaveCancelled: tn,
                onBeforeAppear: tn,
                onAppear: tn,
                onAfterAppear: tn,
                onAppearCancelled: tn
            },
            setup(t, {slots: e}) {
                const n = Di()
                    , i = $e();
                let r;
                return ()=>{
                    const o = e.default && ln(e.default(), !0);
                    if (!o || !o.length)
                        return;
                    const s = bt(t)
                        , {mode: a} = s;
                    const c = o[0];
                    if (i.isLeaving)
                        return sn(c);
                    const l = an(c);
                    if (!l)
                        return sn(c);
                    const u = on(l, s, i, n);
                    cn(l, u);
                    const h = n.subTree
                        , d = h && an(h);
                    let p = !1;
                    const {getTransitionKey: f} = l.type;
                    if (f) {
                        const t = f();
                        void 0 === r ? r = t : t !== r && (r = t,
                            p = !0)
                    }
                    if (d && d.type !== Xn && (!ni(l, d) || p)) {
                        const t = on(d, s, i, n);
                        if (cn(d, t),
                        "out-in" === a)
                            return i.isLeaving = !0,
                                t.afterLeave = ()=>{
                                    i.isLeaving = !1,
                                        n.update()
                                }
                                ,
                                sn(c);
                        "in-out" === a && l.type !== Xn && (t.delayLeave = (t,e,n)=>{
                                const r = rn(i, d);
                                r[String(d.key)] = d,
                                    t._leaveCb = ()=>{
                                        e(),
                                            t._leaveCb = void 0,
                                            delete u.delayedLeave
                                    }
                                    ,
                                    u.delayedLeave = n
                            }
                        )
                    }
                    return c
                }
            }
        }
            , nn = en;
        function rn(t, e) {
            const {leavingVNodes: n} = t;
            let i = n.get(e.type);
            return i || (i = Object.create(null),
                n.set(e.type, i)),
                i
        }
        function on(t, e, n, i) {
            const {appear: r, mode: o, persisted: s=!1, onBeforeEnter: a, onEnter: c, onAfterEnter: l, onEnterCancelled: u, onBeforeLeave: h, onLeave: d, onAfterLeave: p, onLeaveCancelled: f, onBeforeAppear: m, onAppear: g, onAfterAppear: v, onAppearCancelled: y} = e
                , _ = String(t.key)
                , x = rn(n, t)
                , b = (t,e)=>{
                t && Pt(t, i, 9, e)
            }
                , w = {
                mode: o,
                persisted: s,
                beforeEnter(e) {
                    let i = a;
                    if (!n.isMounted) {
                        if (!r)
                            return;
                        i = m || a
                    }
                    e._leaveCb && e._leaveCb(!0);
                    const o = x[_];
                    o && ni(t, o) && o.el._leaveCb && o.el._leaveCb(),
                        b(i, [e])
                },
                enter(t) {
                    let e = c
                        , i = l
                        , o = u;
                    if (!n.isMounted) {
                        if (!r)
                            return;
                        e = g || c,
                            i = v || l,
                            o = y || u
                    }
                    let s = !1;
                    const a = t._enterCb = e=>{
                            s || (s = !0,
                                b(e ? o : i, [t]),
                            w.delayedLeave && w.delayedLeave(),
                                t._enterCb = void 0)
                        }
                    ;
                    e ? (e(t, a),
                    e.length <= 1 && a()) : a()
                },
                leave(e, i) {
                    const r = String(t.key);
                    if (e._enterCb && e._enterCb(!0),
                        n.isUnmounting)
                        return i();
                    b(h, [e]);
                    let o = !1;
                    const s = e._leaveCb = n=>{
                            o || (o = !0,
                                i(),
                                b(n ? f : p, [e]),
                                e._leaveCb = void 0,
                            x[r] === t && delete x[r])
                        }
                    ;
                    x[r] = t,
                        d ? (d(e, s),
                        d.length <= 1 && s()) : s()
                },
                clone(t) {
                    return on(t, e, n, i)
                }
            };
            return w
        }
        function sn(t) {
            if (un(t))
                return t = ci(t),
                    t.children = null,
                    t
        }
        function an(t) {
            return un(t) ? t.children ? t.children[0] : void 0 : t
        }
        function cn(t, e) {
            6 & t.shapeFlag && t.component ? cn(t.component.subTree, e) : 128 & t.shapeFlag ? (t.ssContent.transition = e.clone(t.ssContent),
                t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
        }
        function ln(t, e=!1) {
            let n = []
                , i = 0;
            for (let r = 0; r < t.length; r++) {
                const o = t[r];
                o.type === Wn ? (128 & o.patchFlag && i++,
                    n = n.concat(ln(o.children, e))) : (e || o.type !== Xn) && n.push(o)
            }
            if (i > 1)
                for (let r = 0; r < n.length; r++)
                    n[r].patchFlag = -2;
            return n
        }
        const un = t=>t.type.__isKeepAlive;
        RegExp,
            RegExp;
        function hn(t, e) {
            return Object(i["m"])(t) ? t.some(t=>hn(t, e)) : Object(i["A"])(t) ? t.split(",").indexOf(e) > -1 : !!t.test && t.test(e)
        }
        function dn(t, e) {
            fn(t, "a", e)
        }
        function pn(t, e) {
            fn(t, "da", e)
        }
        function fn(t, e, n=Ni) {
            const i = t.__wdc || (t.__wdc = ()=>{
                    let e = n;
                    while (e) {
                        if (e.isDeactivated)
                            return;
                        e = e.parent
                    }
                    t()
                }
            );
            if (ke(e, i, n),
                n) {
                let t = n.parent;
                while (t && t.parent)
                    un(t.parent.vnode) && mn(i, e, n, t),
                        t = t.parent
            }
        }
        function mn(t, e, n, r) {
            const o = ke(e, t, r, !0);
            Ve(()=>{
                    Object(i["H"])(r[e], o)
                }
                , n)
        }
        function gn(t) {
            let e = t.shapeFlag;
            256 & e && (e -= 256),
            512 & e && (e -= 512),
                t.shapeFlag = e
        }
        function vn(t) {
            return 128 & t.shapeFlag ? t.ssContent : t
        }
        const yn = t=>"_" === t[0] || "$stable" === t
            , _n = t=>Object(i["m"])(t) ? t.map(hi) : [hi(t)]
            , xn = (t,e,n)=>ge(t=>_n(e(t)), n)
            , bn = (t,e)=>{
                const n = t._ctx;
                for (const r in t) {
                    if (yn(r))
                        continue;
                    const o = t[r];
                    if (Object(i["n"])(o))
                        e[r] = xn(r, o, n);
                    else if (null != o) {
                        0;
                        const t = _n(o);
                        e[r] = ()=>t
                    }
                }
            }
            , wn = (t,e)=>{
                const n = _n(e);
                t.slots.default = ()=>n
            }
            , Mn = (t,e)=>{
                if (32 & t.vnode.shapeFlag) {
                    const n = e._;
                    n ? (t.slots = e,
                        Object(i["g"])(e, "_", n)) : bn(e, t.slots = {})
                } else
                    t.slots = {},
                    e && wn(t, e);
                Object(i["g"])(t.slots, ii, 1)
            }
            , Sn = (t,e,n)=>{
                const {vnode: r, slots: o} = t;
                let s = !0
                    , a = i["b"];
                if (32 & r.shapeFlag) {
                    const t = e._;
                    t ? n && 1 === t ? s = !1 : (Object(i["h"])(o, e),
                    n || 1 !== t || delete o._) : (s = !e.$stable,
                        bn(e, o)),
                        a = e
                } else
                    e && (wn(t, e),
                        a = {
                            default: 1
                        });
                if (s)
                    for (const i in o)
                        yn(i) || i in a || delete o[i]
            }
        ;
        function En(t, e, n, i) {
            const r = t.dirs
                , o = e && e.dirs;
            for (let s = 0; s < r.length; s++) {
                const a = r[s];
                o && (a.oldValue = o[s].value);
                const c = a.dir[i];
                c && Pt(c, n, 8, [t.el, a, t, e])
            }
        }
        function Tn() {
            return {
                app: null,
                config: {
                    isNativeTag: i["c"],
                    performance: !1,
                    globalProperties: {},
                    optionMergeStrategies: {},
                    isCustomElement: i["c"],
                    errorHandler: void 0,
                    warnHandler: void 0
                },
                mixins: [],
                components: {},
                directives: {},
                provides: Object.create(null)
            }
        }
        let An = 0;
        function Ln(t, e) {
            return function(n, r=null) {
                null == r || Object(i["t"])(r) || (r = null);
                const o = Tn()
                    , s = new Set;
                let a = !1;
                const c = o.app = {
                    _uid: An++,
                    _component: n,
                    _props: r,
                    _container: null,
                    _context: o,
                    version: Ji,
                    get config() {
                        return o.config
                    },
                    set config(t) {
                        0
                    },
                    use(t, ...e) {
                        return s.has(t) || (t && Object(i["n"])(t.install) ? (s.add(t),
                            t.install(c, ...e)) : Object(i["n"])(t) && (s.add(t),
                            t(c, ...e))),
                            c
                    },
                    mixin(t) {
                        return o.mixins.includes(t) || (o.mixins.push(t),
                        (t.props || t.emits) && (o.deopt = !0)),
                            c
                    },
                    component(t, e) {
                        return e ? (o.components[t] = e,
                            c) : o.components[t]
                    },
                    directive(t, e) {
                        return e ? (o.directives[t] = e,
                            c) : o.directives[t]
                    },
                    mount(i, s, l) {
                        if (!a) {
                            const u = si(n, r);
                            return u.appContext = o,
                                s && e ? e(u, i) : t(u, i, l),
                                a = !0,
                                c._container = i,
                                i.__vue_app__ = c,
                                u.component.proxy
                        }
                    },
                    unmount() {
                        a && (t(null, c._container),
                            delete c._container.__vue_app__)
                    },
                    provide(t, e) {
                        return o.provides[t] = e,
                            c
                    }
                };
                return c
            }
        }
        function Rn() {}
        const Cn = t=>!!t.type.__asyncLoader;
        const Pn = {
            scheduler: Zt,
            allowRecurse: !0
        };
        const On = Ae
            , In = (t,e,n,r)=>{
                if (Object(i["m"])(t))
                    return void t.forEach((t,o)=>In(t, e && (Object(i["m"])(e) ? e[o] : e), n, r));
                let o;
                if (r) {
                    if (Cn(r))
                        return;
                    o = 4 & r.shapeFlag ? r.component.exposed || r.component.proxy : r.el
                } else
                    o = null;
                const {i: s, r: a} = t;
                const c = e && e.r
                    , l = s.refs === i["b"] ? s.refs = {} : s.refs
                    , u = s.setupState;
                if (null != c && c !== a && (Object(i["A"])(c) ? (l[c] = null,
                Object(i["j"])(u, c) && (u[c] = null)) : wt(c) && (c.value = null)),
                    Object(i["A"])(a)) {
                    const t = ()=>{
                            l[a] = o,
                            Object(i["j"])(u, a) && (u[a] = o)
                        }
                    ;
                    o ? (t.id = -1,
                        On(t, n)) : t()
                } else if (wt(a)) {
                    const t = ()=>{
                            a.value = o
                        }
                    ;
                    o ? (t.id = -1,
                        On(t, n)) : t()
                } else
                    Object(i["n"])(a) && Ct(a, s, 12, [o, l])
            }
        ;
        function Nn(t) {
            return Dn(t)
        }
        function Dn(t, e) {
            Rn();
            const {insert: n, remove: r, patchProp: o, forcePatchProp: s, createElement: a, createText: c, createComment: l, setText: d, setElementText: p, parentNode: f, nextSibling: m, setScopeId: g=i["d"], cloneNode: y, insertStaticContent: x} = t
                , b = (t,e,n,i=null,r=null,o=null,s=!1,a=null,c=!1)=>{
                t && !ni(t, e) && (i = Z(t),
                    V(t, r, o, !0),
                    t = null),
                -2 === e.patchFlag && (c = !1,
                    e.dynamicChildren = null);
                const {type: l, ref: u, shapeFlag: h} = e;
                switch (l) {
                    case qn:
                        w(t, e, n, i);
                        break;
                    case Xn:
                        M(t, e, n, i);
                        break;
                    case Yn:
                        null == t && S(e, n, i, s);
                        break;
                    case Wn:
                        N(t, e, n, i, r, o, s, a, c);
                        break;
                    default:
                        1 & h ? A(t, e, n, i, r, o, s, a, c) : 6 & h ? D(t, e, n, i, r, o, s, a, c) : (64 & h || 128 & h) && l.process(t, e, n, i, r, o, s, a, c, K)
                }
                null != u && r && In(u, t && t.ref, o, e)
            }
                , w = (t,e,i,r)=>{
                if (null == t)
                    n(e.el = c(e.children), i, r);
                else {
                    const n = e.el = t.el;
                    e.children !== t.children && d(n, e.children)
                }
            }
                , M = (t,e,i,r)=>{
                null == t ? n(e.el = l(e.children || ""), i, r) : e.el = t.el
            }
                , S = (t,e,n,i)=>{
                [t.el,t.anchor] = x(t.children, e, n, i)
            }
                , E = ({el: t, anchor: e},i,r)=>{
                let o;
                while (t && t !== e)
                    o = m(t),
                        n(t, i, r),
                        t = o;
                n(e, i, r)
            }
                , T = ({el: t, anchor: e})=>{
                let n;
                while (t && t !== e)
                    n = m(t),
                        r(t),
                        t = n;
                r(e)
            }
                , A = (t,e,n,i,r,o,s,a,c)=>{
                s = s || "svg" === e.type,
                    null == t ? L(e, n, i, r, o, s, a, c) : P(t, e, r, o, s, a, c)
            }
                , L = (t,e,r,s,c,l,u,h)=>{
                let d, f;
                const {type: m, props: g, shapeFlag: v, transition: _, patchFlag: x, dirs: b} = t;
                if (t.el && void 0 !== y && -1 === x)
                    d = t.el = y(t.el);
                else {
                    if (d = t.el = a(t.type, l, g && g.is, g),
                        8 & v ? p(d, t.children) : 16 & v && C(t.children, d, null, s, c, l && "foreignObject" !== m, u, h || !!t.dynamicChildren),
                    b && En(t, null, s, "created"),
                        g) {
                        for (const e in g)
                            Object(i["w"])(e) || o(d, e, null, g[e], l, t.children, s, c, Y);
                        (f = g.onVnodeBeforeMount) && Fn(f, s, t)
                    }
                    R(d, t, t.scopeId, u, s)
                }
                b && En(t, null, s, "beforeMount");
                const w = (!c || c && !c.pendingBranch) && _ && !_.persisted;
                w && _.beforeEnter(d),
                    n(d, e, r),
                ((f = g && g.onVnodeMounted) || w || b) && On(()=>{
                        f && Fn(f, s, t),
                        w && _.enter(d),
                        b && En(t, null, s, "mounted")
                    }
                    , c)
            }
                , R = (t,e,n,i,r)=>{
                if (n && g(t, n),
                    i)
                    for (let o = 0; o < i.length; o++)
                        g(t, i[o]);
                if (r) {
                    let n = r.subTree;
                    if (e === n) {
                        const e = r.vnode;
                        R(t, e, e.scopeId, e.slotScopeIds, r.parent)
                    }
                }
            }
                , C = (t,e,n,i,r,o,s,a,c=0)=>{
                for (let l = c; l < t.length; l++) {
                    const c = t[l] = s ? di(t[l]) : hi(t[l]);
                    b(null, c, e, n, i, r, o, s, a)
                }
            }
                , P = (t,e,n,r,a,c,l)=>{
                const u = e.el = t.el;
                let {patchFlag: h, dynamicChildren: d, dirs: f} = e;
                h |= 16 & t.patchFlag;
                const m = t.props || i["b"]
                    , g = e.props || i["b"];
                let v;
                if ((v = g.onVnodeBeforeUpdate) && Fn(v, n, e, t),
                f && En(e, t, n, "beforeUpdate"),
                h > 0) {
                    if (16 & h)
                        I(u, e, m, g, n, r, a);
                    else if (2 & h && m.class !== g.class && o(u, "class", null, g.class, a),
                    4 & h && o(u, "style", m.style, g.style, a),
                    8 & h) {
                        const i = e.dynamicProps;
                        for (let e = 0; e < i.length; e++) {
                            const c = i[e]
                                , l = m[c]
                                , h = g[c];
                            (h !== l || s && s(u, c)) && o(u, c, l, h, a, t.children, n, r, Y)
                        }
                    }
                    1 & h && t.children !== e.children && p(u, e.children)
                } else
                    l || null != d || I(u, e, m, g, n, r, a);
                const y = a && "foreignObject" !== e.type;
                d ? O(t.dynamicChildren, d, u, n, r, y, c) : l || z(t, e, u, null, n, r, y, c, !1),
                ((v = g.onVnodeUpdated) || f) && On(()=>{
                        v && Fn(v, n, e, t),
                        f && En(e, t, n, "updated")
                    }
                    , r)
            }
                , O = (t,e,n,i,r,o,s)=>{
                for (let a = 0; a < e.length; a++) {
                    const c = t[a]
                        , l = e[a]
                        , u = c.type === Wn || !ni(c, l) || 6 & c.shapeFlag || 64 & c.shapeFlag ? f(c.el) : n;
                    b(c, l, u, null, i, r, o, s, !0)
                }
            }
                , I = (t,e,n,r,a,c,l)=>{
                if (n !== r) {
                    for (const u in r) {
                        if (Object(i["w"])(u))
                            continue;
                        const h = r[u]
                            , d = n[u];
                        (h !== d || s && s(t, u)) && o(t, u, d, h, l, e.children, a, c, Y)
                    }
                    if (n !== i["b"])
                        for (const s in n)
                            Object(i["w"])(s) || s in r || o(t, s, n[s], null, l, e.children, a, c, Y)
                }
            }
                , N = (t,e,i,r,o,s,a,l,u)=>{
                const h = e.el = t ? t.el : c("")
                    , d = e.anchor = t ? t.anchor : c("");
                let {patchFlag: p, dynamicChildren: f, slotScopeIds: m} = e;
                p > 0 && (u = !0),
                m && (l = l ? l.concat(m) : m),
                    null == t ? (n(h, i, r),
                        n(d, i, r),
                        C(e.children, i, d, o, s, a, l, u)) : p > 0 && 64 & p && f && t.dynamicChildren ? (O(t.dynamicChildren, f, i, o, s, a, l),
                    (null != e.key || o && e === o.subTree) && kn(t, e, !0)) : z(t, e, i, d, o, s, a, l, u)
            }
                , D = (t,e,n,i,r,o,s,a,c)=>{
                e.slotScopeIds = a,
                    null == t ? 512 & e.shapeFlag ? r.ctx.activate(e, n, i, s, c) : F(e, n, i, r, o, s, c) : k(t, e, c)
            }
                , F = (t,e,n,i,r,o,s)=>{
                const a = t.component = Ii(t, i, r);
                if (un(t) && (a.ctx.renderer = K),
                    zi(a),
                    a.asyncDep) {
                    if (r && r.registerDep(a, H),
                        !t.el) {
                        const t = a.subTree = si(Xn);
                        M(null, t, e, n)
                    }
                } else
                    H(a, t, e, n, r, o, s)
            }
                , k = (t,e,n)=>{
                const i = e.component = t.component;
                if (be(t, e, n)) {
                    if (i.asyncDep && !i.asyncResolved)
                        return void B(i, e, n);
                    i.next = e,
                        Kt(i.update),
                        i.update()
                } else
                    e.component = t.component,
                        e.el = t.el,
                        i.vnode = e
            }
                , H = (t,e,n,r,o,s,a)=>{
                t.update = u((function() {
                        if (t.isMounted) {
                            let e, {next: n, bu: r, u: c, parent: l, vnode: u} = t, h = n;
                            0,
                                n ? (n.el = u.el,
                                    B(t, n, a)) : n = u,
                            r && Object(i["l"])(r),
                            (e = n.props && n.props.onVnodeBeforeUpdate) && Fn(e, l, n, u);
                            const d = ve(t);
                            0;
                            const p = t.subTree;
                            t.subTree = d,
                                b(p, d, f(p.el), Z(p), t, o, s),
                                n.el = d.el,
                            null === h && Me(t, d.el),
                            c && On(c, o),
                            (e = n.props && n.props.onVnodeUpdated) && On(()=>{
                                    Fn(e, l, n, u)
                                }
                                , o)
                        } else {
                            let a;
                            const {el: c, props: l} = e
                                , {bm: u, m: h, parent: d} = t;
                            u && Object(i["l"])(u),
                            (a = l && l.onVnodeBeforeMount) && Fn(a, d, e);
                            const p = t.subTree = ve(t);
                            if (c && $ ? $(e.el, p, t, o, null) : (b(null, p, n, r, t, o, s),
                                e.el = p.el),
                            h && On(h, o),
                                a = l && l.onVnodeMounted) {
                                const t = e;
                                On(()=>{
                                        Fn(a, d, t)
                                    }
                                    , o)
                            }
                            const {a: f} = t;
                            f && 256 & e.shapeFlag && On(f, o),
                                t.isMounted = !0,
                                e = n = r = null
                        }
                    }
                ), Pn)
            }
                , B = (t,e,n)=>{
                e.component = t;
                const i = t.vnode.props;
                t.vnode = e,
                    t.next = null,
                    Re(t, e.props, i, n),
                    Sn(t, e.children, n),
                    v(),
                    ee(void 0, t.update),
                    _()
            }
                , z = (t,e,n,i,r,o,s,a,c=!1)=>{
                const l = t && t.children
                    , u = t ? t.shapeFlag : 0
                    , h = e.children
                    , {patchFlag: d, shapeFlag: f} = e;
                if (d > 0) {
                    if (128 & d)
                        return void j(l, h, n, i, r, o, s, a, c);
                    if (256 & d)
                        return void U(l, h, n, i, r, o, s, a, c)
                }
                8 & f ? (16 & u && Y(l, r, o),
                h !== l && p(n, h)) : 16 & u ? 16 & f ? j(l, h, n, i, r, o, s, a, c) : Y(l, r, o, !0) : (8 & u && p(n, ""),
                16 & f && C(h, n, i, r, o, s, a, c))
            }
                , U = (t,e,n,r,o,s,a,c,l)=>{
                t = t || i["a"],
                    e = e || i["a"];
                const u = t.length
                    , h = e.length
                    , d = Math.min(u, h);
                let p;
                for (p = 0; p < d; p++) {
                    const i = e[p] = l ? di(e[p]) : hi(e[p]);
                    b(t[p], i, n, null, o, s, a, c, l)
                }
                u > h ? Y(t, o, s, !0, !1, d) : C(e, n, r, o, s, a, c, l, d)
            }
                , j = (t,e,n,r,o,s,a,c,l)=>{
                let u = 0;
                const h = e.length;
                let d = t.length - 1
                    , p = h - 1;
                while (u <= d && u <= p) {
                    const i = t[u]
                        , r = e[u] = l ? di(e[u]) : hi(e[u]);
                    if (!ni(i, r))
                        break;
                    b(i, r, n, null, o, s, a, c, l),
                        u++
                }
                while (u <= d && u <= p) {
                    const i = t[d]
                        , r = e[p] = l ? di(e[p]) : hi(e[p]);
                    if (!ni(i, r))
                        break;
                    b(i, r, n, null, o, s, a, c, l),
                        d--,
                        p--
                }
                if (u > d) {
                    if (u <= p) {
                        const t = p + 1
                            , i = t < h ? e[t].el : r;
                        while (u <= p)
                            b(null, e[u] = l ? di(e[u]) : hi(e[u]), n, i, o, s, a, c, l),
                                u++
                    }
                } else if (u > p)
                    while (u <= d)
                        V(t[u], o, s, !0),
                            u++;
                else {
                    const f = u
                        , m = u
                        , g = new Map;
                    for (u = m; u <= p; u++) {
                        const t = e[u] = l ? di(e[u]) : hi(e[u]);
                        null != t.key && g.set(t.key, u)
                    }
                    let v, y = 0;
                    const _ = p - m + 1;
                    let x = !1
                        , w = 0;
                    const M = new Array(_);
                    for (u = 0; u < _; u++)
                        M[u] = 0;
                    for (u = f; u <= d; u++) {
                        const i = t[u];
                        if (y >= _) {
                            V(i, o, s, !0);
                            continue
                        }
                        let r;
                        if (null != i.key)
                            r = g.get(i.key);
                        else
                            for (v = m; v <= p; v++)
                                if (0 === M[v - m] && ni(i, e[v])) {
                                    r = v;
                                    break
                                }
                        void 0 === r ? V(i, o, s, !0) : (M[r - m] = u + 1,
                            r >= w ? w = r : x = !0,
                            b(i, e[r], n, null, o, s, a, c, l),
                            y++)
                    }
                    const S = x ? Hn(M) : i["a"];
                    for (v = S.length - 1,
                             u = _ - 1; u >= 0; u--) {
                        const t = m + u
                            , i = e[t]
                            , d = t + 1 < h ? e[t + 1].el : r;
                        0 === M[u] ? b(null, i, n, d, o, s, a, c, l) : x && (v < 0 || u !== S[v] ? G(i, n, d, 2) : v--)
                    }
                }
            }
                , G = (t,e,i,r,o=null)=>{
                const {el: s, type: a, transition: c, children: l, shapeFlag: u} = t;
                if (6 & u)
                    return void G(t.component.subTree, e, i, r);
                if (128 & u)
                    return void t.suspense.move(e, i, r);
                if (64 & u)
                    return void a.move(t, e, i, K);
                if (a === Wn) {
                    n(s, e, i);
                    for (let t = 0; t < l.length; t++)
                        G(l[t], e, i, r);
                    return void n(t.anchor, e, i)
                }
                if (a === Yn)
                    return void E(t, e, i);
                const h = 2 !== r && 1 & u && c;
                if (h)
                    if (0 === r)
                        c.beforeEnter(s),
                            n(s, e, i),
                            On(()=>c.enter(s), o);
                    else {
                        const {leave: t, delayLeave: r, afterLeave: o} = c
                            , a = ()=>n(s, e, i)
                            , l = ()=>{
                                t(s, ()=>{
                                        a(),
                                        o && o()
                                    }
                                )
                            }
                        ;
                        r ? r(s, a, l) : l()
                    }
                else
                    n(s, e, i)
            }
                , V = (t,e,n,i=!1,r=!1)=>{
                const {type: o, props: s, ref: a, children: c, dynamicChildren: l, shapeFlag: u, patchFlag: h, dirs: d} = t;
                if (null != a && In(a, null, n, null),
                256 & u)
                    return void e.ctx.deactivate(t);
                const p = 1 & u && d;
                let f;
                if ((f = s && s.onVnodeBeforeUnmount) && Fn(f, e, t),
                6 & u)
                    X(t.component, n, i);
                else {
                    if (128 & u)
                        return void t.suspense.unmount(n, i);
                    p && En(t, null, e, "beforeUnmount"),
                        64 & u ? t.type.remove(t, e, n, r, K, i) : l && (o !== Wn || h > 0 && 64 & h) ? Y(l, e, n, !1, !0) : (o === Wn && (128 & h || 256 & h) || !r && 16 & u) && Y(c, e, n),
                    i && W(t)
                }
                ((f = s && s.onVnodeUnmounted) || p) && On(()=>{
                        f && Fn(f, e, t),
                        p && En(t, null, e, "unmounted")
                    }
                    , n)
            }
                , W = t=>{
                const {type: e, el: n, anchor: i, transition: o} = t;
                if (e === Wn)
                    return void q(n, i);
                if (e === Yn)
                    return void T(t);
                const s = ()=>{
                        r(n),
                        o && !o.persisted && o.afterLeave && o.afterLeave()
                    }
                ;
                if (1 & t.shapeFlag && o && !o.persisted) {
                    const {leave: e, delayLeave: i} = o
                        , r = ()=>e(n, s);
                    i ? i(t.el, s, r) : r()
                } else
                    s()
            }
                , q = (t,e)=>{
                let n;
                while (t !== e)
                    n = m(t),
                        r(t),
                        t = n;
                r(e)
            }
                , X = (t,e,n)=>{
                const {bum: r, effects: o, update: s, subTree: a, um: c} = t;
                if (r && Object(i["l"])(r),
                    o)
                    for (let i = 0; i < o.length; i++)
                        h(o[i]);
                s && (h(s),
                    V(a, t, e, n)),
                c && On(c, e),
                    On(()=>{
                            t.isUnmounted = !0
                        }
                        , e),
                e && e.pendingBranch && !e.isUnmounted && t.asyncDep && !t.asyncResolved && t.suspenseId === e.pendingId && (e.deps--,
                0 === e.deps && e.resolve())
            }
                , Y = (t,e,n,i=!1,r=!1,o=0)=>{
                for (let s = o; s < t.length; s++)
                    V(t[s], e, n, i, r)
            }
                , Z = t=>6 & t.shapeFlag ? Z(t.component.subTree) : 128 & t.shapeFlag ? t.suspense.next() : m(t.anchor || t.el)
                , J = (t,e,n)=>{
                null == t ? e._vnode && V(e._vnode, null, null, !0) : b(e._vnode || null, t, e, null, null, null, n),
                    ne(),
                    e._vnode = t
            }
                , K = {
                p: b,
                um: V,
                m: G,
                r: W,
                mt: F,
                mc: C,
                pc: z,
                pbc: O,
                n: Z,
                o: t
            };
            let Q, $;
            return e && ([Q,$] = e(K)),
                {
                    render: J,
                    hydrate: Q,
                    createApp: Ln(J, Q)
                }
        }
        function Fn(t, e, n, i=null) {
            Pt(t, e, 7, [n, i])
        }
        function kn(t, e, n=!1) {
            const r = t.children
                , o = e.children;
            if (Object(i["m"])(r) && Object(i["m"])(o))
                for (let i = 0; i < r.length; i++) {
                    const t = r[i];
                    let e = o[i];
                    1 & e.shapeFlag && !e.dynamicChildren && ((e.patchFlag <= 0 || 32 === e.patchFlag) && (e = o[i] = di(o[i]),
                        e.el = t.el),
                    n || kn(t, e))
                }
        }
        function Hn(t) {
            const e = t.slice()
                , n = [0];
            let i, r, o, s, a;
            const c = t.length;
            for (i = 0; i < c; i++) {
                const c = t[i];
                if (0 !== c) {
                    if (r = n[n.length - 1],
                    t[r] < c) {
                        e[i] = r,
                            n.push(i);
                        continue
                    }
                    o = 0,
                        s = n.length - 1;
                    while (o < s)
                        a = (o + s) / 2 | 0,
                            t[n[a]] < c ? o = a + 1 : s = a;
                    c < t[n[o]] && (o > 0 && (e[i] = n[o - 1]),
                        n[o] = i)
                }
            }
            o = n.length,
                s = n[o - 1];
            while (o-- > 0)
                n[o] = s,
                    s = e[s];
            return n
        }
        const Bn = t=>t.__isTeleport;
        const zn = "components";
        function Un(t, e) {
            return Gn(zn, t, !0, e) || t
        }
        const jn = Symbol();
        function Gn(t, e, n=!0, r=!1) {
            const o = ue || Ni;
            if (o) {
                const n = o.type;
                if (t === zn) {
                    const t = qi(n);
                    if (t && (t === e || t === Object(i["e"])(e) || t === Object(i["f"])(Object(i["e"])(e))))
                        return n
                }
                const s = Vn(o[t] || n[t], e) || Vn(o.appContext[t], e);
                return !s && r ? n : s
            }
        }
        function Vn(t, e) {
            return t && (t[e] || t[Object(i["e"])(e)] || t[Object(i["f"])(Object(i["e"])(e))])
        }
        const Wn = Symbol(void 0)
            , qn = Symbol(void 0)
            , Xn = Symbol(void 0)
            , Yn = Symbol(void 0)
            , Zn = [];
        let Jn = null;
        function Kn(t=!1) {
            Zn.push(Jn = t ? null : [])
        }
        function Qn() {
            Zn.pop(),
                Jn = Zn[Zn.length - 1] || null
        }
        let $n = 1;
        function ti(t, e, n, r, o) {
            const s = si(t, e, n, r, o, !0);
            return s.dynamicChildren = Jn || i["a"],
                Qn(),
            $n > 0 && Jn && Jn.push(s),
                s
        }
        function ei(t) {
            return !!t && !0 === t.__v_isVNode
        }
        function ni(t, e) {
            return t.type === e.type && t.key === e.key
        }
        const ii = "__vInternal"
            , ri = ({key: t})=>null != t ? t : null
            , oi = ({ref: t})=>null != t ? Object(i["A"])(t) || wt(t) || Object(i["n"])(t) ? {
            i: ue,
            r: t
        } : t : null
            , si = ai;
        function ai(t, e=null, n=null, r=0, o=null, s=!1) {
            if (t && t !== jn || (t = Xn),
                ei(t)) {
                const i = ci(t, e, !0);
                return n && pi(i, n),
                    i
            }
            if (Xi(t) && (t = t.__vccOpts),
                e) {
                (xt(e) || ii in e) && (e = Object(i["h"])({}, e));
                let {class: t, style: n} = e;
                t && !Object(i["A"])(t) && (e.class = Object(i["F"])(t)),
                Object(i["t"])(n) && (xt(n) && !Object(i["m"])(n) && (n = Object(i["h"])({}, n)),
                    e.style = Object(i["G"])(n))
            }
            const a = Object(i["A"])(t) ? 1 : Se(t) ? 128 : Bn(t) ? 64 : Object(i["t"])(t) ? 4 : Object(i["n"])(t) ? 2 : 0;
            const c = {
                __v_isVNode: !0,
                ["__v_skip"]: !0,
                type: t,
                props: e,
                key: e && ri(e),
                ref: e && oi(e),
                scopeId: he,
                slotScopeIds: null,
                children: null,
                component: null,
                suspense: null,
                ssContent: null,
                ssFallback: null,
                dirs: null,
                transition: null,
                el: null,
                anchor: null,
                target: null,
                targetAnchor: null,
                staticCount: 0,
                shapeFlag: a,
                patchFlag: r,
                dynamicProps: o,
                dynamicChildren: null,
                appContext: null
            };
            if (pi(c, n),
            128 & a) {
                const {content: t, fallback: e} = Ee(c);
                c.ssContent = t,
                    c.ssFallback = e
            }
            return $n > 0 && !s && Jn && (r > 0 || 6 & a) && 32 !== r && Jn.push(c),
                c
        }
        function ci(t, e, n=!1) {
            const {props: r, ref: o, patchFlag: s, children: a} = t
                , c = e ? fi(r || {}, e) : r;
            return {
                __v_isVNode: !0,
                ["__v_skip"]: !0,
                type: t.type,
                props: c,
                key: c && ri(c),
                ref: e && e.ref ? n && o ? Object(i["m"])(o) ? o.concat(oi(e)) : [o, oi(e)] : oi(e) : o,
                scopeId: t.scopeId,
                slotScopeIds: t.slotScopeIds,
                children: a,
                target: t.target,
                targetAnchor: t.targetAnchor,
                staticCount: t.staticCount,
                shapeFlag: t.shapeFlag,
                patchFlag: e && t.type !== Wn ? -1 === s ? 16 : 16 | s : s,
                dynamicProps: t.dynamicProps,
                dynamicChildren: t.dynamicChildren,
                appContext: t.appContext,
                dirs: t.dirs,
                transition: t.transition,
                component: t.component,
                suspense: t.suspense,
                ssContent: t.ssContent && ci(t.ssContent),
                ssFallback: t.ssFallback && ci(t.ssFallback),
                el: t.el,
                anchor: t.anchor
            }
        }
        function li(t=" ", e=0) {
            return si(qn, null, t, e)
        }
        function ui(t="", e=!1) {
            return e ? (Kn(),
                ti(Xn, null, t)) : si(Xn, null, t)
        }
        function hi(t) {
            return null == t || "boolean" === typeof t ? si(Xn) : Object(i["m"])(t) ? si(Wn, null, t) : "object" === typeof t ? null === t.el ? t : ci(t) : si(qn, null, String(t))
        }
        function di(t) {
            return null === t.el ? t : ci(t)
        }
        function pi(t, e) {
            let n = 0;
            const {shapeFlag: r} = t;
            if (null == e)
                e = null;
            else if (Object(i["m"])(e))
                n = 16;
            else if ("object" === typeof e) {
                if (1 & r || 64 & r) {
                    const n = e.default;
                    return void (n && (n._c && le(1),
                        pi(t, n()),
                    n._c && le(-1)))
                }
                {
                    n = 32;
                    const i = e._;
                    i || ii in e ? 3 === i && ue && (1024 & ue.vnode.patchFlag ? (e._ = 2,
                        t.patchFlag |= 1024) : e._ = 1) : e._ctx = ue
                }
            } else
                Object(i["n"])(e) ? (e = {
                    default: e,
                    _ctx: ue
                },
                    n = 32) : (e = String(e),
                    64 & r ? (n = 16,
                        e = [li(e)]) : n = 8);
            t.children = e,
                t.shapeFlag |= n
        }
        function fi(...t) {
            const e = Object(i["h"])({}, t[0]);
            for (let n = 1; n < t.length; n++) {
                const r = t[n];
                for (const t in r)
                    if ("class" === t)
                        e.class !== r.class && (e.class = Object(i["F"])([e.class, r.class]));
                    else if ("style" === t)
                        e.style = Object(i["G"])([e.style, r.style]);
                    else if (Object(i["u"])(t)) {
                        const n = e[t]
                            , i = r[t];
                        n !== i && (e[t] = n ? [].concat(n, r[t]) : i)
                    } else
                        "" !== t && (e[t] = r[t])
            }
            return e
        }
        function mi(t, e) {
            if (Ni) {
                let n = Ni.provides;
                const i = Ni.parent && Ni.parent.provides;
                i === n && (n = Ni.provides = Object.create(i)),
                    n[t] = e
            } else
                0
        }
        function gi(t, e, n=!1) {
            const r = Ni || ue;
            if (r) {
                const o = null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
                if (o && t in o)
                    return o[t];
                if (arguments.length > 1)
                    return n && Object(i["n"])(e) ? e() : e
            } else
                0
        }
        let vi = !0;
        function yi(t, e, n=[], r=[], o=[], s=!1) {
            const {mixins: a, extends: c, data: l, computed: u, methods: h, watch: d, provide: p, inject: f, components: m, directives: g, beforeMount: v, mounted: y, beforeUpdate: _, updated: x, activated: b, deactivated: w, beforeDestroy: M, beforeUnmount: S, destroyed: E, unmounted: T, render: A, renderTracked: L, renderTriggered: R, errorCaptured: C, expose: P} = e
                , O = t.proxy
                , I = t.ctx
                , N = t.appContext.mixins;
            s && A && t.render === i["d"] && (t.render = A),
            s || (vi = !1,
                _i("beforeCreate", "bc", e, t, N),
                vi = !0,
                bi(t, N, n, r, o)),
            c && yi(t, c, n, r, o, !0),
            a && bi(t, a, n, r, o);
            if (f)
                if (Object(i["m"])(f))
                    for (let i = 0; i < f.length; i++) {
                        const t = f[i];
                        I[t] = gi(t)
                    }
                else
                    for (const D in f) {
                        const t = f[D];
                        Object(i["t"])(t) ? I[D] = gi(t.from || D, t.default, !0) : I[D] = gi(t)
                    }
            if (h)
                for (const D in h) {
                    const t = h[D];
                    Object(i["n"])(t) && (I[D] = t.bind(O))
                }
            if (s ? l && n.push(l) : (n.length && n.forEach(e=>wi(t, e, O)),
            l && wi(t, l, O)),
                u)
                for (const D in u) {
                    const t = u[D]
                        , e = Object(i["n"])(t) ? t.bind(O, O) : Object(i["n"])(t.get) ? t.get.bind(O, O) : i["d"];
                    0;
                    const n = !Object(i["n"])(t) && Object(i["n"])(t.set) ? t.set.bind(O) : i["d"]
                        , r = Yi({
                        get: e,
                        set: n
                    });
                    Object.defineProperty(I, D, {
                        enumerable: !0,
                        configurable: !0,
                        get: ()=>r.value,
                        set: t=>r.value = t
                    })
                }
            if (d && r.push(d),
            !s && r.length && r.forEach(t=>{
                    for (const e in t)
                        Mi(t[e], I, O, e)
                }
            ),
            p && o.push(p),
            !s && o.length && o.forEach(t=>{
                    const e = Object(i["n"])(t) ? t.call(O) : t;
                    Reflect.ownKeys(e).forEach(t=>{
                            mi(t, e[t])
                        }
                    )
                }
            ),
            s && (m && Object(i["h"])(t.components || (t.components = Object(i["h"])({}, t.type.components)), m),
            g && Object(i["h"])(t.directives || (t.directives = Object(i["h"])({}, t.type.directives)), g)),
            s || _i("created", "c", e, t, N),
            v && Be(v.bind(O)),
            y && ze(y.bind(O)),
            _ && Ue(_.bind(O)),
            x && je(x.bind(O)),
            b && dn(b.bind(O)),
            w && pn(w.bind(O)),
            C && Xe(C.bind(O)),
            L && qe(L.bind(O)),
            R && We(R.bind(O)),
            S && Ge(S.bind(O)),
            T && Ve(T.bind(O)),
                Object(i["m"])(P))
                if (s)
                    0;
                else if (P.length) {
                    const e = t.exposed || (t.exposed = Et({}));
                    P.forEach(t=>{
                            e[t] = At(O, t)
                        }
                    )
                } else
                    t.exposed || (t.exposed = i["b"])
        }
        function _i(t, e, n, i, r) {
            for (let o = 0; o < r.length; o++)
                xi(t, e, r[o], i);
            xi(t, e, n, i)
        }
        function xi(t, e, n, i) {
            const {extends: r, mixins: o} = n
                , s = n[t];
            if (r && xi(t, e, r, i),
                o)
                for (let a = 0; a < o.length; a++)
                    xi(t, e, o[a], i);
            s && Pt(s.bind(i.proxy), i, e)
        }
        function bi(t, e, n, i, r) {
            for (let o = 0; o < e.length; o++)
                yi(t, e[o], n, i, r, !0)
        }
        function wi(t, e, n) {
            vi = !1;
            const r = e.call(n, n);
            vi = !0,
            Object(i["t"])(r) && (t.data === i["b"] ? t.data = ft(r) : Object(i["h"])(t.data, r))
        }
        function Mi(t, e, n, r) {
            const o = r.includes(".") ? Si(n, r) : ()=>n[r];
            if (Object(i["A"])(t)) {
                const n = e[t];
                Object(i["n"])(n) && Ze(o, n)
            } else if (Object(i["n"])(t))
                Ze(o, t.bind(n));
            else if (Object(i["t"])(t))
                if (Object(i["m"])(t))
                    t.forEach(t=>Mi(t, e, n, r));
                else {
                    const r = Object(i["n"])(t.handler) ? t.handler.bind(n) : e[t.handler];
                    Object(i["n"])(r) && Ze(o, r, t)
                }
            else
                0
        }
        function Si(t, e) {
            const n = e.split(".");
            return ()=>{
                let e = t;
                for (let t = 0; t < n.length && e; t++)
                    e = e[n[t]];
                return e
            }
        }
        function Ei(t) {
            const e = t.type
                , {__merged: n, mixins: i, extends: r} = e;
            if (n)
                return n;
            const o = t.appContext.mixins;
            if (!o.length && !i && !r)
                return e;
            const s = {};
            return o.forEach(e=>Ti(s, e, t)),
                Ti(s, e, t),
                e.__merged = s
        }
        function Ti(t, e, n) {
            const r = n.appContext.config.optionMergeStrategies
                , {mixins: o, extends: s} = e;
            s && Ti(t, s, n),
            o && o.forEach(e=>Ti(t, e, n));
            for (const a in e)
                r && Object(i["j"])(r, a) ? t[a] = r[a](t[a], e[a], n.proxy, a) : t[a] = e[a]
        }
        const Ai = t=>t ? ki(t) ? t.exposed ? t.exposed : t.proxy : Ai(t.parent) : null
            , Li = Object(i["h"])(Object.create(null), {
            $: t=>t,
            $el: t=>t.vnode.el,
            $data: t=>t.data,
            $props: t=>t.props,
            $attrs: t=>t.attrs,
            $slots: t=>t.slots,
            $refs: t=>t.refs,
            $parent: t=>Ai(t.parent),
            $root: t=>Ai(t.root),
            $emit: t=>t.emit,
            $options: t=>Ei(t),
            $forceUpdate: t=>()=>Zt(t.update),
            $nextTick: t=>Xt.bind(t.proxy),
            $watch: t=>Ke.bind(t)
        })
            , Ri = {
            get({_: t}, e) {
                const {ctx: n, setupState: r, data: o, props: s, accessCache: a, type: c, appContext: l} = t;
                if ("__v_skip" === e)
                    return !0;
                let u;
                if ("$" !== e[0]) {
                    const c = a[e];
                    if (void 0 !== c)
                        switch (c) {
                            case 0:
                                return r[e];
                            case 1:
                                return o[e];
                            case 3:
                                return n[e];
                            case 2:
                                return s[e]
                        }
                    else {
                        if (r !== i["b"] && Object(i["j"])(r, e))
                            return a[e] = 0,
                                r[e];
                        if (o !== i["b"] && Object(i["j"])(o, e))
                            return a[e] = 1,
                                o[e];
                        if ((u = t.propsOptions[0]) && Object(i["j"])(u, e))
                            return a[e] = 2,
                                s[e];
                        if (n !== i["b"] && Object(i["j"])(n, e))
                            return a[e] = 3,
                                n[e];
                        vi && (a[e] = 4)
                    }
                }
                const h = Li[e];
                let d, p;
                return h ? ("$attrs" === e && x(t, "get", e),
                    h(t)) : (d = c.__cssModules) && (d = d[e]) ? d : n !== i["b"] && Object(i["j"])(n, e) ? (a[e] = 3,
                    n[e]) : (p = l.config.globalProperties,
                    Object(i["j"])(p, e) ? p[e] : void 0)
            },
            set({_: t}, e, n) {
                const {data: r, setupState: o, ctx: s} = t;
                if (o !== i["b"] && Object(i["j"])(o, e))
                    o[e] = n;
                else if (r !== i["b"] && Object(i["j"])(r, e))
                    r[e] = n;
                else if (Object(i["j"])(t.props, e))
                    return !1;
                return ("$" !== e[0] || !(e.slice(1)in t)) && (s[e] = n,
                    !0)
            },
            has({_: {data: t, setupState: e, accessCache: n, ctx: r, appContext: o, propsOptions: s}}, a) {
                let c;
                return void 0 !== n[a] || t !== i["b"] && Object(i["j"])(t, a) || e !== i["b"] && Object(i["j"])(e, a) || (c = s[0]) && Object(i["j"])(c, a) || Object(i["j"])(r, a) || Object(i["j"])(Li, a) || Object(i["j"])(o.config.globalProperties, a)
            }
        };
        const Ci = Object(i["h"])({}, Ri, {
            get(t, e) {
                if (e !== Symbol.unscopables)
                    return Ri.get(t, e, t)
            },
            has(t, e) {
                const n = "_" !== e[0] && !Object(i["o"])(e);
                return n
            }
        });
        const Pi = Tn();
        let Oi = 0;
        function Ii(t, e, n) {
            const r = t.type
                , o = (e ? e.appContext : t.appContext) || Pi
                , s = {
                uid: Oi++,
                vnode: t,
                type: r,
                parent: e,
                appContext: o,
                root: null,
                next: null,
                subTree: null,
                update: null,
                render: null,
                proxy: null,
                exposed: null,
                withProxy: null,
                effects: null,
                provides: e ? e.provides : Object.create(o.provides),
                accessCache: null,
                renderCache: [],
                components: null,
                directives: null,
                propsOptions: Oe(r, o),
                emitsOptions: se(r, o),
                emit: null,
                emitted: null,
                propsDefaults: i["b"],
                ctx: i["b"],
                data: i["b"],
                props: i["b"],
                attrs: i["b"],
                slots: i["b"],
                refs: i["b"],
                setupState: i["b"],
                setupContext: null,
                suspense: n,
                suspenseId: n ? n.pendingId : 0,
                asyncDep: null,
                asyncResolved: !1,
                isMounted: !1,
                isUnmounted: !1,
                isDeactivated: !1,
                bc: null,
                c: null,
                bm: null,
                m: null,
                bu: null,
                u: null,
                um: null,
                bum: null,
                da: null,
                a: null,
                rtg: null,
                rtc: null,
                ec: null
            };
            return s.ctx = {
                _: s
            },
                s.root = e ? e.root : s,
                s.emit = oe.bind(null, s),
                s
        }
        let Ni = null;
        const Di = ()=>Ni || ue
            , Fi = t=>{
                Ni = t
            }
        ;
        function ki(t) {
            return 4 & t.vnode.shapeFlag
        }
        let Hi, Bi = !1;
        function zi(t, e=!1) {
            Bi = e;
            const {props: n, children: i} = t.vnode
                , r = ki(t);
            Le(t, n, r, e),
                Mn(t, i);
            const o = r ? Ui(t, e) : void 0;
            return Bi = !1,
                o
        }
        function Ui(t, e) {
            const n = t.type;
            t.accessCache = Object.create(null),
                t.proxy = new Proxy(t.ctx,Ri);
            const {setup: r} = n;
            if (r) {
                const n = t.setupContext = r.length > 1 ? Vi(t) : null;
                Ni = t,
                    v();
                const o = Ct(r, t, 0, [t.props, n]);
                if (_(),
                    Ni = null,
                    Object(i["v"])(o)) {
                    if (e)
                        return o.then(n=>{
                                ji(t, n, e)
                            }
                        ).catch(e=>{
                                Ot(e, t, 0)
                            }
                        );
                    t.asyncDep = o
                } else
                    ji(t, o, e)
            } else
                Gi(t, e)
        }
        function ji(t, e, n) {
            Object(i["n"])(e) ? t.render = e : Object(i["t"])(e) && (t.setupState = Et(e)),
                Gi(t, n)
        }
        function Gi(t, e) {
            const n = t.type;
            t.render || (Hi && n.template && !n.render && (n.render = Hi(n.template, {
                isCustomElement: t.appContext.config.isCustomElement,
                delimiters: n.delimiters
            })),
                t.render = n.render || i["d"],
            t.render._rc && (t.withProxy = new Proxy(t.ctx,Ci))),
                Ni = t,
                v(),
                yi(t, n),
                _(),
                Ni = null
        }
        function Vi(t) {
            const e = e=>{
                    t.exposed = Et(e)
                }
            ;
            return {
                attrs: t.attrs,
                slots: t.slots,
                emit: t.emit,
                expose: e
            }
        }
        function Wi(t, e=Ni) {
            e && (e.effects || (e.effects = [])).push(t)
        }
        function qi(t) {
            return Object(i["n"])(t) && t.displayName || t.name
        }
        function Xi(t) {
            return Object(i["n"])(t) && "__vccOpts"in t
        }
        function Yi(t) {
            const e = Rt(t);
            return Wi(e.effect),
                e
        }
        function Zi(t, e, n) {
            const r = arguments.length;
            return 2 === r ? Object(i["t"])(e) && !Object(i["m"])(e) ? ei(e) ? si(t, null, [e]) : si(t, e) : si(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && ei(n) && (n = [n]),
                si(t, e, n))
        }
        Symbol("");
        const Ji = "3.0.11"
            , Ki = "http://www.w3.org/2000/svg"
            , Qi = "undefined" !== typeof document ? document : null;
        let $i, tr;
        const er = {
            insert: (t,e,n)=>{
                e.insertBefore(t, n || null)
            }
            ,
            remove: t=>{
                const e = t.parentNode;
                e && e.removeChild(t)
            }
            ,
            createElement: (t,e,n,i)=>{
                const r = e ? Qi.createElementNS(Ki, t) : Qi.createElement(t, n ? {
                    is: n
                } : void 0);
                return "select" === t && i && null != i.multiple && r.setAttribute("multiple", i.multiple),
                    r
            }
            ,
            createText: t=>Qi.createTextNode(t),
            createComment: t=>Qi.createComment(t),
            setText: (t,e)=>{
                t.nodeValue = e
            }
            ,
            setElementText: (t,e)=>{
                t.textContent = e
            }
            ,
            parentNode: t=>t.parentNode,
            nextSibling: t=>t.nextSibling,
            querySelector: t=>Qi.querySelector(t),
            setScopeId(t, e) {
                t.setAttribute(e, "")
            },
            cloneNode(t) {
                const e = t.cloneNode(!0);
                return "_value"in t && (e._value = t._value),
                    e
            },
            insertStaticContent(t, e, n, i) {
                const r = i ? tr || (tr = Qi.createElementNS(Ki, "svg")) : $i || ($i = Qi.createElement("div"));
                r.innerHTML = t;
                const o = r.firstChild;
                let s = o
                    , a = s;
                while (s)
                    a = s,
                        er.insert(s, e, n),
                        s = r.firstChild;
                return [o, a]
            }
        };
        function nr(t, e, n) {
            if (null == e && (e = ""),
                n)
                t.setAttribute("class", e);
            else {
                const n = t._vtc;
                n && (e = (e ? [e, ...n] : [...n]).join(" ")),
                    t.className = e
            }
        }
        function ir(t, e, n) {
            const r = t.style;
            if (n)
                if (Object(i["A"])(n)) {
                    if (e !== n) {
                        const e = r.display;
                        r.cssText = n,
                        "_vod"in t && (r.display = e)
                    }
                } else {
                    for (const t in n)
                        or(r, t, n[t]);
                    if (e && !Object(i["A"])(e))
                        for (const t in e)
                            null == n[t] && or(r, t, "")
                }
            else
                t.removeAttribute("style")
        }
        const rr = /\s*!important$/;
        function or(t, e, n) {
            if (Object(i["m"])(n))
                n.forEach(n=>or(t, e, n));
            else if (e.startsWith("--"))
                t.setProperty(e, n);
            else {
                const r = cr(t, e);
                rr.test(n) ? t.setProperty(Object(i["k"])(r), n.replace(rr, ""), "important") : t[r] = n
            }
        }
        const sr = ["Webkit", "Moz", "ms"]
            , ar = {};
        function cr(t, e) {
            const n = ar[e];
            if (n)
                return n;
            let r = Object(i["e"])(e);
            if ("filter" !== r && r in t)
                return ar[e] = r;
            r = Object(i["f"])(r);
            for (let i = 0; i < sr.length; i++) {
                const n = sr[i] + r;
                if (n in t)
                    return ar[e] = n
            }
            return e
        }
        const lr = "http://www.w3.org/1999/xlink";
        function ur(t, e, n, r) {
            if (r && e.startsWith("xlink:"))
                null == n ? t.removeAttributeNS(lr, e.slice(6, e.length)) : t.setAttributeNS(lr, e, n);
            else {
                const r = Object(i["z"])(e);
                null == n || r && !1 === n ? t.removeAttribute(e) : t.setAttribute(e, r ? "" : n)
            }
        }
        function hr(t, e, n, i, r, o, s) {
            if ("innerHTML" === e || "textContent" === e)
                return i && s(i, r, o),
                    void (t[e] = null == n ? "" : n);
            if ("value" !== e || "PROGRESS" === t.tagName) {
                if ("" === n || null == n) {
                    const i = typeof t[e];
                    if ("" === n && "boolean" === i)
                        return void (t[e] = !0);
                    if (null == n && "string" === i)
                        return t[e] = "",
                            void t.removeAttribute(e);
                    if ("number" === i)
                        return t[e] = 0,
                            void t.removeAttribute(e)
                }
                try {
                    t[e] = n
                } catch (a) {
                    0
                }
            } else {
                t._value = n;
                const e = null == n ? "" : n;
                t.value !== e && (t.value = e)
            }
        }
        let dr = Date.now
            , pr = !1;
        if ("undefined" !== typeof window) {
            dr() > document.createEvent("Event").timeStamp && (dr = ()=>performance.now());
            const t = navigator.userAgent.match(/firefox\/(\d+)/i);
            pr = !!(t && Number(t[1]) <= 53)
        }
        let fr = 0;
        const mr = Promise.resolve()
            , gr = ()=>{
            fr = 0
        }
            , vr = ()=>fr || (mr.then(gr),
            fr = dr());
        function yr(t, e, n, i) {
            t.addEventListener(e, n, i)
        }
        function _r(t, e, n, i) {
            t.removeEventListener(e, n, i)
        }
        function xr(t, e, n, i, r=null) {
            const o = t._vei || (t._vei = {})
                , s = o[e];
            if (i && s)
                s.value = i;
            else {
                const [n,a] = wr(e);
                if (i) {
                    const s = o[e] = Mr(i, r);
                    yr(t, n, s, a)
                } else
                    s && (_r(t, n, s, a),
                        o[e] = void 0)
            }
        }
        const br = /(?:Once|Passive|Capture)$/;
        function wr(t) {
            let e;
            if (br.test(t)) {
                let n;
                e = {};
                while (n = t.match(br))
                    t = t.slice(0, t.length - n[0].length),
                        e[n[0].toLowerCase()] = !0
            }
            return [Object(i["k"])(t.slice(2)), e]
        }
        function Mr(t, e) {
            const n = t=>{
                    const i = t.timeStamp || dr();
                    (pr || i >= n.attached - 1) && Pt(Sr(t, n.value), e, 5, [t])
                }
            ;
            return n.value = t,
                n.attached = vr(),
                n
        }
        function Sr(t, e) {
            if (Object(i["m"])(e)) {
                const n = t.stopImmediatePropagation;
                return t.stopImmediatePropagation = ()=>{
                    n.call(t),
                        t._stopped = !0
                }
                    ,
                    e.map(t=>e=>!e._stopped && t(e))
            }
            return e
        }
        const Er = /^on[a-z]/
            , Tr = (t,e)=>"value" === e
            , Ar = (t,e,n,r,o=!1,s,a,c,l)=>{
                switch (e) {
                    case "class":
                        nr(t, r, o);
                        break;
                    case "style":
                        ir(t, n, r);
                        break;
                    default:
                        Object(i["u"])(e) ? Object(i["s"])(e) || xr(t, e, n, r, a) : Lr(t, e, r, o) ? hr(t, e, r, s, a, c, l) : ("true-value" === e ? t._trueValue = r : "false-value" === e && (t._falseValue = r),
                            ur(t, e, r, o));
                        break
                }
            }
        ;
        function Lr(t, e, n, r) {
            return r ? "innerHTML" === e || !!(e in t && Er.test(e) && Object(i["n"])(n)) : "spellcheck" !== e && "draggable" !== e && ("form" !== e && (("list" !== e || "INPUT" !== t.tagName) && (("type" !== e || "TEXTAREA" !== t.tagName) && ((!Er.test(e) || !Object(i["A"])(n)) && e in t))))
        }
        const Rr = "transition"
            , Cr = "animation"
            , Pr = (t,{slots: e})=>Zi(nn, Ir(t), e);
        Pr.displayName = "Transition";
        const Or = {
            name: String,
            type: String,
            css: {
                type: Boolean,
                default: !0
            },
            duration: [String, Number, Object],
            enterFromClass: String,
            enterActiveClass: String,
            enterToClass: String,
            appearFromClass: String,
            appearActiveClass: String,
            appearToClass: String,
            leaveFromClass: String,
            leaveActiveClass: String,
            leaveToClass: String
        };
        Pr.props = Object(i["h"])({}, nn.props, Or);
        function Ir(t) {
            let {name: e="v", type: n, css: r=!0, duration: o, enterFromClass: s=e + "-enter-from", enterActiveClass: a=e + "-enter-active", enterToClass: c=e + "-enter-to", appearFromClass: l=s, appearActiveClass: u=a, appearToClass: h=c, leaveFromClass: d=e + "-leave-from", leaveActiveClass: p=e + "-leave-active", leaveToClass: f=e + "-leave-to"} = t;
            const m = {};
            for (const i in t)
                i in Or || (m[i] = t[i]);
            if (!r)
                return m;
            const g = Nr(o)
                , v = g && g[0]
                , y = g && g[1]
                , {onBeforeEnter: _, onEnter: x, onEnterCancelled: b, onLeave: w, onLeaveCancelled: M, onBeforeAppear: S=_, onAppear: E=x, onAppearCancelled: T=b} = m
                , A = (t,e,n)=>{
                    kr(t, e ? h : c),
                        kr(t, e ? u : a),
                    n && n()
                }
                , L = (t,e)=>{
                    kr(t, f),
                        kr(t, p),
                    e && e()
                }
                , R = t=>(e,i)=>{
                    const r = t ? E : x
                        , o = ()=>A(e, t, i);
                    r && r(e, o),
                        Hr(()=>{
                                kr(e, t ? l : s),
                                    Fr(e, t ? h : c),
                                r && r.length > 1 || zr(e, n, v, o)
                            }
                        )
                }
            ;
            return Object(i["h"])(m, {
                onBeforeEnter(t) {
                    _ && _(t),
                        Fr(t, s),
                        Fr(t, a)
                },
                onBeforeAppear(t) {
                    S && S(t),
                        Fr(t, l),
                        Fr(t, u)
                },
                onEnter: R(!1),
                onAppear: R(!0),
                onLeave(t, e) {
                    const i = ()=>L(t, e);
                    Fr(t, d),
                        Vr(),
                        Fr(t, p),
                        Hr(()=>{
                                kr(t, d),
                                    Fr(t, f),
                                w && w.length > 1 || zr(t, n, y, i)
                            }
                        ),
                    w && w(t, i)
                },
                onEnterCancelled(t) {
                    A(t, !1),
                    b && b(t)
                },
                onAppearCancelled(t) {
                    A(t, !0),
                    T && T(t)
                },
                onLeaveCancelled(t) {
                    L(t),
                    M && M(t)
                }
            })
        }
        function Nr(t) {
            if (null == t)
                return null;
            if (Object(i["t"])(t))
                return [Dr(t.enter), Dr(t.leave)];
            {
                const e = Dr(t);
                return [e, e]
            }
        }
        function Dr(t) {
            const e = Object(i["K"])(t);
            return e
        }
        function Fr(t, e) {
            e.split(/\s+/).forEach(e=>e && t.classList.add(e)),
                (t._vtc || (t._vtc = new Set)).add(e)
        }
        function kr(t, e) {
            e.split(/\s+/).forEach(e=>e && t.classList.remove(e));
            const {_vtc: n} = t;
            n && (n.delete(e),
            n.size || (t._vtc = void 0))
        }
        function Hr(t) {
            requestAnimationFrame(()=>{
                    requestAnimationFrame(t)
                }
            )
        }
        let Br = 0;
        function zr(t, e, n, i) {
            const r = t._endId = ++Br
                , o = ()=>{
                    r === t._endId && i()
                }
            ;
            if (n)
                return setTimeout(o, n);
            const {type: s, timeout: a, propCount: c} = Ur(t, e);
            if (!s)
                return i();
            const l = s + "end";
            let u = 0;
            const h = ()=>{
                    t.removeEventListener(l, d),
                        o()
                }
                , d = e=>{
                    e.target === t && ++u >= c && h()
                }
            ;
            setTimeout(()=>{
                    u < c && h()
                }
                , a + 1),
                t.addEventListener(l, d)
        }
        function Ur(t, e) {
            const n = window.getComputedStyle(t)
                , i = t=>(n[t] || "").split(", ")
                , r = i(Rr + "Delay")
                , o = i(Rr + "Duration")
                , s = jr(r, o)
                , a = i(Cr + "Delay")
                , c = i(Cr + "Duration")
                , l = jr(a, c);
            let u = null
                , h = 0
                , d = 0;
            e === Rr ? s > 0 && (u = Rr,
                h = s,
                d = o.length) : e === Cr ? l > 0 && (u = Cr,
                h = l,
                d = c.length) : (h = Math.max(s, l),
                u = h > 0 ? s > l ? Rr : Cr : null,
                d = u ? u === Rr ? o.length : c.length : 0);
            const p = u === Rr && /\b(transform|all)(,|$)/.test(n[Rr + "Property"]);
            return {
                type: u,
                timeout: h,
                propCount: d,
                hasTransform: p
            }
        }
        function jr(t, e) {
            while (t.length < e.length)
                t = t.concat(t);
            return Math.max(...e.map((e,n)=>Gr(e) + Gr(t[n])))
        }
        function Gr(t) {
            return 1e3 * Number(t.slice(0, -1).replace(",", "."))
        }
        function Vr() {
            return document.body.offsetHeight
        }
        new WeakMap,
            new WeakMap;
        const Wr = Object(i["h"])({
            patchProp: Ar,
            forcePatchProp: Tr
        }, er);
        let qr;
        function Xr() {
            return qr || (qr = Nn(Wr))
        }
        const Yr = (...t)=>{
                const e = Xr().createApp(...t);
                const {mount: n} = e;
                return e.mount = t=>{
                    const r = Zr(t);
                    if (!r)
                        return;
                    const o = e._component;
                    Object(i["n"])(o) || o.render || o.template || (o.template = r.innerHTML),
                        r.innerHTML = "";
                    const s = n(r, !1, r instanceof SVGElement);
                    return r instanceof Element && (r.removeAttribute("v-cloak"),
                        r.setAttribute("data-v-app", "")),
                        s
                }
                    ,
                    e
            }
        ;
        function Zr(t) {
            if (Object(i["A"])(t)) {
                const e = document.querySelector(t);
                return e
            }
            return t
        }
    },
    "7b0b": function(t, e, n) {
        var i = n("1d80");
        t.exports = function(t) {
            return Object(i(t))
        }
    },
    "7c73": function(t, e, n) {
        var i, r = n("825a"), o = n("37e8"), s = n("7839"), a = n("d012"), c = n("1be4"), l = n("cc12"), u = n("f772"), h = ">", d = "<", p = "prototype", f = "script", m = u("IE_PROTO"), g = function() {}, v = function(t) {
            return d + f + h + t + d + "/" + f + h
        }, y = function(t) {
            t.write(v("")),
                t.close();
            var e = t.parentWindow.Object;
            return t = null,
                e
        }, _ = function() {
            var t, e = l("iframe"), n = "java" + f + ":";
            return e.style.display = "none",
                c.appendChild(e),
                e.src = String(n),
                t = e.contentWindow.document,
                t.open(),
                t.write(v("document.F=Object")),
                t.close(),
                t.F
        }, x = function() {
            try {
                i = document.domain && new ActiveXObject("htmlfile")
            } catch (e) {}
            x = i ? y(i) : _();
            var t = s.length;
            while (t--)
                delete x[p][s[t]];
            return x()
        };
        a[m] = !0,
            t.exports = Object.create || function(t, e) {
                var n;
                return null !== t ? (g[p] = r(t),
                    n = new g,
                    g[p] = null,
                    n[m] = t) : n = x(),
                    void 0 === e ? n : o(n, e)
            }
    },
    "7db0": function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("b727").find
            , o = n("44d2")
            , s = "find"
            , a = !0;
        s in [] && Array(1)[s]((function() {
                a = !1
            }
        )),
            i({
                target: "Array",
                proto: !0,
                forced: a
            }, {
                find: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }),
            o(s)
    },
    "7dd0": function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("9ed3")
            , o = n("e163")
            , s = n("d2bb")
            , a = n("d44e")
            , c = n("9112")
            , l = n("6eeb")
            , u = n("b622")
            , h = n("c430")
            , d = n("3f8c")
            , p = n("ae93")
            , f = p.IteratorPrototype
            , m = p.BUGGY_SAFARI_ITERATORS
            , g = u("iterator")
            , v = "keys"
            , y = "values"
            , _ = "entries"
            , x = function() {
            return this
        };
        t.exports = function(t, e, n, u, p, b, w) {
            r(n, e, u);
            var M, S, E, T = function(t) {
                if (t === p && P)
                    return P;
                if (!m && t in R)
                    return R[t];
                switch (t) {
                    case v:
                        return function() {
                            return new n(this,t)
                        }
                            ;
                    case y:
                        return function() {
                            return new n(this,t)
                        }
                            ;
                    case _:
                        return function() {
                            return new n(this,t)
                        }
                }
                return function() {
                    return new n(this)
                }
            }, A = e + " Iterator", L = !1, R = t.prototype, C = R[g] || R["@@iterator"] || p && R[p], P = !m && C || T(p), O = "Array" == e && R.entries || C;
            if (O && (M = o(O.call(new t)),
            f !== Object.prototype && M.next && (h || o(M) === f || (s ? s(M, f) : "function" != typeof M[g] && c(M, g, x)),
                a(M, A, !0, !0),
            h && (d[A] = x))),
            p == y && C && C.name !== y && (L = !0,
                    P = function() {
                        return C.call(this)
                    }
            ),
            h && !w || R[g] === P || c(R, g, P),
                d[e] = P,
                p)
                if (S = {
                    values: T(y),
                    keys: b ? P : T(v),
                    entries: T(_)
                },
                    w)
                    for (E in S)
                        (m || L || !(E in R)) && l(R, E, S[E]);
                else
                    i({
                        target: e,
                        proto: !0,
                        forced: m || L
                    }, S);
            return S
        }
    },
    "7f9a": function(t, e, n) {
        var i = n("da84")
            , r = n("8925")
            , o = i.WeakMap;
        t.exports = "function" === typeof o && /native code/.test(r(o))
    },
    "81d5": function(t, e, n) {
        "use strict";
        var i = n("7b0b")
            , r = n("23cb")
            , o = n("50c4");
        t.exports = function(t) {
            var e = i(this)
                , n = o(e.length)
                , s = arguments.length
                , a = r(s > 1 ? arguments[1] : void 0, n)
                , c = s > 2 ? arguments[2] : void 0
                , l = void 0 === c ? n : r(c, n);
            while (l > a)
                e[a++] = t;
            return e
        }
    },
    "825a": function(t, e, n) {
        var i = n("861d");
        t.exports = function(t) {
            if (!i(t))
                throw TypeError(String(t) + " is not an object");
            return t
        }
    },
    "82f8": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("4d64").includes
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("includes", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    "83ab": function(t, e, n) {
        var i = n("d039");
        t.exports = !i((function() {
                return 7 != Object.defineProperty({}, 1, {
                    get: function() {
                        return 7
                    }
                })[1]
            }
        ))
    },
    8418: function(t, e, n) {
        "use strict";
        var i = n("c04e")
            , r = n("9bf2")
            , o = n("5c6c");
        t.exports = function(t, e, n) {
            var s = i(e);
            s in t ? r.f(t, s, o(0, n)) : t[s] = n
        }
    },
    "857a": function(t, e, n) {
        var i = n("1d80")
            , r = /"/g;
        t.exports = function(t, e, n, o) {
            var s = String(i(t))
                , a = "<" + e;
            return "" !== n && (a += " " + n + '="' + String(o).replace(r, "&quot;") + '"'),
            a + ">" + s + "</" + e + ">"
        }
    },
    "861d": function(t, e) {
        t.exports = function(t) {
            return "object" === typeof t ? null !== t : "function" === typeof t
        }
    },
    8925: function(t, e, n) {
        var i = n("c6cd")
            , r = Function.toString;
        "function" != typeof i.inspectSource && (i.inspectSource = function(t) {
                return r.call(t)
            }
        ),
            t.exports = i.inspectSource
    },
    "8aa7": function(t, e, n) {
        var i = n("da84")
            , r = n("d039")
            , o = n("1c7e")
            , s = n("ebb5").NATIVE_ARRAY_BUFFER_VIEWS
            , a = i.ArrayBuffer
            , c = i.Int8Array;
        t.exports = !s || !r((function() {
                c(1)
            }
        )) || !r((function() {
                new c(-1)
            }
        )) || !o((function(t) {
                new c,
                    new c(null),
                    new c(1.5),
                    new c(t)
            }
        ), !0) || r((function() {
                return 1 !== new c(new a(2),1,void 0).length
            }
        ))
    },
    "90e3": function(t, e) {
        var n = 0
            , i = Math.random();
        t.exports = function(t) {
            return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++n + i).toString(36)
        }
    },
    9112: function(t, e, n) {
        var i = n("83ab")
            , r = n("9bf2")
            , o = n("5c6c");
        t.exports = i ? function(t, e, n) {
                return r.f(t, e, o(1, n))
            }
            : function(t, e, n) {
                return t[e] = n,
                    t
            }
    },
    "94ca": function(t, e, n) {
        var i = n("d039")
            , r = /#|\.prototype\./
            , o = function(t, e) {
            var n = a[s(t)];
            return n == l || n != c && ("function" == typeof e ? i(e) : !!e)
        }
            , s = o.normalize = function(t) {
            return String(t).replace(r, ".").toLowerCase()
        }
            , a = o.data = {}
            , c = o.NATIVE = "N"
            , l = o.POLYFILL = "P";
        t.exports = o
    },
    9911: function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("857a")
            , o = n("af03");
        i({
            target: "String",
            proto: !0,
            forced: o("link")
        }, {
            link: function(t) {
                return r(this, "a", "href", t)
            }
        })
    },
    "9a8c": function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("145e")
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("copyWithin", (function(t, e) {
                return r.call(o(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
            }
        ))
    },
    "9bf2": function(t, e, n) {
        var i = n("83ab")
            , r = n("0cfb")
            , o = n("825a")
            , s = n("c04e")
            , a = Object.defineProperty;
        e.f = i ? a : function(t, e, n) {
            if (o(t),
                e = s(e, !0),
                o(n),
                r)
                try {
                    return a(t, e, n)
                } catch (i) {}
            if ("get"in n || "set"in n)
                throw TypeError("Accessors not supported");
            return "value"in n && (t[e] = n.value),
                t
        }
    },
    "9ed3": function(t, e, n) {
        "use strict";
        var i = n("ae93").IteratorPrototype
            , r = n("7c73")
            , o = n("5c6c")
            , s = n("d44e")
            , a = n("3f8c")
            , c = function() {
            return this
        };
        t.exports = function(t, e, n) {
            var l = e + " Iterator";
            return t.prototype = r(i, {
                next: o(1, n)
            }),
                s(t, l, !1, !0),
                a[l] = c,
                t
        }
    },
    "9ff4": function(t, e, n) {
        "use strict";
        (function(t) {
                function i(t, e) {
                    const n = Object.create(null)
                        , i = t.split(",");
                    for (let r = 0; r < i.length; r++)
                        n[i[r]] = !0;
                    return e ? t=>!!n[t.toLowerCase()] : t=>!!n[t]
                }
                n.d(e, "a", (function() {
                        return M
                    }
                )),
                    n.d(e, "b", (function() {
                            return w
                        }
                    )),
                    n.d(e, "c", (function() {
                            return E
                        }
                    )),
                    n.d(e, "d", (function() {
                            return S
                        }
                    )),
                    n.d(e, "e", (function() {
                            return J
                        }
                    )),
                    n.d(e, "f", (function() {
                            return $
                        }
                    )),
                    n.d(e, "g", (function() {
                            return it
                        }
                    )),
                    n.d(e, "h", (function() {
                            return R
                        }
                    )),
                    n.d(e, "i", (function() {
                            return et
                        }
                    )),
                    n.d(e, "j", (function() {
                            return O
                        }
                    )),
                    n.d(e, "k", (function() {
                            return Q
                        }
                    )),
                    n.d(e, "l", (function() {
                            return nt
                        }
                    )),
                    n.d(e, "m", (function() {
                            return I
                        }
                    )),
                    n.d(e, "n", (function() {
                            return k
                        }
                    )),
                    n.d(e, "o", (function() {
                            return o
                        }
                    )),
                    n.d(e, "p", (function() {
                            return m
                        }
                    )),
                    n.d(e, "q", (function() {
                            return q
                        }
                    )),
                    n.d(e, "r", (function() {
                            return N
                        }
                    )),
                    n.d(e, "s", (function() {
                            return L
                        }
                    )),
                    n.d(e, "t", (function() {
                            return z
                        }
                    )),
                    n.d(e, "u", (function() {
                            return A
                        }
                    )),
                    n.d(e, "v", (function() {
                            return U
                        }
                    )),
                    n.d(e, "w", (function() {
                            return X
                        }
                    )),
                    n.d(e, "x", (function() {
                            return g
                        }
                    )),
                    n.d(e, "y", (function() {
                            return D
                        }
                    )),
                    n.d(e, "z", (function() {
                            return a
                        }
                    )),
                    n.d(e, "A", (function() {
                            return H
                        }
                    )),
                    n.d(e, "B", (function() {
                            return B
                        }
                    )),
                    n.d(e, "C", (function() {
                            return y
                        }
                    )),
                    n.d(e, "D", (function() {
                            return _
                        }
                    )),
                    n.d(e, "E", (function() {
                            return i
                        }
                    )),
                    n.d(e, "F", (function() {
                            return d
                        }
                    )),
                    n.d(e, "G", (function() {
                            return c
                        }
                    )),
                    n.d(e, "H", (function() {
                            return C
                        }
                    )),
                    n.d(e, "I", (function() {
                            return x
                        }
                    )),
                    n.d(e, "J", (function() {
                            return tt
                        }
                    )),
                    n.d(e, "K", (function() {
                            return rt
                        }
                    )),
                    n.d(e, "L", (function() {
                            return V
                        }
                    ));
                const r = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt"
                    , o = i(r);
                const s = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
                    , a = i(s);
                function c(t) {
                    if (I(t)) {
                        const e = {};
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n]
                                , r = c(H(i) ? h(i) : i);
                            if (r)
                                for (const t in r)
                                    e[t] = r[t]
                        }
                        return e
                    }
                    if (z(t))
                        return t
                }
                const l = /;(?![^(]*\))/g
                    , u = /:(.+)/;
                function h(t) {
                    const e = {};
                    return t.split(l).forEach(t=>{
                            if (t) {
                                const n = t.split(u);
                                n.length > 1 && (e[n[0].trim()] = n[1].trim())
                            }
                        }
                    ),
                        e
                }
                function d(t) {
                    let e = "";
                    if (H(t))
                        e = t;
                    else if (I(t))
                        for (let n = 0; n < t.length; n++) {
                            const i = d(t[n]);
                            i && (e += i + " ")
                        }
                    else if (z(t))
                        for (const n in t)
                            t[n] && (e += n + " ");
                    return e.trim()
                }
                const p = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"
                    , f = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"
                    , m = i(p)
                    , g = i(f);
                function v(t, e) {
                    if (t.length !== e.length)
                        return !1;
                    let n = !0;
                    for (let i = 0; n && i < t.length; i++)
                        n = y(t[i], e[i]);
                    return n
                }
                function y(t, e) {
                    if (t === e)
                        return !0;
                    let n = F(t)
                        , i = F(e);
                    if (n || i)
                        return !(!n || !i) && t.getTime() === e.getTime();
                    if (n = I(t),
                        i = I(e),
                    n || i)
                        return !(!n || !i) && v(t, e);
                    if (n = z(t),
                        i = z(e),
                    n || i) {
                        if (!n || !i)
                            return !1;
                        const r = Object.keys(t).length
                            , o = Object.keys(e).length;
                        if (r !== o)
                            return !1;
                        for (const n in t) {
                            const i = t.hasOwnProperty(n)
                                , r = e.hasOwnProperty(n);
                            if (i && !r || !i && r || !y(t[n], e[n]))
                                return !1
                        }
                    }
                    return String(t) === String(e)
                }
                function _(t, e) {
                    return t.findIndex(t=>y(t, e))
                }
                const x = t=>null == t ? "" : z(t) ? JSON.stringify(t, b, 2) : String(t)
                    , b = (t,e)=>N(e) ? {
                    [`Map(${e.size})`]: [...e.entries()].reduce((t,[e,n])=>(t[e + " =>"] = n,
                        t), {})
                } : D(e) ? {
                    [`Set(${e.size})`]: [...e.values()]
                } : !z(e) || I(e) || W(e) ? e : String(e)
                    , w = {}
                    , M = []
                    , S = ()=>{}
                    , E = ()=>!1
                    , T = /^on[^a-z]/
                    , A = t=>T.test(t)
                    , L = t=>t.startsWith("onUpdate:")
                    , R = Object.assign
                    , C = (t,e)=>{
                    const n = t.indexOf(e);
                    n > -1 && t.splice(n, 1)
                }
                    , P = Object.prototype.hasOwnProperty
                    , O = (t,e)=>P.call(t, e)
                    , I = Array.isArray
                    , N = t=>"[object Map]" === G(t)
                    , D = t=>"[object Set]" === G(t)
                    , F = t=>t instanceof Date
                    , k = t=>"function" === typeof t
                    , H = t=>"string" === typeof t
                    , B = t=>"symbol" === typeof t
                    , z = t=>null !== t && "object" === typeof t
                    , U = t=>z(t) && k(t.then) && k(t.catch)
                    , j = Object.prototype.toString
                    , G = t=>j.call(t)
                    , V = t=>G(t).slice(8, -1)
                    , W = t=>"[object Object]" === G(t)
                    , q = t=>H(t) && "NaN" !== t && "-" !== t[0] && "" + parseInt(t, 10) === t
                    , X = i(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
                    , Y = t=>{
                    const e = Object.create(null);
                    return n=>{
                        const i = e[n];
                        return i || (e[n] = t(n))
                    }
                }
                    , Z = /-(\w)/g
                    , J = Y(t=>t.replace(Z, (t,e)=>e ? e.toUpperCase() : ""))
                    , K = /\B([A-Z])/g
                    , Q = Y(t=>t.replace(K, "-$1").toLowerCase())
                    , $ = Y(t=>t.charAt(0).toUpperCase() + t.slice(1))
                    , tt = Y(t=>t ? "on" + $(t) : "")
                    , et = (t,e)=>t !== e && (t === t || e === e)
                    , nt = (t,e)=>{
                    for (let n = 0; n < t.length; n++)
                        t[n](e)
                }
                    , it = (t,e,n)=>{
                    Object.defineProperty(t, e, {
                        configurable: !0,
                        enumerable: !1,
                        value: n
                    })
                }
                    , rt = t=>{
                    const e = parseFloat(t);
                    return isNaN(e) ? t : e
                }
            }
        ).call(this, n("c8ba"))
    },
    a078: function(t, e, n) {
        var i = n("7b0b")
            , r = n("50c4")
            , o = n("35a1")
            , s = n("e95a")
            , a = n("0366")
            , c = n("ebb5").aTypedArrayConstructor;
        t.exports = function(t) {
            var e, n, l, u, h, d, p = i(t), f = arguments.length, m = f > 1 ? arguments[1] : void 0, g = void 0 !== m, v = o(p);
            if (void 0 != v && !s(v)) {
                h = v.call(p),
                    d = h.next,
                    p = [];
                while (!(u = d.call(h)).done)
                    p.push(u.value)
            }
            for (g && f > 2 && (m = a(m, arguments[2], 2)),
                     n = r(p.length),
                     l = new (c(this))(n),
                     e = 0; n > e; e++)
                l[e] = g ? m(p[e], e) : p[e];
            return l
        }
    },
    a434: function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("23cb")
            , o = n("a691")
            , s = n("50c4")
            , a = n("7b0b")
            , c = n("65f0")
            , l = n("8418")
            , u = n("1dde")
            , h = u("splice")
            , d = Math.max
            , p = Math.min
            , f = 9007199254740991
            , m = "Maximum allowed length exceeded";
        i({
            target: "Array",
            proto: !0,
            forced: !h
        }, {
            splice: function(t, e) {
                var n, i, u, h, g, v, y = a(this), _ = s(y.length), x = r(t, _), b = arguments.length;
                if (0 === b ? n = i = 0 : 1 === b ? (n = 0,
                    i = _ - x) : (n = b - 2,
                    i = p(d(o(e), 0), _ - x)),
                _ + n - i > f)
                    throw TypeError(m);
                for (u = c(y, i),
                         h = 0; h < i; h++)
                    g = x + h,
                    g in y && l(u, h, y[g]);
                if (u.length = i,
                n < i) {
                    for (h = x; h < _ - i; h++)
                        g = h + i,
                            v = h + n,
                            g in y ? y[v] = y[g] : delete y[v];
                    for (h = _; h > _ - i + n; h--)
                        delete y[h - 1]
                } else if (n > i)
                    for (h = _ - i; h > x; h--)
                        g = h + i - 1,
                            v = h + n - 1,
                            g in y ? y[v] = y[g] : delete y[v];
                for (h = 0; h < n; h++)
                    y[h + x] = arguments[h + 2];
                return y.length = _ - i + n,
                    u
            }
        })
    },
    a4b4: function(t, e, n) {
        var i = n("342f");
        t.exports = /web0s(?!.*chrome)/i.test(i)
    },
    a640: function(t, e, n) {
        "use strict";
        var i = n("d039");
        t.exports = function(t, e) {
            var n = [][t];
            return !!n && i((function() {
                    n.call(null, e || function() {
                        throw 1
                    }
                        , 1)
                }
            ))
        }
    },
    a691: function(t, e) {
        var n = Math.ceil
            , i = Math.floor;
        t.exports = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t)
        }
    },
    a79d: function(t, e, n) {
        "use strict";
        var i = n("23e7")
            , r = n("c430")
            , o = n("fea9")
            , s = n("d039")
            , a = n("d066")
            , c = n("4840")
            , l = n("cdf9")
            , u = n("6eeb")
            , h = !!o && s((function() {
                o.prototype["finally"].call({
                    then: function() {}
                }, (function() {}
                ))
            }
        ));
        i({
            target: "Promise",
            proto: !0,
            real: !0,
            forced: h
        }, {
            finally: function(t) {
                var e = c(this, a("Promise"))
                    , n = "function" == typeof t;
                return this.then(n ? function(n) {
                        return l(e, t()).then((function() {
                                return n
                            }
                        ))
                    }
                    : t, n ? function(n) {
                        return l(e, t()).then((function() {
                                throw n
                            }
                        ))
                    }
                    : t)
            }
        }),
        r || "function" != typeof o || o.prototype["finally"] || u(o.prototype, "finally", a("Promise").prototype["finally"])
    },
    a975: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").every
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("every", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    a981: function(t, e) {
        t.exports = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof DataView
    },
    ae93: function(t, e, n) {
        "use strict";
        var i, r, o, s = n("d039"), a = n("e163"), c = n("9112"), l = n("5135"), u = n("b622"), h = n("c430"), d = u("iterator"), p = !1, f = function() {
            return this
        };
        [].keys && (o = [].keys(),
            "next"in o ? (r = a(a(o)),
            r !== Object.prototype && (i = r)) : p = !0);
        var m = void 0 == i || s((function() {
                var t = {};
                return i[d].call(t) !== t
            }
        ));
        m && (i = {}),
        h && !m || l(i, d) || c(i, d, f),
            t.exports = {
                IteratorPrototype: i,
                BUGGY_SAFARI_ITERATORS: p
            }
    },
    af03: function(t, e, n) {
        var i = n("d039");
        t.exports = function(t) {
            return i((function() {
                    var e = ""[t]('"');
                    return e !== e.toLowerCase() || e.split('"').length > 3
                }
            ))
        }
    },
    b041: function(t, e, n) {
        "use strict";
        var i = n("00ee")
            , r = n("f5df");
        t.exports = i ? {}.toString : function() {
            return "[object " + r(this) + "]"
        }
    },
    b0c0: function(t, e, n) {
        var i = n("83ab")
            , r = n("9bf2").f
            , o = Function.prototype
            , s = o.toString
            , a = /^\s*function ([^ (]*)/
            , c = "name";
        i && !(c in o) && r(o, c, {
            configurable: !0,
            get: function() {
                try {
                    return s.call(this).match(a)[1]
                } catch (t) {
                    return ""
                }
            }
        })
    },
    b39a: function(t, e, n) {
        "use strict";
        var i = n("da84")
            , r = n("ebb5")
            , o = n("d039")
            , s = i.Int8Array
            , a = r.aTypedArray
            , c = r.exportTypedArrayMethod
            , l = [].toLocaleString
            , u = [].slice
            , h = !!s && o((function() {
                l.call(new s(1))
            }
        ))
            , d = o((function() {
                return [1, 2].toLocaleString() != new s([1, 2]).toLocaleString()
            }
        )) || !o((function() {
                s.prototype.toLocaleString.call([1, 2])
            }
        ));
        c("toLocaleString", (function() {
                return l.apply(h ? u.call(a(this)) : a(this), arguments)
            }
        ), d)
    },
    b575: function(t, e, n) {
        var i, r, o, s, a, c, l, u, h = n("da84"), d = n("06cf").f, p = n("2cf4").set, f = n("1cdc"), m = n("a4b4"), g = n("605d"), v = h.MutationObserver || h.WebKitMutationObserver, y = h.document, _ = h.process, x = h.Promise, b = d(h, "queueMicrotask"), w = b && b.value;
        w || (i = function() {
            var t, e;
            g && (t = _.domain) && t.exit();
            while (r) {
                e = r.fn,
                    r = r.next;
                try {
                    e()
                } catch (n) {
                    throw r ? s() : o = void 0,
                        n
                }
            }
            o = void 0,
            t && t.enter()
        }
            ,
            f || g || m || !v || !y ? x && x.resolve ? (l = x.resolve(void 0),
                        u = l.then,
                        s = function() {
                            u.call(l, i)
                        }
                ) : s = g ? function() {
                        _.nextTick(i)
                    }
                    : function() {
                        p.call(h, i)
                    }
                : (a = !0,
                        c = y.createTextNode(""),
                        new v(i).observe(c, {
                            characterData: !0
                        }),
                        s = function() {
                            c.data = a = !a
                        }
                )),
            t.exports = w || function(t) {
                var e = {
                    fn: t,
                    next: void 0
                };
                o && (o.next = e),
                r || (r = e,
                    s()),
                    o = e
            }
    },
    b622: function(t, e, n) {
        var i = n("da84")
            , r = n("5692")
            , o = n("5135")
            , s = n("90e3")
            , a = n("4930")
            , c = n("fdbf")
            , l = r("wks")
            , u = i.Symbol
            , h = c ? u : u && u.withoutSetter || s;
        t.exports = function(t) {
            return o(l, t) && (a || "string" == typeof l[t]) || (a && o(u, t) ? l[t] = u[t] : l[t] = h("Symbol." + t)),
                l[t]
        }
    },
    b727: function(t, e, n) {
        var i = n("0366")
            , r = n("44ad")
            , o = n("7b0b")
            , s = n("50c4")
            , a = n("65f0")
            , c = [].push
            , l = function(t) {
            var e = 1 == t
                , n = 2 == t
                , l = 3 == t
                , u = 4 == t
                , h = 6 == t
                , d = 7 == t
                , p = 5 == t || h;
            return function(f, m, g, v) {
                for (var y, _, x = o(f), b = r(x), w = i(m, g, 3), M = s(b.length), S = 0, E = v || a, T = e ? E(f, M) : n || d ? E(f, 0) : void 0; M > S; S++)
                    if ((p || S in b) && (y = b[S],
                        _ = w(y, S, x),
                        t))
                        if (e)
                            T[S] = _;
                        else if (_)
                            switch (t) {
                                case 3:
                                    return !0;
                                case 5:
                                    return y;
                                case 6:
                                    return S;
                                case 2:
                                    c.call(T, y)
                            }
                        else
                            switch (t) {
                                case 4:
                                    return !1;
                                case 7:
                                    c.call(T, y)
                            }
                return h ? -1 : l || u ? u : T
            }
        };
        t.exports = {
            forEach: l(0),
            map: l(1),
            filter: l(2),
            some: l(3),
            every: l(4),
            find: l(5),
            findIndex: l(6),
            filterOut: l(7)
        }
    },
    b9d8: function(t, e, n) {
        "use strict";
        function i(t) {
            if (t && "undefined" !== typeof window) {
                var e = document.createElement("style");
                return e.setAttribute("type", "text/css"),
                    e.innerHTML = t,
                    document.head.appendChild(e),
                    t
            }
        }
        function r(t, e) {
            var n = t.__state.conversionName.toString()
                , i = Math.round(t.r)
                , r = Math.round(t.g)
                , o = Math.round(t.b)
                , s = t.a
                , a = Math.round(t.h)
                , c = t.s.toFixed(1)
                , l = t.v.toFixed(1);
            if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
                var u = t.hex.toString(16);
                while (u.length < 6)
                    u = "0" + u;
                return "#" + u
            }
            return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + o + "," + s + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + o + "," + s + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + s + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + ",a:" + s + "}" : "unknown format"
        }
        n.d(e, "a", (function() {
                return wt
            }
        ));
        var o = Array.prototype.forEach
            , s = Array.prototype.slice
            , a = {
            BREAK: {},
            extend: function(t) {
                return this.each(s.call(arguments, 1), (function(e) {
                        var n = this.isObject(e) ? Object.keys(e) : [];
                        n.forEach(function(n) {
                            this.isUndefined(e[n]) || (t[n] = e[n])
                        }
                            .bind(this))
                    }
                ), this),
                    t
            },
            defaults: function(t) {
                return this.each(s.call(arguments, 1), (function(e) {
                        var n = this.isObject(e) ? Object.keys(e) : [];
                        n.forEach(function(n) {
                            this.isUndefined(t[n]) && (t[n] = e[n])
                        }
                            .bind(this))
                    }
                ), this),
                    t
            },
            compose: function() {
                var t = s.call(arguments);
                return function() {
                    for (var e = s.call(arguments), n = t.length - 1; n >= 0; n--)
                        e = [t[n].apply(this, e)];
                    return e[0]
                }
            },
            each: function(t, e, n) {
                if (t)
                    if (o && t.forEach && t.forEach === o)
                        t.forEach(e, n);
                    else if (t.length === t.length + 0) {
                        var i = void 0
                            , r = void 0;
                        for (i = 0,
                                 r = t.length; i < r; i++)
                            if (i in t && e.call(n, t[i], i) === this.BREAK)
                                return
                    } else
                        for (var s in t)
                            if (e.call(n, t[s], s) === this.BREAK)
                                return
            },
            defer: function(t) {
                setTimeout(t, 0)
            },
            debounce: function(t, e, n) {
                var i = void 0;
                return function() {
                    var r = this
                        , o = arguments;
                    function s() {
                        i = null,
                        n || t.apply(r, o)
                    }
                    var a = n || !i;
                    clearTimeout(i),
                        i = setTimeout(s, e),
                    a && t.apply(r, o)
                }
            },
            toArray: function(t) {
                return t.toArray ? t.toArray() : s.call(t)
            },
            isUndefined: function(t) {
                return void 0 === t
            },
            isNull: function(t) {
                return null === t
            },
            isNaN: function(t) {
                function e() {
                    return t.apply(this, arguments)
                }
                return e.toString = function() {
                    return t.toString()
                }
                    ,
                    e
            }((function(t) {
                    return isNaN(t)
                }
            )),
            isArray: Array.isArray || function(t) {
                return t.constructor === Array
            }
            ,
            isObject: function(t) {
                return t === Object(t)
            },
            isNumber: function(t) {
                return t === t + 0
            },
            isString: function(t) {
                return t === t + ""
            },
            isBoolean: function(t) {
                return !1 === t || !0 === t
            },
            isFunction: function(t) {
                return t instanceof Function
            }
        }
            , c = [{
            litmus: a.isString,
            conversions: {
                THREE_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                        }
                    },
                    write: r
                },
                SIX_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9]{6})$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString(), 0)
                        }
                    },
                    write: r
                },
                CSS_RGB: {
                    read: function(t) {
                        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3])
                        }
                    },
                    write: r
                },
                CSS_RGBA: {
                    read: function(t) {
                        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3]),
                            a: parseFloat(e[4])
                        }
                    },
                    write: r
                }
            }
        }, {
            litmus: a.isNumber,
            conversions: {
                HEX: {
                    read: function(t) {
                        return {
                            space: "HEX",
                            hex: t,
                            conversionName: "HEX"
                        }
                    },
                    write: function(t) {
                        return t.hex
                    }
                }
            }
        }, {
            litmus: a.isArray,
            conversions: {
                RGB_ARRAY: {
                    read: function(t) {
                        return 3 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b]
                    }
                },
                RGBA_ARRAY: {
                    read: function(t) {
                        return 4 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2],
                            a: t[3]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b, t.a]
                    }
                }
            }
        }, {
            litmus: a.isObject,
            conversions: {
                RGBA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b) && a.isNumber(t.a)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    }
                },
                RGB_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    }
                },
                HSVA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v) && a.isNumber(t.a)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    }
                },
                HSV_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    }
                }
            }
        }]
            , l = void 0
            , u = void 0
            , h = function() {
            u = !1;
            var t = arguments.length > 1 ? a.toArray(arguments) : arguments[0];
            return a.each(c, (function(e) {
                    if (e.litmus(t))
                        return a.each(e.conversions, (function(e, n) {
                                if (l = e.read(t),
                                !1 === u && !1 !== l)
                                    return u = l,
                                        l.conversionName = n,
                                        l.conversion = e,
                                        a.BREAK
                            }
                        )),
                            a.BREAK
                }
            )),
                u
        }
            , d = void 0
            , p = {
            hsv_to_rgb: function(t, e, n) {
                var i = Math.floor(t / 60) % 6
                    , r = t / 60 - Math.floor(t / 60)
                    , o = n * (1 - e)
                    , s = n * (1 - r * e)
                    , a = n * (1 - (1 - r) * e)
                    , c = [[n, a, o], [s, n, o], [o, n, a], [o, s, n], [a, o, n], [n, o, s]][i];
                return {
                    r: 255 * c[0],
                    g: 255 * c[1],
                    b: 255 * c[2]
                }
            },
            rgb_to_hsv: function(t, e, n) {
                var i = Math.min(t, e, n)
                    , r = Math.max(t, e, n)
                    , o = r - i
                    , s = void 0
                    , a = void 0;
                return 0 === r ? {
                    h: NaN,
                    s: 0,
                    v: 0
                } : (a = o / r,
                    s = t === r ? (e - n) / o : e === r ? 2 + (n - t) / o : 4 + (t - e) / o,
                    s /= 6,
                s < 0 && (s += 1),
                    {
                        h: 360 * s,
                        s: a,
                        v: r / 255
                    })
            },
            rgb_to_hex: function(t, e, n) {
                var i = this.hex_with_component(0, 2, t);
                return i = this.hex_with_component(i, 1, e),
                    i = this.hex_with_component(i, 0, n),
                    i
            },
            component_from_hex: function(t, e) {
                return t >> 8 * e & 255
            },
            hex_with_component: function(t, e, n) {
                return n << (d = 8 * e) | t & ~(255 << d)
            }
        }
            , f = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(t) {
                return typeof t
            }
            : function(t) {
                return t && "function" === typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }
            , m = function(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }
            , g = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1,
                        i.configurable = !0,
                    "value"in i && (i.writable = !0),
                        Object.defineProperty(t, i.key, i)
                }
            }
            return function(e, n, i) {
                return n && t(e.prototype, n),
                i && t(e, i),
                    e
            }
        }()
            , v = function t(e, n, i) {
            null === e && (e = Function.prototype);
            var r = Object.getOwnPropertyDescriptor(e, n);
            if (void 0 === r) {
                var o = Object.getPrototypeOf(e);
                return null === o ? void 0 : t(o, n, i)
            }
            if ("value"in r)
                return r.value;
            var s = r.get;
            return void 0 !== s ? s.call(i) : void 0
        }
            , y = function(t, e) {
            if ("function" !== typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        }
            , _ = function(t, e) {
            if (!t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !e || "object" !== typeof e && "function" !== typeof e ? t : e
        }
            , x = function() {
            function t() {
                if (m(this, t),
                    this.__state = h.apply(this, arguments),
                !1 === this.__state)
                    throw new Error("Failed to interpret color arguments");
                this.__state.a = this.__state.a || 1
            }
            return g(t, [{
                key: "toString",
                value: function() {
                    return r(this)
                }
            }, {
                key: "toHexString",
                value: function() {
                    return r(this, !0)
                }
            }, {
                key: "toOriginal",
                value: function() {
                    return this.__state.conversion.write(this)
                }
            }]),
                t
        }();
        function b(t, e, n) {
            Object.defineProperty(t, e, {
                get: function() {
                    return "RGB" === this.__state.space || x.recalculateRGB(this, e, n),
                        this.__state[e]
                },
                set: function(t) {
                    "RGB" !== this.__state.space && (x.recalculateRGB(this, e, n),
                        this.__state.space = "RGB"),
                        this.__state[e] = t
                }
            })
        }
        function w(t, e) {
            Object.defineProperty(t, e, {
                get: function() {
                    return "HSV" === this.__state.space || x.recalculateHSV(this),
                        this.__state[e]
                },
                set: function(t) {
                    "HSV" !== this.__state.space && (x.recalculateHSV(this),
                        this.__state.space = "HSV"),
                        this.__state[e] = t
                }
            })
        }
        x.recalculateRGB = function(t, e, n) {
            if ("HEX" === t.__state.space)
                t.__state[e] = p.component_from_hex(t.__state.hex, n);
            else {
                if ("HSV" !== t.__state.space)
                    throw new Error("Corrupted color state");
                a.extend(t.__state, p.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
            }
        }
            ,
            x.recalculateHSV = function(t) {
                var e = p.rgb_to_hsv(t.r, t.g, t.b);
                a.extend(t.__state, {
                    s: e.s,
                    v: e.v
                }),
                    a.isNaN(e.h) ? a.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
            }
            ,
            x.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"],
            b(x.prototype, "r", 2),
            b(x.prototype, "g", 1),
            b(x.prototype, "b", 0),
            w(x.prototype, "h"),
            w(x.prototype, "s"),
            w(x.prototype, "v"),
            Object.defineProperty(x.prototype, "a", {
                get: function() {
                    return this.__state.a
                },
                set: function(t) {
                    this.__state.a = t
                }
            }),
            Object.defineProperty(x.prototype, "hex", {
                get: function() {
                    return "HEX" !== this.__state.space && (this.__state.hex = p.rgb_to_hex(this.r, this.g, this.b),
                        this.__state.space = "HEX"),
                        this.__state.hex
                },
                set: function(t) {
                    this.__state.space = "HEX",
                        this.__state.hex = t
                }
            });
        var M = function() {
            function t(e, n) {
                m(this, t),
                    this.initialValue = e[n],
                    this.domElement = document.createElement("div"),
                    this.object = e,
                    this.property = n,
                    this.__onChange = void 0,
                    this.__onFinishChange = void 0
            }
            return g(t, [{
                key: "onChange",
                value: function(t) {
                    return this.__onChange = t,
                        this
                }
            }, {
                key: "onFinishChange",
                value: function(t) {
                    return this.__onFinishChange = t,
                        this
                }
            }, {
                key: "setValue",
                value: function(t) {
                    return this.object[this.property] = t,
                    this.__onChange && this.__onChange.call(this, t),
                        this.updateDisplay(),
                        this
                }
            }, {
                key: "getValue",
                value: function() {
                    return this.object[this.property]
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return this
                }
            }, {
                key: "isModified",
                value: function() {
                    return this.initialValue !== this.getValue()
                }
            }]),
                t
        }()
            , S = {
            HTMLEvents: ["change"],
            MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
            KeyboardEvents: ["keydown"]
        }
            , E = {};
        a.each(S, (function(t, e) {
                a.each(t, (function(t) {
                        E[t] = e
                    }
                ))
            }
        ));
        var T = /(\d+(\.\d+)?)px/;
        function A(t) {
            if ("0" === t || a.isUndefined(t))
                return 0;
            var e = t.match(T);
            return a.isNull(e) ? 0 : parseFloat(e[1])
        }
        var L = {
            makeSelectable: function(t, e) {
                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                        return !1
                    }
                    : function() {}
                    ,
                    t.style.MozUserSelect = e ? "auto" : "none",
                    t.style.KhtmlUserSelect = e ? "auto" : "none",
                    t.unselectable = e ? "on" : "off")
            },
            makeFullscreen: function(t, e, n) {
                var i = n
                    , r = e;
                a.isUndefined(r) && (r = !0),
                a.isUndefined(i) && (i = !0),
                    t.style.position = "absolute",
                r && (t.style.left = 0,
                    t.style.right = 0),
                i && (t.style.top = 0,
                    t.style.bottom = 0)
            },
            fakeEvent: function(t, e, n, i) {
                var r = n || {}
                    , o = E[e];
                if (!o)
                    throw new Error("Event type " + e + " not supported.");
                var s = document.createEvent(o);
                switch (o) {
                    case "MouseEvents":
                        var c = r.x || r.clientX || 0
                            , l = r.y || r.clientY || 0;
                        s.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        var u = s.initKeyboardEvent || s.initKeyEvent;
                        a.defaults(r, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }),
                            u(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                        break;
                    default:
                        s.initEvent(e, r.bubbles || !1, r.cancelable || !0);
                        break
                }
                a.defaults(s, i),
                    t.dispatchEvent(s)
            },
            bind: function(t, e, n, i) {
                var r = i || !1;
                return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n),
                    L
            },
            unbind: function(t, e, n, i) {
                var r = i || !1;
                return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n),
                    L
            },
            addClass: function(t, e) {
                if (void 0 === t.className)
                    t.className = e;
                else if (t.className !== e) {
                    var n = t.className.split(/ +/);
                    -1 === n.indexOf(e) && (n.push(e),
                        t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                }
                return L
            },
            removeClass: function(t, e) {
                if (e)
                    if (t.className === e)
                        t.removeAttribute("class");
                    else {
                        var n = t.className.split(/ +/)
                            , i = n.indexOf(e);
                        -1 !== i && (n.splice(i, 1),
                            t.className = n.join(" "))
                    }
                else
                    t.className = void 0;
                return L
            },
            hasClass: function(t, e) {
                return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
            },
            getWidth: function(t) {
                var e = getComputedStyle(t);
                return A(e["border-left-width"]) + A(e["border-right-width"]) + A(e["padding-left"]) + A(e["padding-right"]) + A(e.width)
            },
            getHeight: function(t) {
                var e = getComputedStyle(t);
                return A(e["border-top-width"]) + A(e["border-bottom-width"]) + A(e["padding-top"]) + A(e["padding-bottom"]) + A(e.height)
            },
            getOffset: function(t) {
                var e = t
                    , n = {
                    left: 0,
                    top: 0
                };
                if (e.offsetParent)
                    do {
                        n.left += e.offsetLeft,
                            n.top += e.offsetTop,
                            e = e.offsetParent
                    } while (e);
                return n
            },
            isActive: function(t) {
                return t === document.activeElement && (t.type || t.href)
            }
        }
            , R = function(t) {
            function e(t, n) {
                m(this, e);
                var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
                    , r = i;
                function o() {
                    r.setValue(!r.__prev)
                }
                return i.__prev = i.getValue(),
                    i.__checkbox = document.createElement("input"),
                    i.__checkbox.setAttribute("type", "checkbox"),
                    L.bind(i.__checkbox, "change", o, !1),
                    i.domElement.appendChild(i.__checkbox),
                    i.updateDisplay(),
                    i
            }
            return y(e, t),
                g(e, [{
                    key: "setValue",
                    value: function(t) {
                        var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                            this.__prev = this.getValue(),
                            n
                    }
                }, {
                    key: "updateDisplay",
                    value: function() {
                        return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"),
                            this.__checkbox.checked = !0,
                            this.__prev = !0) : (this.__checkbox.checked = !1,
                            this.__prev = !1),
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]),
                e
        }(M)
            , C = function(t) {
            function e(t, n, i) {
                m(this, e);
                var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
                    , o = i
                    , s = r;
                if (r.__select = document.createElement("select"),
                    a.isArray(o)) {
                    var c = {};
                    a.each(o, (function(t) {
                            c[t] = t
                        }
                    )),
                        o = c
                }
                return a.each(o, (function(t, e) {
                        var n = document.createElement("option");
                        n.innerHTML = e,
                            n.setAttribute("value", t),
                            s.__select.appendChild(n)
                    }
                )),
                    r.updateDisplay(),
                    L.bind(r.__select, "change", (function() {
                            var t = this.options[this.selectedIndex].value;
                            s.setValue(t)
                        }
                    )),
                    r.domElement.appendChild(r.__select),
                    r
            }
            return y(e, t),
                g(e, [{
                    key: "setValue",
                    value: function(t) {
                        var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                            n
                    }
                }, {
                    key: "updateDisplay",
                    value: function() {
                        return L.isActive(this.__select) ? this : (this.__select.value = this.getValue(),
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                    }
                }]),
                e
        }(M)
            , P = function(t) {
            function e(t, n) {
                m(this, e);
                var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
                    , r = i;
                function o() {
                    r.setValue(r.__input.value)
                }
                function s() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
                }
                return i.__input = document.createElement("input"),
                    i.__input.setAttribute("type", "text"),
                    L.bind(i.__input, "keyup", o),
                    L.bind(i.__input, "change", o),
                    L.bind(i.__input, "blur", s),
                    L.bind(i.__input, "keydown", (function(t) {
                            13 === t.keyCode && this.blur()
                        }
                    )),
                    i.updateDisplay(),
                    i.domElement.appendChild(i.__input),
                    i
            }
            return y(e, t),
                g(e, [{
                    key: "updateDisplay",
                    value: function() {
                        return L.isActive(this.__input) || (this.__input.value = this.getValue()),
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]),
                e
        }(M);
        function O(t) {
            var e = t.toString();
            return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
        }
        var I = function(t) {
            function e(t, n, i) {
                m(this, e);
                var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
                    , o = i || {};
                return r.__min = o.min,
                    r.__max = o.max,
                    r.__step = o.step,
                    a.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step,
                    r.__precision = O(r.__impliedStep),
                    r
            }
            return y(e, t),
                g(e, [{
                    key: "setValue",
                    value: function(t) {
                        var n = t;
                        return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max),
                        void 0 !== this.__step && n % this.__step !== 0 && (n = Math.round(n / this.__step) * this.__step),
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
                    }
                }, {
                    key: "min",
                    value: function(t) {
                        return this.__min = t,
                            this
                    }
                }, {
                    key: "max",
                    value: function(t) {
                        return this.__max = t,
                            this
                    }
                }, {
                    key: "step",
                    value: function(t) {
                        return this.__step = t,
                            this.__impliedStep = t,
                            this.__precision = O(t),
                            this
                    }
                }]),
                e
        }(M);
        function N(t, e) {
            var n = Math.pow(10, e);
            return Math.round(t * n) / n
        }
        var D = function(t) {
            function e(t, n, i) {
                m(this, e);
                var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i));
                r.__truncationSuspended = !1;
                var o = r
                    , s = void 0;
                function c() {
                    var t = parseFloat(o.__input.value);
                    a.isNaN(t) || o.setValue(t)
                }
                function l() {
                    o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
                }
                function u() {
                    l()
                }
                function h(t) {
                    var e = s - t.clientY;
                    o.setValue(o.getValue() + e * o.__impliedStep),
                        s = t.clientY
                }
                function d() {
                    L.unbind(window, "mousemove", h),
                        L.unbind(window, "mouseup", d),
                        l()
                }
                function p(t) {
                    L.bind(window, "mousemove", h),
                        L.bind(window, "mouseup", d),
                        s = t.clientY
                }
                return r.__input = document.createElement("input"),
                    r.__input.setAttribute("type", "text"),
                    L.bind(r.__input, "change", c),
                    L.bind(r.__input, "blur", u),
                    L.bind(r.__input, "mousedown", p),
                    L.bind(r.__input, "keydown", (function(t) {
                            13 === t.keyCode && (o.__truncationSuspended = !0,
                                this.blur(),
                                o.__truncationSuspended = !1,
                                l())
                        }
                    )),
                    r.updateDisplay(),
                    r.domElement.appendChild(r.__input),
                    r
            }
            return y(e, t),
                g(e, [{
                    key: "updateDisplay",
                    value: function() {
                        return this.__input.value = this.__truncationSuspended ? this.getValue() : N(this.getValue(), this.__precision),
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]),
                e
        }(I);
        function F(t, e, n, i, r) {
            return i + (t - e) / (n - e) * (r - i)
        }
        var k = function(t) {
            function e(t, n, i, r, o) {
                m(this, e);
                var s = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                    min: i,
                    max: r,
                    step: o
                }))
                    , a = s;
                function c(t) {
                    document.activeElement.blur(),
                        L.bind(window, "mousemove", l),
                        L.bind(window, "mouseup", u),
                        l(t)
                }
                function l(t) {
                    t.preventDefault();
                    var e = a.__background.getBoundingClientRect();
                    return a.setValue(F(t.clientX, e.left, e.right, a.__min, a.__max)),
                        !1
                }
                function u() {
                    L.unbind(window, "mousemove", l),
                        L.unbind(window, "mouseup", u),
                    a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                }
                function h(t) {
                    1 === t.touches.length && (L.bind(window, "touchmove", d),
                        L.bind(window, "touchend", p),
                        d(t))
                }
                function d(t) {
                    var e = t.touches[0].clientX
                        , n = a.__background.getBoundingClientRect();
                    a.setValue(F(e, n.left, n.right, a.__min, a.__max))
                }
                function p() {
                    L.unbind(window, "touchmove", d),
                        L.unbind(window, "touchend", p),
                    a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
                }
                return s.__background = document.createElement("div"),
                    s.__foreground = document.createElement("div"),
                    L.bind(s.__background, "mousedown", c),
                    L.bind(s.__background, "touchstart", h),
                    L.addClass(s.__background, "slider"),
                    L.addClass(s.__foreground, "slider-fg"),
                    s.updateDisplay(),
                    s.__background.appendChild(s.__foreground),
                    s.domElement.appendChild(s.__background),
                    s
            }
            return y(e, t),
                g(e, [{
                    key: "updateDisplay",
                    value: function() {
                        var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                        return this.__foreground.style.width = 100 * t + "%",
                            v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]),
                e
        }(I)
            , H = function(t) {
            function e(t, n, i) {
                m(this, e);
                var r = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
                    , o = r;
                return r.__button = document.createElement("div"),
                    r.__button.innerHTML = void 0 === i ? "Fire" : i,
                    L.bind(r.__button, "click", (function(t) {
                            return t.preventDefault(),
                                o.fire(),
                                !1
                        }
                    )),
                    L.addClass(r.__button, "button"),
                    r.domElement.appendChild(r.__button),
                    r
            }
            return y(e, t),
                g(e, [{
                    key: "fire",
                    value: function() {
                        this.__onChange && this.__onChange.call(this),
                            this.getValue().call(this.object),
                        this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                    }
                }]),
                e
        }(M)
            , B = function(t) {
            function e(t, n) {
                m(this, e);
                var i = _(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
                i.__color = new x(i.getValue()),
                    i.__temp = new x(0);
                var r = i;
                i.domElement = document.createElement("div"),
                    L.makeSelectable(i.domElement, !1),
                    i.__selector = document.createElement("div"),
                    i.__selector.className = "selector",
                    i.__saturation_field = document.createElement("div"),
                    i.__saturation_field.className = "saturation-field",
                    i.__field_knob = document.createElement("div"),
                    i.__field_knob.className = "field-knob",
                    i.__field_knob_border = "2px solid ",
                    i.__hue_knob = document.createElement("div"),
                    i.__hue_knob.className = "hue-knob",
                    i.__hue_field = document.createElement("div"),
                    i.__hue_field.className = "hue-field",
                    i.__input = document.createElement("input"),
                    i.__input.type = "text",
                    i.__input_textShadow = "0 1px 1px ",
                    L.bind(i.__input, "keydown", (function(t) {
                            13 === t.keyCode && d.call(this)
                        }
                    )),
                    L.bind(i.__input, "blur", d),
                    L.bind(i.__selector, "mousedown", (function() {
                            L.addClass(this, "drag").bind(window, "mouseup", (function() {
                                    L.removeClass(r.__selector, "drag")
                                }
                            ))
                        }
                    )),
                    L.bind(i.__selector, "touchstart", (function() {
                            L.addClass(this, "drag").bind(window, "touchend", (function() {
                                    L.removeClass(r.__selector, "drag")
                                }
                            ))
                        }
                    ));
                var o = document.createElement("div");
                function s(t) {
                    f(t),
                        L.bind(window, "mousemove", f),
                        L.bind(window, "touchmove", f),
                        L.bind(window, "mouseup", l),
                        L.bind(window, "touchend", l)
                }
                function c(t) {
                    g(t),
                        L.bind(window, "mousemove", g),
                        L.bind(window, "touchmove", g),
                        L.bind(window, "mouseup", u),
                        L.bind(window, "touchend", u)
                }
                function l() {
                    L.unbind(window, "mousemove", f),
                        L.unbind(window, "touchmove", f),
                        L.unbind(window, "mouseup", l),
                        L.unbind(window, "touchend", l),
                        p()
                }
                function u() {
                    L.unbind(window, "mousemove", g),
                        L.unbind(window, "touchmove", g),
                        L.unbind(window, "mouseup", u),
                        L.unbind(window, "touchend", u),
                        p()
                }
                function d() {
                    var t = h(this.value);
                    !1 !== t ? (r.__color.__state = t,
                        r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString()
                }
                function p() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal())
                }
                function f(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__saturation_field.getBoundingClientRect()
                        , n = t.touches && t.touches[0] || t
                        , i = n.clientX
                        , o = n.clientY
                        , s = (i - e.left) / (e.right - e.left)
                        , a = 1 - (o - e.top) / (e.bottom - e.top);
                    return a > 1 ? a = 1 : a < 0 && (a = 0),
                        s > 1 ? s = 1 : s < 0 && (s = 0),
                        r.__color.v = a,
                        r.__color.s = s,
                        r.setValue(r.__color.toOriginal()),
                        !1
                }
                function g(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__hue_field.getBoundingClientRect()
                        , n = t.touches && t.touches[0] || t
                        , i = n.clientY
                        , o = 1 - (i - e.top) / (e.bottom - e.top);
                    return o > 1 ? o = 1 : o < 0 && (o = 0),
                        r.__color.h = 360 * o,
                        r.setValue(r.__color.toOriginal()),
                        !1
                }
                return a.extend(i.__selector.style, {
                    width: "122px",
                    height: "102px",
                    padding: "3px",
                    backgroundColor: "#222",
                    boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                }),
                    a.extend(i.__field_knob.style, {
                        position: "absolute",
                        width: "12px",
                        height: "12px",
                        border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"),
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                        borderRadius: "12px",
                        zIndex: 1
                    }),
                    a.extend(i.__hue_knob.style, {
                        position: "absolute",
                        width: "15px",
                        height: "2px",
                        borderRight: "4px solid #fff",
                        zIndex: 1
                    }),
                    a.extend(i.__saturation_field.style, {
                        width: "100px",
                        height: "100px",
                        border: "1px solid #555",
                        marginRight: "3px",
                        display: "inline-block",
                        cursor: "pointer"
                    }),
                    a.extend(o.style, {
                        width: "100%",
                        height: "100%",
                        background: "none"
                    }),
                    U(o, "top", "rgba(0,0,0,0)", "#000"),
                    a.extend(i.__hue_field.style, {
                        width: "15px",
                        height: "100px",
                        border: "1px solid #555",
                        cursor: "ns-resize",
                        position: "absolute",
                        top: "3px",
                        right: "3px"
                    }),
                    j(i.__hue_field),
                    a.extend(i.__input.style, {
                        outline: "none",
                        textAlign: "center",
                        color: "#fff",
                        border: 0,
                        fontWeight: "bold",
                        textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)"
                    }),
                    L.bind(i.__saturation_field, "mousedown", s),
                    L.bind(i.__saturation_field, "touchstart", s),
                    L.bind(i.__field_knob, "mousedown", s),
                    L.bind(i.__field_knob, "touchstart", s),
                    L.bind(i.__hue_field, "mousedown", c),
                    L.bind(i.__hue_field, "touchstart", c),
                    i.__saturation_field.appendChild(o),
                    i.__selector.appendChild(i.__field_knob),
                    i.__selector.appendChild(i.__saturation_field),
                    i.__selector.appendChild(i.__hue_field),
                    i.__hue_field.appendChild(i.__hue_knob),
                    i.domElement.appendChild(i.__input),
                    i.domElement.appendChild(i.__selector),
                    i.updateDisplay(),
                    i
            }
            return y(e, t),
                g(e, [{
                    key: "updateDisplay",
                    value: function() {
                        var t = h(this.getValue());
                        if (!1 !== t) {
                            var e = !1;
                            a.each(x.COMPONENTS, (function(n) {
                                    if (!a.isUndefined(t[n]) && !a.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n])
                                        return e = !0,
                                            {}
                                }
                            ), this),
                            e && a.extend(this.__color.__state, t)
                        }
                        a.extend(this.__temp.__state, this.__color.__state),
                            this.__temp.a = 1;
                        var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0
                            , i = 255 - n;
                        a.extend(this.__field_knob.style, {
                            marginLeft: 100 * this.__color.s - 7 + "px",
                            marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                            backgroundColor: this.__temp.toHexString(),
                            border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                        }),
                            this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px",
                            this.__temp.s = 1,
                            this.__temp.v = 1,
                            U(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
                            this.__input.value = this.__color.toString(),
                            a.extend(this.__input.style, {
                                backgroundColor: this.__color.toHexString(),
                                color: "rgb(" + n + "," + n + "," + n + ")",
                                textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)"
                            })
                    }
                }]),
                e
        }(M)
            , z = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
        function U(t, e, n, i) {
            t.style.background = "",
                a.each(z, (function(r) {
                        t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + i + " 100%); "
                    }
                ))
        }
        function j(t) {
            t.style.background = "",
                t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",
                t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
                t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
        }
        var G = {
            load: function(t, e) {
                var n = e || document
                    , i = n.createElement("link");
                i.type = "text/css",
                    i.rel = "stylesheet",
                    i.href = t,
                    n.getElementsByTagName("head")[0].appendChild(i)
            },
            inject: function(t, e) {
                var n = e || document
                    , i = document.createElement("style");
                i.type = "text/css",
                    i.innerHTML = t;
                var r = n.getElementsByTagName("head")[0];
                try {
                    r.appendChild(i)
                } catch (o) {}
            }
        }
            , V = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'
            , W = function(t, e) {
            var n = t[e];
            return a.isArray(arguments[2]) || a.isObject(arguments[2]) ? new C(t,e,arguments[2]) : a.isNumber(n) ? a.isNumber(arguments[2]) && a.isNumber(arguments[3]) ? a.isNumber(arguments[4]) ? new k(t,e,arguments[2],arguments[3],arguments[4]) : new k(t,e,arguments[2],arguments[3]) : a.isNumber(arguments[4]) ? new D(t,e,{
                min: arguments[2],
                max: arguments[3],
                step: arguments[4]
            }) : new D(t,e,{
                min: arguments[2],
                max: arguments[3]
            }) : a.isString(n) ? new P(t,e) : a.isFunction(n) ? new H(t,e,"") : a.isBoolean(n) ? new R(t,e) : null
        };
        function q(t) {
            setTimeout(t, 1e3 / 60)
        }
        var X = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || q
            , Y = function() {
            function t() {
                m(this, t),
                    this.backgroundElement = document.createElement("div"),
                    a.extend(this.backgroundElement.style, {
                        backgroundColor: "rgba(0,0,0,0.8)",
                        top: 0,
                        left: 0,
                        display: "none",
                        zIndex: "1000",
                        opacity: 0,
                        WebkitTransition: "opacity 0.2s linear",
                        transition: "opacity 0.2s linear"
                    }),
                    L.makeFullscreen(this.backgroundElement),
                    this.backgroundElement.style.position = "fixed",
                    this.domElement = document.createElement("div"),
                    a.extend(this.domElement.style, {
                        position: "fixed",
                        display: "none",
                        zIndex: "1001",
                        opacity: 0,
                        WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                        transition: "transform 0.2s ease-out, opacity 0.2s linear"
                    }),
                    document.body.appendChild(this.backgroundElement),
                    document.body.appendChild(this.domElement);
                var e = this;
                L.bind(this.backgroundElement, "click", (function() {
                        e.hide()
                    }
                ))
            }
            return g(t, [{
                key: "show",
                value: function() {
                    var t = this;
                    this.backgroundElement.style.display = "block",
                        this.domElement.style.display = "block",
                        this.domElement.style.opacity = 0,
                        this.domElement.style.webkitTransform = "scale(1.1)",
                        this.layout(),
                        a.defer((function() {
                                t.backgroundElement.style.opacity = 1,
                                    t.domElement.style.opacity = 1,
                                    t.domElement.style.webkitTransform = "scale(1)"
                            }
                        ))
                }
            }, {
                key: "hide",
                value: function() {
                    var t = this
                        , e = function e() {
                        t.domElement.style.display = "none",
                            t.backgroundElement.style.display = "none",
                            L.unbind(t.domElement, "webkitTransitionEnd", e),
                            L.unbind(t.domElement, "transitionend", e),
                            L.unbind(t.domElement, "oTransitionEnd", e)
                    };
                    L.bind(this.domElement, "webkitTransitionEnd", e),
                        L.bind(this.domElement, "transitionend", e),
                        L.bind(this.domElement, "oTransitionEnd", e),
                        this.backgroundElement.style.opacity = 0,
                        this.domElement.style.opacity = 0,
                        this.domElement.style.webkitTransform = "scale(1.1)"
                }
            }, {
                key: "layout",
                value: function() {
                    this.domElement.style.left = window.innerWidth / 2 - L.getWidth(this.domElement) / 2 + "px",
                        this.domElement.style.top = window.innerHeight / 2 - L.getHeight(this.domElement) / 2 + "px"
                }
            }]),
                t
        }()
            , Z = i(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
        G.inject(Z);
        var J = "dg"
            , K = 72
            , Q = 20
            , $ = "Default"
            , tt = function() {
            try {
                return !!window.localStorage
            } catch (t) {
                return !1
            }
        }()
            , et = void 0
            , nt = !0
            , it = void 0
            , rt = !1
            , ot = []
            , st = function t(e) {
            var n = this
                , i = e || {};
            this.domElement = document.createElement("div"),
                this.__ul = document.createElement("ul"),
                this.domElement.appendChild(this.__ul),
                L.addClass(this.domElement, J),
                this.__folders = {},
                this.__controllers = [],
                this.__rememberedObjects = [],
                this.__rememberedObjectIndecesToControllers = [],
                this.__listening = [],
                i = a.defaults(i, {
                    closeOnTop: !1,
                    autoPlace: !0,
                    width: t.DEFAULT_WIDTH
                }),
                i = a.defaults(i, {
                    resizable: i.autoPlace,
                    hideable: i.autoPlace
                }),
                a.isUndefined(i.load) ? i.load = {
                    preset: $
                } : i.preset && (i.load.preset = i.preset),
            a.isUndefined(i.parent) && i.hideable && ot.push(this),
                i.resizable = a.isUndefined(i.parent) && i.resizable,
            i.autoPlace && a.isUndefined(i.scrollable) && (i.scrollable = !0);
            var r = tt && "true" === localStorage.getItem(pt(this, "isLocal"))
                , o = void 0
                , s = void 0;
            if (Object.defineProperties(this, {
                parent: {
                    get: function() {
                        return i.parent
                    }
                },
                scrollable: {
                    get: function() {
                        return i.scrollable
                    }
                },
                autoPlace: {
                    get: function() {
                        return i.autoPlace
                    }
                },
                closeOnTop: {
                    get: function() {
                        return i.closeOnTop
                    }
                },
                preset: {
                    get: function() {
                        return n.parent ? n.getRoot().preset : i.load.preset
                    },
                    set: function(t) {
                        n.parent ? n.getRoot().preset = t : i.load.preset = t,
                            xt(this),
                            n.revert()
                    }
                },
                width: {
                    get: function() {
                        return i.width
                    },
                    set: function(t) {
                        i.width = t,
                            yt(n, t)
                    }
                },
                name: {
                    get: function() {
                        return i.name
                    },
                    set: function(t) {
                        i.name = t,
                        s && (s.innerHTML = i.name)
                    }
                },
                closed: {
                    get: function() {
                        return i.closed
                    },
                    set: function(e) {
                        i.closed = e,
                            i.closed ? L.addClass(n.__ul, t.CLASS_CLOSED) : L.removeClass(n.__ul, t.CLASS_CLOSED),
                            this.onResize(),
                        n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                    }
                },
                load: {
                    get: function() {
                        return i.load
                    }
                },
                useLocalStorage: {
                    get: function() {
                        return r
                    },
                    set: function(t) {
                        tt && (r = t,
                            t ? L.bind(window, "unload", o) : L.unbind(window, "unload", o),
                            localStorage.setItem(pt(n, "isLocal"), t))
                    }
                }
            }),
                a.isUndefined(i.parent)) {
                if (this.closed = i.closed || !1,
                    L.addClass(this.domElement, t.CLASS_MAIN),
                    L.makeSelectable(this.domElement, !1),
                tt && r) {
                    n.useLocalStorage = !0;
                    var c = localStorage.getItem(pt(this, "gui"));
                    c && (i.load = JSON.parse(c))
                }
                this.__closeButton = document.createElement("div"),
                    this.__closeButton.innerHTML = t.TEXT_CLOSED,
                    L.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON),
                    i.closeOnTop ? (L.addClass(this.__closeButton, t.CLASS_CLOSE_TOP),
                        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (L.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM),
                        this.domElement.appendChild(this.__closeButton)),
                    L.bind(this.__closeButton, "click", (function() {
                            n.closed = !n.closed
                        }
                    ))
            } else {
                void 0 === i.closed && (i.closed = !0);
                var l = document.createTextNode(i.name);
                L.addClass(l, "controller-name"),
                    s = at(n, l);
                var u = function(t) {
                    return t.preventDefault(),
                        n.closed = !n.closed,
                        !1
                };
                L.addClass(this.__ul, t.CLASS_CLOSED),
                    L.addClass(s, "title"),
                    L.bind(s, "click", u),
                i.closed || (this.closed = !1)
            }
            function h() {
                var t = n.getRoot();
                t.width += 1,
                    a.defer((function() {
                            t.width -= 1
                        }
                    ))
            }
            i.autoPlace && (a.isUndefined(i.parent) && (nt && (it = document.createElement("div"),
                L.addClass(it, J),
                L.addClass(it, t.CLASS_AUTO_PLACE_CONTAINER),
                document.body.appendChild(it),
                nt = !1),
                it.appendChild(this.domElement),
                L.addClass(this.domElement, t.CLASS_AUTO_PLACE)),
            this.parent || yt(n, i.width)),
                this.__resizeHandler = function() {
                    n.onResizeDebounced()
                }
                ,
                L.bind(window, "resize", this.__resizeHandler),
                L.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
                L.bind(this.__ul, "transitionend", this.__resizeHandler),
                L.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
                this.onResize(),
            i.resizable && vt(this),
                o = function() {
                    tt && "true" === localStorage.getItem(pt(n, "isLocal")) && localStorage.setItem(pt(n, "gui"), JSON.stringify(n.getSaveObject()))
                }
                ,
                this.saveToLocalStorageIfPossible = o,
            i.parent || h()
        };
        function at(t, e, n) {
            var i = document.createElement("li");
            return e && i.appendChild(e),
                n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i),
                t.onResize(),
                i
        }
        function ct(t) {
            L.unbind(window, "resize", t.__resizeHandler),
            t.saveToLocalStorageIfPossible && L.unbind(window, "unload", t.saveToLocalStorageIfPossible)
        }
        function lt(t, e) {
            var n = t.__preset_select[t.__preset_select.selectedIndex];
            n.innerHTML = e ? n.value + "*" : n.value
        }
        function ut(t, e, n) {
            if (n.__li = e,
                n.__gui = t,
                a.extend(n, {
                    options: function(e) {
                        if (arguments.length > 1) {
                            var i = n.__li.nextElementSibling;
                            return n.remove(),
                                dt(t, n.object, n.property, {
                                    before: i,
                                    factoryArgs: [a.toArray(arguments)]
                                })
                        }
                        if (a.isArray(e) || a.isObject(e)) {
                            var r = n.__li.nextElementSibling;
                            return n.remove(),
                                dt(t, n.object, n.property, {
                                    before: r,
                                    factoryArgs: [e]
                                })
                        }
                    },
                    name: function(t) {
                        return n.__li.firstElementChild.firstElementChild.innerHTML = t,
                            n
                    },
                    listen: function() {
                        return n.__gui.listen(n),
                            n
                    },
                    remove: function() {
                        return n.__gui.remove(n),
                            n
                    }
                }),
            n instanceof k) {
                var i = new D(n.object,n.property,{
                    min: n.__min,
                    max: n.__max,
                    step: n.__step
                });
                a.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function(t) {
                        var e = n[t]
                            , r = i[t];
                        n[t] = i[t] = function() {
                            var t = Array.prototype.slice.call(arguments);
                            return r.apply(i, t),
                                e.apply(n, t)
                        }
                    }
                )),
                    L.addClass(e, "has-slider"),
                    n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild)
            } else if (n instanceof D) {
                var r = function(e) {
                    if (a.isNumber(n.__min) && a.isNumber(n.__max)) {
                        var i = n.__li.firstElementChild.firstElementChild.innerHTML
                            , r = n.__gui.__listening.indexOf(n) > -1;
                        n.remove();
                        var o = dt(t, n.object, n.property, {
                            before: n.__li.nextElementSibling,
                            factoryArgs: [n.__min, n.__max, n.__step]
                        });
                        return o.name(i),
                        r && o.listen(),
                            o
                    }
                    return e
                };
                n.min = a.compose(r, n.min),
                    n.max = a.compose(r, n.max)
            } else
                n instanceof R ? (L.bind(e, "click", (function() {
                        L.fakeEvent(n.__checkbox, "click")
                    }
                )),
                    L.bind(n.__checkbox, "click", (function(t) {
                            t.stopPropagation()
                        }
                    ))) : n instanceof H ? (L.bind(e, "click", (function() {
                        L.fakeEvent(n.__button, "click")
                    }
                )),
                    L.bind(e, "mouseover", (function() {
                            L.addClass(n.__button, "hover")
                        }
                    )),
                    L.bind(e, "mouseout", (function() {
                            L.removeClass(n.__button, "hover")
                        }
                    ))) : n instanceof B && (L.addClass(e, "color"),
                    n.updateDisplay = a.compose((function(t) {
                            return e.style.borderLeftColor = n.__color.toString(),
                                t
                        }
                    ), n.updateDisplay),
                    n.updateDisplay());
            n.setValue = a.compose((function(e) {
                    return t.getRoot().__preset_select && n.isModified() && lt(t.getRoot(), !0),
                        e
                }
            ), n.setValue)
        }
        function ht(t, e) {
            var n = t.getRoot()
                , i = n.__rememberedObjects.indexOf(e.object);
            if (-1 !== i) {
                var r = n.__rememberedObjectIndecesToControllers[i];
                if (void 0 === r && (r = {},
                    n.__rememberedObjectIndecesToControllers[i] = r),
                    r[e.property] = e,
                n.load && n.load.remembered) {
                    var o = n.load.remembered
                        , s = void 0;
                    if (o[t.preset])
                        s = o[t.preset];
                    else {
                        if (!o[$])
                            return;
                        s = o[$]
                    }
                    if (s[i] && void 0 !== s[i][e.property]) {
                        var a = s[i][e.property];
                        e.initialValue = a,
                            e.setValue(a)
                    }
                }
            }
        }
        function dt(t, e, n, i) {
            if (void 0 === e[n])
                throw new Error('Object "' + e + '" has no property "' + n + '"');
            var r = void 0;
            if (i.color)
                r = new B(e,n);
            else {
                var o = [e, n].concat(i.factoryArgs);
                r = W.apply(t, o)
            }
            i.before instanceof M && (i.before = i.before.__li),
                ht(t, r),
                L.addClass(r.domElement, "c");
            var s = document.createElement("span");
            L.addClass(s, "property-name"),
                s.innerHTML = r.property;
            var a = document.createElement("div");
            a.appendChild(s),
                a.appendChild(r.domElement);
            var c = at(t, a, i.before);
            return L.addClass(c, st.CLASS_CONTROLLER_ROW),
                r instanceof B ? L.addClass(c, "color") : L.addClass(c, f(r.getValue())),
                ut(t, c, r),
                t.__controllers.push(r),
                r
        }
        function pt(t, e) {
            return document.location.href + "." + e
        }
        function ft(t, e, n) {
            var i = document.createElement("option");
            i.innerHTML = e,
                i.value = e,
                t.__preset_select.appendChild(i),
            n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
        }
        function mt(t, e) {
            e.style.display = t.useLocalStorage ? "block" : "none"
        }
        function gt(t) {
            var e = t.__save_row = document.createElement("li");
            L.addClass(t.domElement, "has-save"),
                t.__ul.insertBefore(e, t.__ul.firstChild),
                L.addClass(e, "save-row");
            var n = document.createElement("span");
            n.innerHTML = "&nbsp;",
                L.addClass(n, "button gears");
            var i = document.createElement("span");
            i.innerHTML = "Save",
                L.addClass(i, "button"),
                L.addClass(i, "save");
            var r = document.createElement("span");
            r.innerHTML = "New",
                L.addClass(r, "button"),
                L.addClass(r, "save-as");
            var o = document.createElement("span");
            o.innerHTML = "Revert",
                L.addClass(o, "button"),
                L.addClass(o, "revert");
            var s = t.__preset_select = document.createElement("select");
            if (t.load && t.load.remembered ? a.each(t.load.remembered, (function(e, n) {
                    ft(t, n, n === t.preset)
                }
            )) : ft(t, $, !1),
                L.bind(s, "change", (function() {
                        for (var e = 0; e < t.__preset_select.length; e++)
                            t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                        t.preset = this.value
                    }
                )),
                e.appendChild(s),
                e.appendChild(n),
                e.appendChild(i),
                e.appendChild(r),
                e.appendChild(o),
                tt) {
                var c = document.getElementById("dg-local-explain")
                    , l = document.getElementById("dg-local-storage")
                    , u = document.getElementById("dg-save-locally");
                u.style.display = "block",
                "true" === localStorage.getItem(pt(t, "isLocal")) && l.setAttribute("checked", "checked"),
                    mt(t, c),
                    L.bind(l, "change", (function() {
                            t.useLocalStorage = !t.useLocalStorage,
                                mt(t, c)
                        }
                    ))
            }
            var h = document.getElementById("dg-new-constructor");
            L.bind(h, "keydown", (function(t) {
                    !t.metaKey || 67 !== t.which && 67 !== t.keyCode || et.hide()
                }
            )),
                L.bind(n, "click", (function() {
                        h.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2),
                            et.show(),
                            h.focus(),
                            h.select()
                    }
                )),
                L.bind(i, "click", (function() {
                        t.save()
                    }
                )),
                L.bind(r, "click", (function() {
                        var e = prompt("Enter a new preset name.");
                        e && t.saveAs(e)
                    }
                )),
                L.bind(o, "click", (function() {
                        t.revert()
                    }
                ))
        }
        function vt(t) {
            var e = void 0;
            function n(n) {
                return n.preventDefault(),
                    t.width += e - n.clientX,
                    t.onResize(),
                    e = n.clientX,
                    !1
            }
            function i() {
                L.removeClass(t.__closeButton, st.CLASS_DRAG),
                    L.unbind(window, "mousemove", n),
                    L.unbind(window, "mouseup", i)
            }
            function r(r) {
                return r.preventDefault(),
                    e = r.clientX,
                    L.addClass(t.__closeButton, st.CLASS_DRAG),
                    L.bind(window, "mousemove", n),
                    L.bind(window, "mouseup", i),
                    !1
            }
            t.__resize_handle = document.createElement("div"),
                a.extend(t.__resize_handle.style, {
                    width: "6px",
                    marginLeft: "-3px",
                    height: "200px",
                    cursor: "ew-resize",
                    position: "absolute"
                }),
                L.bind(t.__resize_handle, "mousedown", r),
                L.bind(t.__closeButton, "mousedown", r),
                t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
        }
        function yt(t, e) {
            t.domElement.style.width = e + "px",
            t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"),
            t.__closeButton && (t.__closeButton.style.width = e + "px")
        }
        function _t(t, e) {
            var n = {};
            return a.each(t.__rememberedObjects, (function(i, r) {
                    var o = {}
                        , s = t.__rememberedObjectIndecesToControllers[r];
                    a.each(s, (function(t, n) {
                            o[n] = e ? t.initialValue : t.getValue()
                        }
                    )),
                        n[r] = o
                }
            )),
                n
        }
        function xt(t) {
            for (var e = 0; e < t.__preset_select.length; e++)
                t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
        }
        function bt(t) {
            0 !== t.length && X.call(window, (function() {
                    bt(t)
                }
            )),
                a.each(t, (function(t) {
                        t.updateDisplay()
                    }
                ))
        }
        st.toggleHide = function() {
            rt = !rt,
                a.each(ot, (function(t) {
                        t.domElement.style.display = rt ? "none" : ""
                    }
                ))
        }
            ,
            st.CLASS_AUTO_PLACE = "a",
            st.CLASS_AUTO_PLACE_CONTAINER = "ac",
            st.CLASS_MAIN = "main",
            st.CLASS_CONTROLLER_ROW = "cr",
            st.CLASS_TOO_TALL = "taller-than-window",
            st.CLASS_CLOSED = "closed",
            st.CLASS_CLOSE_BUTTON = "close-button",
            st.CLASS_CLOSE_TOP = "close-top",
            st.CLASS_CLOSE_BOTTOM = "close-bottom",
            st.CLASS_DRAG = "drag",
            st.DEFAULT_WIDTH = 245,
            st.TEXT_CLOSED = "Close Controls",
            st.TEXT_OPEN = "Open Controls",
            st._keydownHandler = function(t) {
                "text" === document.activeElement.type || t.which !== K && t.keyCode !== K || st.toggleHide()
            }
            ,
            L.bind(window, "keydown", st._keydownHandler, !1),
            a.extend(st.prototype, {
                add: function(t, e) {
                    return dt(this, t, e, {
                        factoryArgs: Array.prototype.slice.call(arguments, 2)
                    })
                },
                addColor: function(t, e) {
                    return dt(this, t, e, {
                        color: !0
                    })
                },
                remove: function(t) {
                    this.__ul.removeChild(t.__li),
                        this.__controllers.splice(this.__controllers.indexOf(t), 1);
                    var e = this;
                    a.defer((function() {
                            e.onResize()
                        }
                    ))
                },
                destroy: function() {
                    if (this.parent)
                        throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                    this.autoPlace && it.removeChild(this.domElement);
                    var t = this;
                    a.each(this.__folders, (function(e) {
                            t.removeFolder(e)
                        }
                    )),
                        L.unbind(window, "keydown", st._keydownHandler, !1),
                        ct(this)
                },
                addFolder: function(t) {
                    if (void 0 !== this.__folders[t])
                        throw new Error('You already have a folder in this GUI by the name "' + t + '"');
                    var e = {
                        name: t,
                        parent: this
                    };
                    e.autoPlace = this.autoPlace,
                    this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed,
                        e.load = this.load.folders[t]);
                    var n = new st(e);
                    this.__folders[t] = n;
                    var i = at(this, n.domElement);
                    return L.addClass(i, "folder"),
                        n
                },
                removeFolder: function(t) {
                    this.__ul.removeChild(t.domElement.parentElement),
                        delete this.__folders[t.name],
                    this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name],
                        ct(t);
                    var e = this;
                    a.each(t.__folders, (function(e) {
                            t.removeFolder(e)
                        }
                    )),
                        a.defer((function() {
                                e.onResize()
                            }
                        ))
                },
                open: function() {
                    this.closed = !1
                },
                close: function() {
                    this.closed = !0
                },
                hide: function() {
                    this.domElement.style.display = "none"
                },
                show: function() {
                    this.domElement.style.display = ""
                },
                onResize: function() {
                    var t = this.getRoot();
                    if (t.scrollable) {
                        var e = L.getOffset(t.__ul).top
                            , n = 0;
                        a.each(t.__ul.childNodes, (function(e) {
                                t.autoPlace && e === t.__save_row || (n += L.getHeight(e))
                            }
                        )),
                            window.innerHeight - e - Q < n ? (L.addClass(t.domElement, st.CLASS_TOO_TALL),
                                t.__ul.style.height = window.innerHeight - e - Q + "px") : (L.removeClass(t.domElement, st.CLASS_TOO_TALL),
                                t.__ul.style.height = "auto")
                    }
                    t.__resize_handle && a.defer((function() {
                            t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                        }
                    )),
                    t.__closeButton && (t.__closeButton.style.width = t.width + "px")
                },
                onResizeDebounced: a.debounce((function() {
                        this.onResize()
                    }
                ), 50),
                remember: function() {
                    if (a.isUndefined(et) && (et = new Y,
                        et.domElement.innerHTML = V),
                        this.parent)
                        throw new Error("You can only call remember on a top level GUI.");
                    var t = this;
                    a.each(Array.prototype.slice.call(arguments), (function(e) {
                            0 === t.__rememberedObjects.length && gt(t),
                            -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
                        }
                    )),
                    this.autoPlace && yt(this, this.width)
                },
                getRoot: function() {
                    var t = this;
                    while (t.parent)
                        t = t.parent;
                    return t
                },
                getSaveObject: function() {
                    var t = this.load;
                    return t.closed = this.closed,
                    this.__rememberedObjects.length > 0 && (t.preset = this.preset,
                    t.remembered || (t.remembered = {}),
                        t.remembered[this.preset] = _t(this)),
                        t.folders = {},
                        a.each(this.__folders, (function(e, n) {
                                t.folders[n] = e.getSaveObject()
                            }
                        )),
                        t
                },
                save: function() {
                    this.load.remembered || (this.load.remembered = {}),
                        this.load.remembered[this.preset] = _t(this),
                        lt(this, !1),
                        this.saveToLocalStorageIfPossible()
                },
                saveAs: function(t) {
                    this.load.remembered || (this.load.remembered = {},
                        this.load.remembered[$] = _t(this, !0)),
                        this.load.remembered[t] = _t(this),
                        this.preset = t,
                        ft(this, t, !0),
                        this.saveToLocalStorageIfPossible()
                },
                revert: function(t) {
                    a.each(this.__controllers, (function(e) {
                            this.getRoot().load.remembered ? ht(t || this.getRoot(), e) : e.setValue(e.initialValue),
                            e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
                        }
                    ), this),
                        a.each(this.__folders, (function(t) {
                                t.revert(t)
                            }
                        )),
                    t || lt(this.getRoot(), !1)
                },
                listen: function(t) {
                    var e = 0 === this.__listening.length;
                    this.__listening.push(t),
                    e && bt(this.__listening)
                },
                updateDisplay: function() {
                    a.each(this.__controllers, (function(t) {
                            t.updateDisplay()
                        }
                    )),
                        a.each(this.__folders, (function(t) {
                                t.updateDisplay()
                            }
                        ))
                }
            });
        var wt = st
    },
    bee2: function(t, e, n) {
        "use strict";
        function i(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                    i.configurable = !0,
                "value"in i && (i.writable = !0),
                    Object.defineProperty(t, i.key, i)
            }
        }
        function r(t, e, n) {
            return e && i(t.prototype, e),
            n && i(t, n),
                t
        }
        n.d(e, "a", (function() {
                return r
            }
        ))
    },
    c04e: function(t, e, n) {
        var i = n("861d");
        t.exports = function(t, e) {
            if (!i(t))
                return t;
            var n, r;
            if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                return r;
            if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t)))
                return r;
            if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                return r;
            throw TypeError("Can't convert object to primitive value")
        }
    },
    c1ac: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").filter
            , o = n("1448")
            , s = i.aTypedArray
            , a = i.exportTypedArrayMethod;
        a("filter", (function(t) {
                var e = r(s(this), t, arguments.length > 1 ? arguments[1] : void 0);
                return o(this, e)
            }
        ))
    },
    c430: function(t, e) {
        t.exports = !1
    },
    c6b6: function(t, e) {
        var n = {}.toString;
        t.exports = function(t) {
            return n.call(t).slice(8, -1)
        }
    },
    c6cd: function(t, e, n) {
        var i = n("da84")
            , r = n("ce4e")
            , o = "__core-js_shared__"
            , s = i[o] || r(o, {});
        t.exports = s
    },
    c8ba: function(t, e) {
        var n;
        n = function() {
            return this
        }();
        try {
            n = n || new Function("return this")()
        } catch (i) {
            "object" === typeof window && (n = window)
        }
        t.exports = n
    },
    ca84: function(t, e, n) {
        var i = n("5135")
            , r = n("fc6a")
            , o = n("4d64").indexOf
            , s = n("d012");
        t.exports = function(t, e) {
            var n, a = r(t), c = 0, l = [];
            for (n in a)
                !i(s, n) && i(a, n) && l.push(n);
            while (e.length > c)
                i(a, n = e[c++]) && (~o(l, n) || l.push(n));
            return l
        }
    },
    ca91: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("d58f").left
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("reduce", (function(t) {
                return r(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    cc12: function(t, e, n) {
        var i = n("da84")
            , r = n("861d")
            , o = i.document
            , s = r(o) && r(o.createElement);
        t.exports = function(t) {
            return s ? o.createElement(t) : {}
        }
    },
    cca6: function(t, e, n) {
        var i = n("23e7")
            , r = n("60da");
        i({
            target: "Object",
            stat: !0,
            forced: Object.assign !== r
        }, {
            assign: r
        })
    },
    cd26: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = i.aTypedArray
            , o = i.exportTypedArrayMethod
            , s = Math.floor;
        o("reverse", (function() {
                var t, e = this, n = r(e).length, i = s(n / 2), o = 0;
                while (o < i)
                    t = e[o],
                        e[o++] = e[--n],
                        e[n] = t;
                return e
            }
        ))
    },
    cdf9: function(t, e, n) {
        var i = n("825a")
            , r = n("861d")
            , o = n("f069");
        t.exports = function(t, e) {
            if (i(t),
            r(e) && e.constructor === t)
                return e;
            var n = o.f(t)
                , s = n.resolve;
            return s(e),
                n.promise
        }
    },
    ce4e: function(t, e, n) {
        var i = n("da84")
            , r = n("9112");
        t.exports = function(t, e) {
            try {
                r(i, t, e)
            } catch (n) {
                i[t] = e
            }
            return e
        }
    },
    d012: function(t, e) {
        t.exports = {}
    },
    d039: function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (e) {
                return !0
            }
        }
    },
    d066: function(t, e, n) {
        var i = n("428f")
            , r = n("da84")
            , o = function(t) {
            return "function" == typeof t ? t : void 0
        };
        t.exports = function(t, e) {
            return arguments.length < 2 ? o(i[t]) || o(r[t]) : i[t] && i[t][e] || r[t] && r[t][e]
        }
    },
    d139: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").find
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("find", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    d1e7: function(t, e, n) {
        "use strict";
        var i = {}.propertyIsEnumerable
            , r = Object.getOwnPropertyDescriptor
            , o = r && !i.call({
            1: 2
        }, 1);
        e.f = o ? function(t) {
                var e = r(this, t);
                return !!e && e.enumerable
            }
            : i
    },
    d2bb: function(t, e, n) {
        var i = n("825a")
            , r = n("3bbe");
        t.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
            var t, e = !1, n = {};
            try {
                t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set,
                    t.call(n, []),
                    e = n instanceof Array
            } catch (o) {}
            return function(n, o) {
                return i(n),
                    r(o),
                    e ? t.call(n, o) : n.__proto__ = o,
                    n
            }
        }() : void 0)
    },
    d3b7: function(t, e, n) {
        var i = n("00ee")
            , r = n("6eeb")
            , o = n("b041");
        i || r(Object.prototype, "toString", o, {
            unsafe: !0
        })
    },
    d44e: function(t, e, n) {
        var i = n("9bf2").f
            , r = n("5135")
            , o = n("b622")
            , s = o("toStringTag");
        t.exports = function(t, e, n) {
            t && !r(t = n ? t : t.prototype, s) && i(t, s, {
                configurable: !0,
                value: e
            })
        }
    },
    d4ec: function(t, e, n) {
        "use strict";
        function i(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }
        n.d(e, "a", (function() {
                return i
            }
        ))
    },
    d58f: function(t, e, n) {
        var i = n("1c0b")
            , r = n("7b0b")
            , o = n("44ad")
            , s = n("50c4")
            , a = function(t) {
            return function(e, n, a, c) {
                i(n);
                var l = r(e)
                    , u = o(l)
                    , h = s(l.length)
                    , d = t ? h - 1 : 0
                    , p = t ? -1 : 1;
                if (a < 2)
                    while (1) {
                        if (d in u) {
                            c = u[d],
                                d += p;
                            break
                        }
                        if (d += p,
                            t ? d < 0 : h <= d)
                            throw TypeError("Reduce of empty array with no initial value")
                    }
                for (; t ? d >= 0 : h > d; d += p)
                    d in u && (c = n(c, u[d], d, l));
                return c
            }
        };
        t.exports = {
            left: a(!1),
            right: a(!0)
        }
    },
    d5d6: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("b727").forEach
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("forEach", (function(t) {
                r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    da84: function(t, e, n) {
        (function(e) {
                var n = function(t) {
                    return t && t.Math == Math && t
                };
                t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || function() {
                    return this
                }() || Function("return this")()
            }
        ).call(this, n("c8ba"))
    },
    df75: function(t, e, n) {
        var i = n("ca84")
            , r = n("7839");
        t.exports = Object.keys || function(t) {
            return i(t, r)
        }
    },
    e163: function(t, e, n) {
        var i = n("5135")
            , r = n("7b0b")
            , o = n("f772")
            , s = n("e177")
            , a = o("IE_PROTO")
            , c = Object.prototype;
        t.exports = s ? Object.getPrototypeOf : function(t) {
            return t = r(t),
                i(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? c : null
        }
    },
    e177: function(t, e, n) {
        var i = n("d039");
        t.exports = !i((function() {
                function t() {}
                return t.prototype.constructor = null,
                Object.getPrototypeOf(new t) !== t.prototype
            }
        ))
    },
    e260: function(t, e, n) {
        "use strict";
        var i = n("fc6a")
            , r = n("44d2")
            , o = n("3f8c")
            , s = n("69f3")
            , a = n("7dd0")
            , c = "Array Iterator"
            , l = s.set
            , u = s.getterFor(c);
        t.exports = a(Array, "Array", (function(t, e) {
                l(this, {
                    type: c,
                    target: i(t),
                    index: 0,
                    kind: e
                })
            }
        ), (function() {
                var t = u(this)
                    , e = t.target
                    , n = t.kind
                    , i = t.index++;
                return !e || i >= e.length ? (t.target = void 0,
                    {
                        value: void 0,
                        done: !0
                    }) : "keys" == n ? {
                    value: i,
                    done: !1
                } : "values" == n ? {
                    value: e[i],
                    done: !1
                } : {
                    value: [i, e[i]],
                    done: !1
                }
            }
        ), "values"),
            o.Arguments = o.Array,
            r("keys"),
            r("values"),
            r("entries")
    },
    e2cc: function(t, e, n) {
        var i = n("6eeb");
        t.exports = function(t, e, n) {
            for (var r in e)
                i(t, r, e[r], n);
            return t
        }
    },
    e58c: function(t, e, n) {
        "use strict";
        var i = n("fc6a")
            , r = n("a691")
            , o = n("50c4")
            , s = n("a640")
            , a = Math.min
            , c = [].lastIndexOf
            , l = !!c && 1 / [1].lastIndexOf(1, -0) < 0
            , u = s("lastIndexOf")
            , h = l || !u;
        t.exports = h ? function(t) {
                if (l)
                    return c.apply(this, arguments) || 0;
                var e = i(this)
                    , n = o(e.length)
                    , s = n - 1;
                for (arguments.length > 1 && (s = a(s, r(arguments[1]))),
                     s < 0 && (s = n + s); s >= 0; s--)
                    if (s in e && e[s] === t)
                        return s || 0;
                return -1
            }
            : c
    },
    e667: function(t, e) {
        t.exports = function(t) {
            try {
                return {
                    error: !1,
                    value: t()
                }
            } catch (e) {
                return {
                    error: !0,
                    value: e
                }
            }
        }
    },
    e6cf: function(t, e, n) {
        "use strict";
        var i, r, o, s, a = n("23e7"), c = n("c430"), l = n("da84"), u = n("d066"), h = n("fea9"), d = n("6eeb"), p = n("e2cc"), f = n("d44e"), m = n("2626"), g = n("861d"), v = n("1c0b"), y = n("19aa"), _ = n("8925"), x = n("2266"), b = n("1c7e"), w = n("4840"), M = n("2cf4").set, S = n("b575"), E = n("cdf9"), T = n("44de"), A = n("f069"), L = n("e667"), R = n("69f3"), C = n("94ca"), P = n("b622"), O = n("605d"), I = n("2d00"), N = P("species"), D = "Promise", F = R.get, k = R.set, H = R.getterFor(D), B = h, z = l.TypeError, U = l.document, j = l.process, G = u("fetch"), V = A.f, W = V, q = !!(U && U.createEvent && l.dispatchEvent), X = "function" == typeof PromiseRejectionEvent, Y = "unhandledrejection", Z = "rejectionhandled", J = 0, K = 1, Q = 2, $ = 1, tt = 2, et = C(D, (function() {
                var t = _(B) !== String(B);
                if (!t) {
                    if (66 === I)
                        return !0;
                    if (!O && !X)
                        return !0
                }
                if (c && !B.prototype["finally"])
                    return !0;
                if (I >= 51 && /native code/.test(B))
                    return !1;
                var e = B.resolve(1)
                    , n = function(t) {
                    t((function() {}
                    ), (function() {}
                    ))
                }
                    , i = e.constructor = {};
                return i[N] = n,
                    !(e.then((function() {}
                    ))instanceof n)
            }
        )), nt = et || !b((function(t) {
                B.all(t)["catch"]((function() {}
                ))
            }
        )), it = function(t) {
            var e;
            return !(!g(t) || "function" != typeof (e = t.then)) && e
        }, rt = function(t, e) {
            if (!t.notified) {
                t.notified = !0;
                var n = t.reactions;
                S((function() {
                        var i = t.value
                            , r = t.state == K
                            , o = 0;
                        while (n.length > o) {
                            var s, a, c, l = n[o++], u = r ? l.ok : l.fail, h = l.resolve, d = l.reject, p = l.domain;
                            try {
                                u ? (r || (t.rejection === tt && ct(t),
                                    t.rejection = $),
                                    !0 === u ? s = i : (p && p.enter(),
                                        s = u(i),
                                    p && (p.exit(),
                                        c = !0)),
                                    s === l.promise ? d(z("Promise-chain cycle")) : (a = it(s)) ? a.call(s, h, d) : h(s)) : d(i)
                            } catch (f) {
                                p && !c && p.exit(),
                                    d(f)
                            }
                        }
                        t.reactions = [],
                            t.notified = !1,
                        e && !t.rejection && st(t)
                    }
                ))
            }
        }, ot = function(t, e, n) {
            var i, r;
            q ? (i = U.createEvent("Event"),
                i.promise = e,
                i.reason = n,
                i.initEvent(t, !1, !0),
                l.dispatchEvent(i)) : i = {
                promise: e,
                reason: n
            },
                !X && (r = l["on" + t]) ? r(i) : t === Y && T("Unhandled promise rejection", n)
        }, st = function(t) {
            M.call(l, (function() {
                    var e, n = t.facade, i = t.value, r = at(t);
                    if (r && (e = L((function() {
                            O ? j.emit("unhandledRejection", i, n) : ot(Y, n, i)
                        }
                    )),
                        t.rejection = O || at(t) ? tt : $,
                        e.error))
                        throw e.value
                }
            ))
        }, at = function(t) {
            return t.rejection !== $ && !t.parent
        }, ct = function(t) {
            M.call(l, (function() {
                    var e = t.facade;
                    O ? j.emit("rejectionHandled", e) : ot(Z, e, t.value)
                }
            ))
        }, lt = function(t, e, n) {
            return function(i) {
                t(e, i, n)
            }
        }, ut = function(t, e, n) {
            t.done || (t.done = !0,
            n && (t = n),
                t.value = e,
                t.state = Q,
                rt(t, !0))
        }, ht = function(t, e, n) {
            if (!t.done) {
                t.done = !0,
                n && (t = n);
                try {
                    if (t.facade === e)
                        throw z("Promise can't be resolved itself");
                    var i = it(e);
                    i ? S((function() {
                            var n = {
                                done: !1
                            };
                            try {
                                i.call(e, lt(ht, n, t), lt(ut, n, t))
                            } catch (r) {
                                ut(n, r, t)
                            }
                        }
                    )) : (t.value = e,
                        t.state = K,
                        rt(t, !1))
                } catch (r) {
                    ut({
                        done: !1
                    }, r, t)
                }
            }
        };
        et && (B = function(t) {
            y(this, B, D),
                v(t),
                i.call(this);
            var e = F(this);
            try {
                t(lt(ht, e), lt(ut, e))
            } catch (n) {
                ut(e, n)
            }
        }
            ,
            i = function(t) {
                k(this, {
                    type: D,
                    done: !1,
                    notified: !1,
                    parent: !1,
                    reactions: [],
                    rejection: !1,
                    state: J,
                    value: void 0
                })
            }
            ,
            i.prototype = p(B.prototype, {
                then: function(t, e) {
                    var n = H(this)
                        , i = V(w(this, B));
                    return i.ok = "function" != typeof t || t,
                        i.fail = "function" == typeof e && e,
                        i.domain = O ? j.domain : void 0,
                        n.parent = !0,
                        n.reactions.push(i),
                    n.state != J && rt(n, !1),
                        i.promise
                },
                catch: function(t) {
                    return this.then(void 0, t)
                }
            }),
            r = function() {
                var t = new i
                    , e = F(t);
                this.promise = t,
                    this.resolve = lt(ht, e),
                    this.reject = lt(ut, e)
            }
            ,
            A.f = V = function(t) {
                return t === B || t === o ? new r(t) : W(t)
            }
            ,
        c || "function" != typeof h || (s = h.prototype.then,
            d(h.prototype, "then", (function(t, e) {
                    var n = this;
                    return new B((function(t, e) {
                            s.call(n, t, e)
                        }
                    )).then(t, e)
                }
            ), {
                unsafe: !0
            }),
        "function" == typeof G && a({
            global: !0,
            enumerable: !0,
            forced: !0
        }, {
            fetch: function(t) {
                return E(B, G.apply(l, arguments))
            }
        }))),
            a({
                global: !0,
                wrap: !0,
                forced: et
            }, {
                Promise: B
            }),
            f(B, D, !1, !0),
            m(D),
            o = u(D),
            a({
                target: D,
                stat: !0,
                forced: et
            }, {
                reject: function(t) {
                    var e = V(this);
                    return e.reject.call(void 0, t),
                        e.promise
                }
            }),
            a({
                target: D,
                stat: !0,
                forced: c || et
            }, {
                resolve: function(t) {
                    return E(c && this === o ? B : this, t)
                }
            }),
            a({
                target: D,
                stat: !0,
                forced: nt
            }, {
                all: function(t) {
                    var e = this
                        , n = V(e)
                        , i = n.resolve
                        , r = n.reject
                        , o = L((function() {
                            var n = v(e.resolve)
                                , o = []
                                , s = 0
                                , a = 1;
                            x(t, (function(t) {
                                    var c = s++
                                        , l = !1;
                                    o.push(void 0),
                                        a++,
                                        n.call(e, t).then((function(t) {
                                                l || (l = !0,
                                                    o[c] = t,
                                                --a || i(o))
                                            }
                                        ), r)
                                }
                            )),
                            --a || i(o)
                        }
                    ));
                    return o.error && r(o.value),
                        n.promise
                },
                race: function(t) {
                    var e = this
                        , n = V(e)
                        , i = n.reject
                        , r = L((function() {
                            var r = v(e.resolve);
                            x(t, (function(t) {
                                    r.call(e, t).then(n.resolve, i)
                                }
                            ))
                        }
                    ));
                    return r.error && i(r.value),
                        n.promise
                }
            })
    },
    e893: function(t, e, n) {
        var i = n("5135")
            , r = n("56ef")
            , o = n("06cf")
            , s = n("9bf2");
        t.exports = function(t, e) {
            for (var n = r(e), a = s.f, c = o.f, l = 0; l < n.length; l++) {
                var u = n[l];
                i(t, u) || a(t, u, c(e, u))
            }
        }
    },
    e8b5: function(t, e, n) {
        var i = n("c6b6");
        t.exports = Array.isArray || function(t) {
            return "Array" == i(t)
        }
    },
    e91f: function(t, e, n) {
        "use strict";
        var i = n("ebb5")
            , r = n("4d64").indexOf
            , o = i.aTypedArray
            , s = i.exportTypedArrayMethod;
        s("indexOf", (function(t) {
                return r(o(this), t, arguments.length > 1 ? arguments[1] : void 0)
            }
        ))
    },
    e95a: function(t, e, n) {
        var i = n("b622")
            , r = n("3f8c")
            , o = i("iterator")
            , s = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (r.Array === t || s[o] === t)
        }
    },
    ebb5: function(t, e, n) {
        "use strict";
        var i, r = n("a981"), o = n("83ab"), s = n("da84"), a = n("861d"), c = n("5135"), l = n("f5df"), u = n("9112"), h = n("6eeb"), d = n("9bf2").f, p = n("e163"), f = n("d2bb"), m = n("b622"), g = n("90e3"), v = s.Int8Array, y = v && v.prototype, _ = s.Uint8ClampedArray, x = _ && _.prototype, b = v && p(v), w = y && p(y), M = Object.prototype, S = M.isPrototypeOf, E = m("toStringTag"), T = g("TYPED_ARRAY_TAG"), A = r && !!f && "Opera" !== l(s.opera), L = !1, R = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
        }, C = {
            BigInt64Array: 8,
            BigUint64Array: 8
        }, P = function(t) {
            if (!a(t))
                return !1;
            var e = l(t);
            return "DataView" === e || c(R, e) || c(C, e)
        }, O = function(t) {
            if (!a(t))
                return !1;
            var e = l(t);
            return c(R, e) || c(C, e)
        }, I = function(t) {
            if (O(t))
                return t;
            throw TypeError("Target is not a typed array")
        }, N = function(t) {
            if (f) {
                if (S.call(b, t))
                    return t
            } else
                for (var e in R)
                    if (c(R, i)) {
                        var n = s[e];
                        if (n && (t === n || S.call(n, t)))
                            return t
                    }
            throw TypeError("Target is not a typed array constructor")
        }, D = function(t, e, n) {
            if (o) {
                if (n)
                    for (var i in R) {
                        var r = s[i];
                        r && c(r.prototype, t) && delete r.prototype[t]
                    }
                w[t] && !n || h(w, t, n ? e : A && y[t] || e)
            }
        }, F = function(t, e, n) {
            var i, r;
            if (o) {
                if (f) {
                    if (n)
                        for (i in R)
                            r = s[i],
                            r && c(r, t) && delete r[t];
                    if (b[t] && !n)
                        return;
                    try {
                        return h(b, t, n ? e : A && v[t] || e)
                    } catch (a) {}
                }
                for (i in R)
                    r = s[i],
                    !r || r[t] && !n || h(r, t, e)
            }
        };
        for (i in R)
            s[i] || (A = !1);
        if ((!A || "function" != typeof b || b === Function.prototype) && (b = function() {
            throw TypeError("Incorrect invocation")
        }
            ,
            A))
            for (i in R)
                s[i] && f(s[i], b);
        if ((!A || !w || w === M) && (w = b.prototype,
            A))
            for (i in R)
                s[i] && f(s[i].prototype, w);
        if (A && p(x) !== w && f(x, w),
        o && !c(w, E))
            for (i in L = !0,
                d(w, E, {
                    get: function() {
                        return a(this) ? this[T] : void 0
                    }
                }),
                R)
                s[i] && u(s[i], T, i);
        t.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS: A,
            TYPED_ARRAY_TAG: L && T,
            aTypedArray: I,
            aTypedArrayConstructor: N,
            exportTypedArrayMethod: D,
            exportTypedArrayStaticMethod: F,
            isView: P,
            isTypedArray: O,
            TypedArray: b,
            TypedArrayPrototype: w
        }
    },
    f069: function(t, e, n) {
        "use strict";
        var i = n("1c0b")
            , r = function(t) {
            var e, n;
            this.promise = new t((function(t, i) {
                    if (void 0 !== e || void 0 !== n)
                        throw TypeError("Bad Promise constructor");
                    e = t,
                        n = i
                }
            )),
                this.resolve = i(e),
                this.reject = i(n)
        };
        t.exports.f = function(t) {
            return new r(t)
        }
    },
    f5df: function(t, e, n) {
        var i = n("00ee")
            , r = n("c6b6")
            , o = n("b622")
            , s = o("toStringTag")
            , a = "Arguments" == r(function() {
            return arguments
        }())
            , c = function(t, e) {
            try {
                return t[e]
            } catch (n) {}
        };
        t.exports = i ? r : function(t) {
            var e, n, i;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = c(e = Object(t), s)) ? n : a ? r(e) : "Object" == (i = r(e)) && "function" == typeof e.callee ? "Arguments" : i
        }
    },
    f772: function(t, e, n) {
        var i = n("5692")
            , r = n("90e3")
            , o = i("keys");
        t.exports = function(t) {
            return o[t] || (o[t] = r(t))
        }
    },
    f8cd: function(t, e, n) {
        var i = n("a691");
        t.exports = function(t) {
            var e = i(t);
            if (e < 0)
                throw RangeError("The argument can't be less than 0");
            return e
        }
    },
    fc6a: function(t, e, n) {
        var i = n("44ad")
            , r = n("1d80");
        t.exports = function(t) {
            return i(r(t))
        }
    },
    fdbc: function(t, e) {
        t.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
        }
    },
    fdbf: function(t, e, n) {
        var i = n("4930");
        t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator
    },
    fea9: function(t, e, n) {
        var i = n("da84");
        t.exports = i.Promise
    }
}]);
//# sourceMappingURL=chunk-vendors.04db03a4.js.map
